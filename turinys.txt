Programavimo kalba „LaborasLang“
Bakalauro baigiamasis darbas


Techininė užduotis
Autentiškumo patvirtinimas
Santrauka
Summary
Lentelių sąrašas
Terminų ir santrumpų žodynas ;; TO DO: sort by name

	Asemblis – failas, kuris yra LaborasLang programos kompiliavimo rezultatas. 
	CIL (Common Intermediate Language) – kalba, kurią supranta ir geba vykdyti CLI implementacijų vykdymo aplinkos.
	CLI (Common Language Infrastructure) – tai specifikacija, aprašanti virtualią vykdymo aplinką ir CIL kodą. CLI yra specifikuota ECMA-335 tarptautiniame standarte. Dvi populiariausios CLI implementacijos yra CLR (.NET karkaso dalis) ir Mono Runtime.
	LaborasLang programa – vienas ar daugiau išeities kodo failų, kurie nurodomi LaborasLang kompiliatoriui kaip duomenys. 
	Įeities taškas (entry point) – speciali funkcija, kuri yra iškviečiama paleidus vykdomąjį failą.
	Išraiška (expression) – kodo fragmentas, kurį įvykdžius galima gauti reikšmę, arba jam nustatyti reikšmę.
	Dešininė išraiška (rvalue) – išraiška, kurios reikšmę galima nuskaityti.
	Kairinė išraiška (lvalue) – išraiška, kuriai galima nustatyti reikšmę.
	Lokalus kintamasis (local variable) – kintamasis deklaruotas funkcijoje.
	Globalus kintamasis (global variable) – kintamasis deklaruotas faile.
	Galiojimo sritis (scope) – taisyklės nusakančios kintamųjų pasiekiamumą.
	Sąveika (interoperability) – sistemos galimybė bendrauti su kitomis sistemomis. Kalbos kontekste tai yra galimybė naudoti resursus sukurtus kitomis kalbomis, taip pat kitose kalbose naudoti LaborasLang resursus.
	Blokas, kodo blokas – Kodo fragmentas apribotas simboliais „{“ ir „}“.
	Literalas (literal) – Kode įrašyta reikšmė.
	Vertės tipas (value type) – tipas, kurio kintamasis laiko reikšmę.
	Nuorodos tipas (reference type) – tipas, kurio kintamasis laiko nuorodą į reikšmę.
	Daugybinis tipas (generic type) – tipas turintis kelis daugybinius parametrus, galintis aprašyti kelis skirtigus tipus.
	Tipo pseudonimas (type alias) – papildomas vardas skiriamas tipui.
	Dantytas masyvas (jagged array) – masyvas sudarytas iš kitų masyvų.
	Automatinis tipo keitimas (implicit cast) – reikšmės tipas pagal poreikį keičiamas be vartotojo reikalavimo.
	Nurodomasis tipo keitimas (explicit cast) – reikšmės tipas keičiamas, nes taip nurodė vartotojas.
	Funkcijos parametras (function parameter) - funkcijos deklaruojamas kintamasis, kuris įgyja funkcijos argumento reikšmę. ;;geriau nemoku parašyti, bet niekas nežino kuo arg nuo param skirias
	Funkcijos argumentas (function argument) - reikšmė paduodama funkcijai.
	Vardų grupė (namespace) - ;; dunno, lol - D.
	PEG - parsing expression grammar ;; jei ką čia žemaitiškai o ne angliškai - A.
	Metaduomenys - ;; TO DO

Įvadas

	Ši specifikacija aprašo programavimo kalbą, pavadinimu „LaborasLang“. LaborasLang kalbos autoriai yra Andrius Dapševičius, Darius Lapūnas ir Tautvydas Žilys. 
	Pagrindiniai tikslai, keliami LaborasLang, yra:
	•	Esamiems programuotojams pažįstama sintaksė. Yra siekiama, kad programuotojai,  pažystami su bet kuria programavimo kalba, kurios sintaksė yra kilusi iš C kalbų šeimos, galėtų greitai išmokti programuoti su LaborasLang.
	•	Statinė tipų sistema. LaborasLang kompiliatorius turi sugebėti statiškai patikrinti tipų naudojimą.
	•	Funkcijos – pirmos klasės nariai. LaborasLang programavimo kalboje, funkcijas galima naudoti lygiai taip pat, kaip ir bet kurį kitą duomenų tipą.
	•	Paprastumas. Vienas iš LaborasLang uždavinių – būti kuo įmanoma paprastesnei.
	•	Vykdymo greitis. LaborasLang kalba parašytos programos turi galėti efektyviai išnaudoti kompiuterio resursus.
	•	Sąveika su kitomis programavimo kalbomis. LaborasLang kalba parašytos programos turi galėti naudotis bibliotekomis, kurios yra parašytos kitomis .NET programavimo kalbomis. Dėl šios priežasties, LaborasLang programos yra kompiliuojamos į CIL. Taip pat bibliotekos parašytos LaborasLang turi veikti kitose .NET kalbose.


1. Specifikacijos apimtis

	Ši specifikacija apibrėžia LaborasLang programavimo kalbą. Tai apima:
	•	LaborasLang kalbos leksinę ir sintaksinę gramatiką;
	•	LaborasLang kalbos semantiką;
	•	LaborasLang kalbos apribojimus.
	Kartu su specifikacija pateikiamas pavyzdinio LaborasLang kalbos kompiliatoriaus aprašas.

2. LaborasLang apžvalga
	LaborasLang yra statiškai tipuojama, procedūrinė, kompiliuojama, bendros paskirties programavimo kalba, turinti funkcinio programavimo elementų. Šis skyrius aprašo pagrindines LaborasLang kalbos savybes.

	2.1. Pirmoji LaborasLang programa

		Pavyzdinė „Hello, world“ programa LaborasLang kalboje gali būti užrašoma taip:

			use System;

			entry auto HelloWorld = void()
			{
				Console.WriteLine("Hello, world!");
			};

		Išnagrinėkime šią programą po eilutę:
		•	Sakinys  use System; nurodo, jog šiame faile tipai ir vardų grupės iš System vardų grupės bus tiesiogiai pasiekiami.
		•	entry auto HelloWorld = void() šioje eilutėje yra deklaruojamas kintamasis HelloWorld. Šiam kintamajam yra priskiriama funkcija, kurios tipas – void(). Kadangi kintamojo deklaravimo metu jam yra priskiriama reikšmė, tai jo tipą galima nustatyti automatiškai – tai nurodo specialus tipas auto. Raktinis žodis entry nurodo, jog šis kintamasis yra programos įeities taškas.
		•	{ pažymima funkcijos pradžia.
		•	Console.WriteLine("Hello, world!"); iškviečiama funkcija WriteLine esanti Console tipe. Tai yra standartinė CLI funkcija.
		•	}; pažymima funkcijos pabaiga ir užbaigiamas priskyrimo sakinys.


2.2. Tipai

	LaborasLang palaiko dviejų rūšių tipus: vertės tipus ir nuorodinius tipus. Vertės tipai, skiriasi nuo nuorodinių tipų tuo, kad jie 
	savyje laiko reikšmę. Nuorodiniai tipai laiko nuorodą į reikšmę. Dvi nuorodos gali rodyti į tą pačią reikšmę, o reiškia, kad 
	pakeitimai per vieną nuorodą gali atsirasti kitoje. Tai neįmanoma su vertės tipais, nes vertės tipo kintamieji turi savo reikšmės kopiją. Pavyzdžiui:

		use System;
		use System.Runtime.InteropServices.ComTypes;
		use System.Text;

		entry auto MyFunction = void()
		{
			FILETIME value;
			value.dwLowDateTime = 15;

			auto reference = StringBuilder("Laboras");

			Console.WriteLine(value.dwLowDateTime);
			Console.WriteLine(reference);

			auto valueCopy = value;
			valueCopy.dwLowDateTime = 20;

			auto referenceCopy = reference;
			referenceCopy.Append("Lang");

			Console.WriteLine(value.dwLowDateTime);
			Console.WriteLine(valueCopy.dwLowDateTime);

			Console.WriteLine(reference);
			Console.WriteLine(referenceCopy);
		};

	Ši programa atspausdina:

		15
		Laboras
		15
		20
		LaborasLang
		LaborasLang

	Visi palaikomi CLI tipai paveldi iš System.Object. Reikšmės tipai paveldi iš System.ValueType, kuris paveldi iš System.Object. 
	LaborasLang taip pat palaiko sąsajos tipus, kurių objektai gali būti vertės arba nuorodiniai tipai, priklausomai nuo realizacijos.

	2.2.1. Fundamentalieji tipai

		LaborasLang turi keletą fundamentaliųjų tipų, kurie atitinka fundamentaliuosius CLI tipus:

		Tipo vardas	     CLI tipo atitikmuo	     Pastabos
		bool	         System.Boolean	         Loginis tipas, galintis laikyti 2 reikšmes: true ir false.
		int8	         System.SByte	         1 baito dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-128; 127].
		uint8	         System.Byte	         1 baito dydžio sveikasis skaičius be ženklo, Galimos reikšmės: [0; 255].
		int16	         System.Int16	         2 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-32768; 32767].
		uint16	         System.UInt16	         2 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 65535].
		char	         System.Char	         2 baitų dydžio simbolio tipas.
		int32, int	     System.Int32	         4 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-2147483648; 2147483647].
		uint32, uint	 System.UInt32	         4 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 4294967295].
		int64, long	     System.Int64	         8 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės:  [–9,223,372,036,854,775,808; 9,223,372,036,854,775,807].
		uint64, ulong	 System.UInt64	         8 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 18,446,744,073,709,551,615].
		float	         System.Single	         4 baitų dydžio slankaus kablelio skaičius, atitinkantis IEC 60559:1989 standartą.
		double	         System.Double	         8 baitų dydžio slankaus kablelio skaičius, atitinkantis IEC 60559:1989 standartą.
		void	         System.Void	         Tipas neturintis reikšmės. Naudojamas pažymėti, jog funkcija negražina rezultato.
		object	         String.Object	         Objektas – fundamentaliausias tipas. Jis gali laikyti bet kurio kito tipo reikšmes.
		string	         System.String	         Simbolių eilutės tipas.

		Fundamentalieji tipai išskyrus void, object ir string yra taip pat vadinami primityviaisiai tipais. Jie yra naudojami atliekant 
		standartines operacijas ir sudaro kitus CLI tipus.

		Fundamentaliųjų tipų vardai yra pseudonimai CLI tipams ir jie yra kompiliavimo metu verčiami į tikruosius tipus.
		Todėl:

		string foo;
		ir 
		System.String foo;

		yra sukompiliuojami į identišką kodą.

	2.2.2 Vardų grupė ir pilnas vardas

		Tipo pilnas vardas yra sudaromas iš jo vardų grupės ir vardo atskirtu tašku. Pavyzdžiai:

			Pilnas vardas                  Vardų grupė          Vardas
			System.Collections.ArrayList   System.Collections   ArrayList
			System.String                  System               String
			System.IO.File                 System.IO            File

		Vardų grupės turi dvi funkcijas: suskirstyti tipus pagal paskirtį ir leisti keliem tipam turėti tą patį vardą. Kadangi 
		tipo identifikatorius yra jo pilnas vardas, keli tipai gali turėti tą patį vardą, kol jų vardų grupės skiriasi. Sakoma, 
		kad tipas String priklauso vardų grupei System. Taip pat vardų grupė Collections priklauso vardų grupei System.

	2.2.2. Funkcijų tipai

		LaborasLang kalboje, funkcijų tipus apibrėžia funkcijos gražinamas tipas ir jos priimamų argumentų tipai. 
		Pilna funkcijos tipo sintaksė yra:

		<grąžinamas tipas>(<parametrų tipai atskirti kableliais>)

		Ir grąžinamas tipas, ir parametrų tipai gali būti bet kokie LaborasLang palaikomi tipai. Keletas funkcijų tipų pavydžių:

		void() – funkcija negrąžina rezultato ir nepriima jokių argumentų.

		void(int, double) - funkcija negrąžina jokio rezultato, ir priima du argumentus, kurių tipai yra int ir double.

		string(string, string()) - funkcija grąžina rezultatą, kurio tipas yra string, ir priima du argumentus, kurių tipai yra string ir 
		funkcija, kuri grąžina string tipo rezultatą.

		int[](System.Collections.IList) - funkcija grąžina masyvą, kurio elemento tipas yra int, ir priima vieną argumentą, kurio tipas 
		yra System.Collections.IList.

		void tipas gali būti naudojamas tik kaip funkcijos gražinamas tipas. C stiliaus sintaksė int(void), kurioje void parametrų sąraše 
		reikšdavo parametrų nebuvimą nėra leidžiama, tam yra naudojamas tuščias parametrų sąrašas.

		Kadangi funkcijos yra pirmos klasės nariai, funkcijos taip pat gali gražinti kitas funkcijas. Pavyzdys: 

		string()() - funkcija, kuri gražina string() tipo funkciją ir neima jokių argumentų.

		Funkcija, kurią laiko funkcijos tipo kintamasis, yra iškviečiama šalia kintamojo parašant skliausteliuose argumentus, atskirtus kableliais. Pavyzdžiui:

			void(int, double) myVariable = someFunction;
			myVariable(3, 5.8);

		Funkcijų tipus galima naudoti perduodant funkcijas kaip argumentus kitoms funkcijoms:

			int(int()) GetFunctionResultPlusOne = int(int() function)
			{
				return function() + 1;
			};

			void() PrintSix = void()
			{
				Console.WriteLine(GetFunctionResultPlusOne(int() { return 5; }));
			};

		Implementacijos pastaba: šie tipai yra objektai, turintys „Invoke“ metodą, kuris iškviečia funkciją, grąžino jos grąžinamą reikšmę ir priima tokius pačius argumentus.

	2.2.3. Masyvų tipai

		LaborasLang palaiko masyvų kūrimą iš visų palaikomų tipų. Masyvo tipą sudaro elemento tipas ir matmenų skaičius, visi masyvai yra 
		indeksuojami nuo nulio. Tipų sistema nedengia masyvo matmenų ilgio, tik jų skaičių. Skaičius deklaruojamas kableliais tarp laužtinių 
		skliaustų. Gautas masyvas turės vienu matmeniu daugiau negu tipe yra kablelių. 

		Masyvo tipas yra nuorodos tipas, vieno matmens masyvai atitinka CLI vektoriaus specifikaciją, kelių matmenų masyvai (matricos) atitinka 
		CLI masyvo specifikaciją. Maksimalus masyvo matmenų skaičius yra 32. 

		<elemento tipas>[<matmenų skaičiaus deklaracija>]

		Pavyzdžiai:
		int[] //vienmatis int masyvas
		float[,] //dvimatis float masyvas
		System.Version[,,] // Trimatis versijų masyvas

		Taip pat, galima deklaruoti funkcijų masyvus.

		int(int)[]

		Arba masyvus sudarytus iš kitų masyvų (t.y. dantytus masyvus).

		int[][]

		Kadangi dantytą masyvą sudaro tik nuorodos į kitus masyvus, tokio masyvo matmenų ilgis yra neribojamas. Maksimalus įmanomas matmenų 
		skaičius priklauso nuo kompiliatoriaus realizacijos, taip pat nuo veikimo aplinkos (kompiliatoriaus ir gautos programos).

	2.2.4. Tipų keitimas

		LaborasLang tipų sistema nėra griežta, norint galima keisti reikšmių tipus, bet kompiliatorius užtikrina keitimo korektiškumą jei 
		tai yra įmanoma. Kadangi korektiškumą garantuoti yra įmanoma tik labai retais atvejais ir naudojant sudėtingą statinę analizę, 
		kompiliatorius leidžia tik akivaizdžiai teisingus keitimus.

		Tipo keitimas yra reikalingas keliose situacijose. Pirma, yra daug sveikųjų skaičių tipų, kurie visi laiko tą pačią informaciją 
		panašiu formatu. Taip galima pasirinkti geriausią tipą, bet gali reikėti keitimų perduodant duomenis. Antra, objektinis programavimas 
		reikalauja keitimų. Su keitimais objektų tipai neturi atitikti kintamųjų tipų, užtenka, kad paveldėtų jų tipus. 

		Yra naudojami du keitimų tipai: automatinis keitimas ir nurodomasis keitimas.

		2.2.4.1 Automatinis tipo keitimas

			Kai kuriais atvejais nesutampa reikšmės tipas ir reikalaujamas tipas, bet kompiliatorius gali nustatyti, kad keitimas galimas. Keitimo pagrindinės taisyklės:
			•	Jei tipai vienodi, keitimas nereikalingas. 
			•	Jei tai primityvūs tipai, ar norimas tipas gali įgyti visas keičiamo tipo reikšmes.
			•	Jei tai yra funkcijų tipai, ar sutampa parametrų skaičius? Ar reikšmės parametrus galima automatiškai keisti į norimo tipo parametrus?
			•	Jei tai masyvų tipai, ar sutampa matmenų skaičius? Ar reikšmės elemento tipą galima keisti į norimo tipo elementą?
			•	Ar reikšmės tipas paveldi iš norimo tipo?
			Jei netenkinama nei viena šių taisyklių, keitimas neleidžiamas ir rodoma klaida.
			Keičiant primityvius tipus, naudojama galimų keitimų lentelė.

			;;čia mano papaišyta nuostabi lentelė "assignment map.jpg"

			Šios taisyklės yra tranzityvios, t.y. jei uint8 galima keisti į int16, o int16 į int32, leidžiama ir uint8 keitimas į int32. 
			Vienintelė išlyga reikalavimui dėl korektiškumo yra sveikųjų skaičių keitimas į realiuosius, nors tai gali neduodi tikslių 
			rezultatų artėjant prie kraštutinių reikšmių, dėl paprastumo šis keitimas leidžiamas.

		2.2.4.2 Nurodomasis tipo keitimas

			Jeigu statiškai neįmanoma įrodyti keitimo korektiškumo, bet vartotojas žino, jog jis bus teisingas, galimas nurodomasis keitimas. 
			Šiame keitime vartotojas nurodo tipą į kurį nori keisti. Kompiliatorius draudžia tik tuos nurodomuosius keitimus, kurie yra garantuotai neteisingi. 
			Turi būti patenkinta viena iš sąlygų:
			•	Vienas iš tipų gali būti automatiškai keičiamas kitu;
			•	Abu tipai yra primityvūs ir nei vienas jų nėra bool.

	2.2.5 Null reikšmės tipas

		null yra išskirtinė reikšmė tuo, kad ji neturi tipo. Ją gali įgyti bet koks nuorodinio tipo kintamasis.

	2.2.6 Automatinis tipo radimas

		LaborasLang palaiko ribotą automatinį tipų radimą. Deklaruojant kintamuosius galima nurodyti auto tipą. Tokioje deklaracijoje tipas 
		bus randamas automatiškai, bet kintamąjį būtina inicializuoti. Kompiliavimo metu kintamojo tipas nustatomas toks pat kaip inicializatoriaus. Pavyzdys:

			auto str = "text";

		ir

			string str = "text";

		Abi deklaracijos sukompiliuojamos į identišką kodą.

	2.3. Operatorių prioritetas
		Galimi operatoriai, surikiuoti nuo aukščiausio prioriteto iki žemiausio, yra:
			Taško operatorius ., funkcijos kvietimo operatorius (), indeksavimo operatorius [], didinimo ir mažinimo vienetu operatoriai einantys po operando x++, x--
			Vienanariai operatoriai: inversija ~x, neigimas !a, minuso ženklas -x, didinimo vienetu ++x, mažinimo vienetu --x
			Daugybos *, dalybos /, liekanos % operatoriai
			Sudėties + ir skirtumo -
			Postūmio operatoriai: postūmis į kairę << ir postūmis į dešinę >>
			Lyginimo operatoriai mažiau < , daugiau >, mažiau arba lygu <=, daugiau arba lygu >=
			Lyginimo operatoriai lygu ==, nelygu !=
			Dvejetainiai operatoriai: ir &, palyginimo ^, arba |
			Loginiai operatoriai: ir &&, arba ||
			Priskyrimo operatoriai: =, *=, /=, %=, +=, -=, <<=, >>=, &=, ^=, |=

		Operatorių prioritetas gali būti valdomas naudojant skliaustus:
			auto a = 3 + 4 * 5; //a reikšmė yra 23, skaičiuojama kaip 3 + (4 * 5)
			auto b = (3 + 4) * 5; //b reikšmė yra 35, skaičiuojama kaip (3 + 4) * 5

	2.3. Kintamieji

		LaborasLang palaiko trijų tipų kintamuosius: lokalius kintamuosius, globalius kintamuosius ir funkcijų parametrus. Pagrindiniai 
		kintamųjų panaudojimo skirtumai yra jų galiojimo sritis.

		2.3.1. Lokalūs kintamieji

			Lokalūs kintamieji yra kintamieji deklaruoti funkcijos viduje. Šių kintamųjų galiojimo sritis yra kodo blokas, kuriame jie buvo 
			deklaruoti, su keliomis išlygomis. Kintamieji pradeda galioti nuo jų deklaracijos ir baigia uždarant jų bloką. Jeigu kintamojo 
			galiojimo srityje yra deklaruota funkcija, iš šios funkcijos galima pasiekti kintamąjį, bet tik kaip dešininę reikšmę.

		2.3.2. Globalūs kintamieji

			Deklaruojant kintamajį tiesiogiai faile, bus sukuriamas globalus kintamasis. Tokio kintamojo galiojimo sritis yra visas failas, 
			juo galima naudotis anksčiau negu jis yra deklaruotas. Kintamajį, priklausomai nuo deklaracijos, taip pat galima pasiekti iš 
			kitų failų. Plačiau apie tai skyriuje "Atributai".

		2.3.3. Funkcijų parametrai

			Funkcijos deklaraciją sudaro jos parametrai. Šie parametrai yra kintamieji, kurie įgis funkcijai perduotų argumentų reikšmes. 
			Parametrų galiojimo sritis yra visas funkcijos blokas, bet jų panaudojimas nesiskiria nuo lokalių kintamųjų.

	2.4. Išraiškos

		Išraiška yra kodo fragmentas, kurios gali gražinti reikšmę, arba priimti reikšmę. Išraiškos, kurios gražina reikšmę, dar vadinamos 
		dešininėmis išraiškomis. Dauguma išraiškų yra dešininės. Išraiškos, kurios gali priimti reikšmę vadinamos kairinėmis išraiškomis. 
		Kairinėmis išraiškomis gali būti yra simboliai, klasių nariai ir indeksavimas. Ar išraiška yra dešininė ar kairinė priklauso nuo 
		išraiškos. Šios taisyklės tiksliai aprašomos prie kiekvieno išraiškos tipo.

		2.4.1. Literalai

			Literalai yra reikšmės įrašytos kode. Literalai yra tik dešininės išraiškos.

			2.4.1.1 Loginiai literalai

				Reikšmės "true" ir "false" yra loginiai literalai. Jie gali būti naudojami kaip "bool" tipo išraiškos.

			2.4.1.2 Sveikųjų skaičių literalai.

				Sveikųjų skaičių literalo įgyjamas tipas priklauso nuo skaičiaus dydžio ir jo ženklo. 

					uint8 a = 5;
					int16 b = -20000;
					uint16 c = 70000;// klaida, skaičius netelpa į uint16

				Literalas gali įgyti tipą jei jis telpa į šio tipo reikšmių rėžius imtinai (§2.2.1. Fundamentalieji Tipai).

				Standarinis tipas yra "int". Šis tipas yra naudojamas jei nėra žinomas reikalingas tipas. Tipas nėra žinomas dvejais
				atvejais - jei naudojama deklaracija su inicializacija ir jei kviečiama perdengta funkcija.

					auto foo = void(int a){};
					auto foo = void(long a){};

					foo(5);

				Bus iškviesta pirmoji funkcija. Norint iškviesti antrają, reikia rašyti 

					foo((long)5);

				Literalo tipą galima paversti į "long" jo pabaigoje prirašant simbolį 'l' arba 'L'.

			2.4.1.3 Realiųjų skaičių literalai

				Realieji skaičiai gali įgyti tipus "float" ir "double". "float" tipas yra įgijamas, jei literalo gale yra simbolis
				'f' arba 'F'. Kitu atveju, jei literale yra dešimtainio taško simbolis ('.'), literalas įgija tipą "double".

			2.4.1.4 Tekstiniai literalai

				Tekstiniai literalai turi du tipus - "string" ir "char". "string" literalai gali būti sudaryti iš bet kokio
				skaičiaus simbolių, ir jie yra apgaubiami dvigubų kabučių simboliu ("). "char" literalai yra sudaryti iš vieno
				simbolio, ir yra apgaubti viengubomis kabutėmis.

			2.4.1.5 Null literalas

				"null" reikšmė taip pat laikoma literalu. Šis literalas tipo neturi ir gali įgyti bet kokį nuorodinį tipą.

		2.4.2 Nario išraiška

			Nario išraiška yra specialus operatorius naudojamas pasiekti vardų grupės arba tipo narį.

			<pagrindinė išraiška>.<identifikatorius>

			Šios sintaksės rezultatas gali būti kelios skirtingos išraiškos, priklausomai nuo pagrindinės išraiškos ir identifikatoriaus.
			Galimos išraiškos:

				* vardų grupė. Išraiška gaunama jei pagridninė išraiška kartu su identifikatoriumi sudaro vardų grupę arba jos fragmentą. 
				Tokią išraišką galima panaudoti kaip pagrindinę nario išraišką arba "use" sakinyje.

				* tipas. Išraiška gaunama jei:
					* pagrindinė išraiška yra vardų grupė ir joje deklaruotas tipas, kurio vardas sutampa su identifikatoriumi.
					* pagrindinė išraiška yra tipas, kuriame deklaruotas tipas, kurio vardas sutampa su identifikatoriumi.
				 Tipo išraiška taip pat turi ribotą panaudojimą:
					* kaip pagrindinė nario išraiška
					* deklaracijos tipas
					* nurdomojo keitimo tipas
					* kūriamo objekto tipas
					* kūriamo masyvo tipas
					* sudėtinio tipo dalis (sudėtiniais tipais laikomi funkcijų tipai ir masyvų tipai)

				* laukas. Išraiška gaunama jei:
					* pagrindinė išraiška yra tipas. Šiuo atveju pasiekiami statiniai laukai, atitinkantys identifikatorių.
					* pagrindinė išraiška yra reikšmė. Šiuo atveju pasiekiami nestatiniai laukai.
				 Laukai yra visada dešininiai. Laukas yra kairinis jei nėra deklaruotas su atributu "readonly" ([1] §III.2.3 readonly. (prefix)). 

				* metodas. Išraiška gaunama taip pat kaip laukas, bet metodai yra tik dešininiai. Naudojant metodą kaip išraišką, 
				jis yra keičiamas funkcijos kintamuoju.

				* metodų grupė. Išraiška gaunama tada jei tipas turi kelis metodus tuo pačiu vardu. Šią išraišką reikia sukonkretinti taip, 
				kad būtų parinktas vienas iš metodų. Tam yra du būdai:
					* metodo kvietimas. Pagal argumentus bus parinktas reikiamas metodas, arba gražinama klaida jei tokio metodo nėra.
					* panaudojimas kitose išraiškose. Jei išraiška reikalaja tam tikro tipo, bus parinktas tinkantis metodas arba gražinama 
					klaida, jei tokio nėra.
				 Kadangi metodų grupė neturi konkretaus tipo, ji negali būti naudojama deklaracijos inicializacijoje su tipu "auto".
				 Sukonkretinus metodų grupę ji tampa metodo išraiška.

				* sąvybė. Sąvybė gaunama kaip laukas. Sąvybė yra kairinė ir dešininė jei pasiekiami "set" ir "get" metodai atitinkamai.

			Jei tipo narys turi apribotą pasiekiamumą ir nėra pasiekiamas iš failo, kuriame rašoma išraiška, gražinama klaida.
			Pavyzdžiai:

			Console . WriteLine
			| tipas | metodų grupė |

			Kaip visi operatoriai, nario išraiška gali būti panaudota kitoje nario išraiškoje.

			  System      . IO          . File  . OpenRead
			| vardų grupė | vardų grupė |
			|        vardų grupė        | tipas |
			|               tipas               | metodas  |

				
		2.4.3. Pavieniai identifikatoriai
		
			Identifikatorius yra bet koks legalus simbolis (§3.3. Leksinė gramatika). Naudojant identifikatorių kaip išraišką atliekama paieška 
			pagal galiojimo sritį:

				1. Jei identifikatorius nėra naudojamas funkcijos viduje einama į punktą 4
				2. Ieškoma tarp lokalių kintamųjų. Kodo bloke neradus identifikatoriaus, paieška tesiama aukštesniame bloke kol pasiekiamas 
				aukščiausias funkcijos blokas. Šiame žingsnyje taip pat apimami "for" ciklų kintamieji.
				3. Ieškoma funkcijos parametro.
				4. Ieškoma globalaus kintamojo.
				5. Ieškoma importuotos vardų srities.
				6. Ieškoma importuoto tipo.
				7. Ieškoma vardų grupės.
				8. Ieškoma tipo.

			Tipus galima pasiekti kaip pavienius identifikatorius jei:
				* Jie nėra deklaruoti su vardų grupe arba kitame tipe.
				* Jie yra deklaruoti importuotoje vardų grupėje.

			Vardų grupes galima pasiekti kaip pavienius identifikatorius jei:
				* Jos nėra deklaruotos kitoje vardų grupėje.
				* Jos yra deklaruotos importuotoje vardų grupėje.

			Šiuo būdu gautos tipo ar vardų grupės išraiškos yra aprašytos skyriuje Nario išraiška.

		2.4.4. Indeksavimas

			LaborasLang palaiko du indeksavimo tipus: masyvo indeksavimą ir indekso operatorių.

			<kolekcija>[<indeksai>]

			Kolekcijos išraiška turi būti masyvas arba objektas su indekso operatoriumi.

			Indeksai yra kableliais atskirtos išraiškos.

			Ir kolekcija ir indeksai privalo būti dešininės išraiškos.

			2.4.2.x Masyvo indeksavimas

				Jei kolekcija yra masyvas, indeksavimas nustatomas pagal masyvo tipą:

				* Išraiškos reikšmės tipas yra masyvo elemento tipas.
				* Indeksų skaičius turi atitikti masyvo matmenų skaičių.
				* Indeksai gali būti sveikieji skaičiai išskyrus "int64" ir "uint64" tipus.

			2.4.2.x Indekso operatorius

				Jei kolekcija nėra masyvas, joje ieškoma indekso operatoriaus pagal nurodytus indeksus. Operatorius parenkamas taip pat 
				kaip perdengtas metodas. Šiuo atveju indeksai gali būti bet kokio tipo išraiškos, jei yra tokio tipo operatorius.

				Objektuose gali būti keli indekso operatoriai

				Pavyzdžiai:

					int[] arr = int[] { 1, 2, 3 };
					Console.WriteLine(arr[2]); // išspausdina "3"

					getMap()["foo"];
				
					// objektas su keliais skritingais operatoriais
					incrediblyComplexStructure[1, "agurkas", 6];
					incrediblyComplexStructure[5];

		2.4.5. Funkcijos

			Funkcijos išraiška yra naudojama norint aprašyti funkcijas.

			<tipas>(<parametru sąrašas>)
				<kodo blokas>

			Tipas gali būti bet koks LaborasLang tipas.

			Parametrų sąrašas yra kableliu atskirtos tipo ir identifikatoriaus poros. Šie parametrai iškvietus funkciją įgyja argumentų 
			reikšmes ir gali būti naudojami kaip lokalūs kintamieji. 

			Kodo blokas yra aprašytas skyriuje §2.5.6.1.

			Tokios išraiškos rezultatas yra nuoroda į funkcijos objektą. Ši išraiška nuo kitų skiriasi tuo, kad nėra vykdomas joje esantis 
			kodas, tik gaunama nuoroda į funkciją.

			Pavyzdžiai:

				auto func = int() { return 4; };

			Įvykdžius šį sakinį nebus įvykdytas funkcijos kodas, tik kintamajam foo priskirta nuorodą į funkciją.
			Norint įvykdyti kodą funkciją reikia iškviesti.

				int val;
				val = func();

		2.4.6. Funkcijos kvietimai

			LaborasLang leidžia kviesti CLI metodus ir funkcijos tipo objektus. Abu kvietimai yra sintaksiškai vienodi, bet jų veikimas 
			gali būti priklausomas nuo kompiliatoriaus.

			<funkcija>(<argumentų sąrašas>)

			Funkcija gali būti funkcijos objektas, CLI metodas arba metodų grupė. Nors abi kategorijos kviečiamos vienodai, jų panaudojime 
			yra subtilių skirtumų. Kviečiant argumentų tipai turi atitikti parametrams, arba turi būti galimas automatinis konvertavimas 
			tarp jų. Kitaip gražinama klaida.

			Pavyzdžiai:

			auto foo = void() { Console.WriteLine("It works!"); };

			foo();

			Šiame kode yra abu kvietimų tipai, foo yra funkcijos objektas, o WriteLine yra metodų grupė tipe Console.

			2.4.4.x Funkcijos objekto kvietimas

				Bet kokia išraiška, kurios reikšmė yra funkcijos objekto tipo, gali būti iškviesta, ne tik kintamieji. Pavyzdžiui
				funkcijos rezultatas:

					auto func = int()() { return int() { return 4; }; };
					int value = func()();

				Masyvo elementas:

					auto arr = { int() { return 4; } };
					int value = arr[0]();

				Pati funkcija:

					int value = int() { return 4; }();

				Tipo keitimas:

					auto func = (object)int() { return 4; };
					int value = ((int())func)();

				Ši sintaksė leidžia atlikt sudėtingą kintamųjų inicializaciją vienu sakiniu.

					const int value = int()
					{
						int day = System.Random().Next(1, 7);
						int meaningOfLife = 42;
						return day % meaningOfLife;
					}();

				Kadangi funkcijos tipas yra nuorodinis tipas, šio tipo išraiškos nebūtinai turi reikšmę.

					auto func = int()() { return null; };
					int value = func()(); // klaida, func rezultatas yra null

			2.4.4.x Metodo kvietimas

				Jei išraiška yra metodas, kvietimas neturi jokių papildomų reikalavimų. Kitaip negu funkcijos objekto atveju, 
				toks kvietimas yra visada sekmingas.

			2.4.4.x Funkcijų grupės kvietimas

				Kviečiant funkcijų grupę atsiranda papildomas reikalavimas: pagal tipus turi būti įmanoma tiksliai nustatyti kurią funkciją
				reikia kviesti. Jei argumentų tipai tiksliai neatitinka parametrų tipų, argumentai gali tikti kelioms funkcijoms iš grupės. 
				Tokiu atveju gražinama klaida.

				Pavyzdžiui:

					Console.WriteLine(5);

				WriteLine yra metodų grupė, kurios vienas metodų turi parametrą "int", o "5" literalo tipas yra "int". Kviečiamas šis metodas.

				auto foo = void(long a){};
				auto foo = void(int a){};

				entry auto main = void()
				{
					uint8 a = 5;
					foo(a); // klaida
				};

				Kadangi "uint8" galima automatiškai keisti ir į "int" ir į "long", neįmanoma konkrečiai pasakyti kuri funkcija tinka.

			;; Čia reikia nepamiršti paminėti tail calls
			;; tai ne implementation detail - D?
			;; Ne, nes tai language feature, nes gali infinite recursion daryt

		2.4.7. Priskyrimo operacija ;; parašyt kas būna kai dešinėj yra metodas
		2.4.8. Vienanarės operacijos
			
			Palaikomi vienanariai operatoriai yra
				Didinimo vienetu operatorius ++ 
				Mažinimo vienetu operatorius --
				Minuso ženklas -
				Inversija ~ 
				Neiginys !
			
			Operatoriai ++, -- naudojami operando didinimui ar mažinimui vienetu, nuo jų naudojimo vietos (prieš ar po operando) priklauso grąžinama reikšmė:

				auto a = 5--; // Operatorius naudojamas už operando grąžins pakeistą reikšmę, a vertė bus 4.
				auto b = ++4; // Operatorius naudojamas prieš operandą grąžins reikšmę prieš jos pakeitimą, b vertė bus 4.
			Kiti vienanariai operatoriai yra minuso ženklas -, inversija ~, neiginys !. Jie gali būti naudojami tik prieš operandą.
			
			Minuso operatorius atitinka daugybą iš -1:
				auto a = 1;
				auto b = -a; // b reikšmė yra -1.

			Inversijos operatorius ~ gali būti naudojamas kai jo operandas yra sveiko skaičiaus tipo, šis operatorius pakeičia visus skaičiaus bitus į priešingą reikšmę:
				auto a = ~1;

			Neigimo operatorius ! gali b8ti naudojamas loginiams operandams, jis paneigia jų reikšmę. Naudojamas prieš operandą:
				auto a = !true;// a reikšmė yra false

		2.4.9. Dvinarės operacijos
			2.4.7.1. Aritmetinės operacijos
			2.4.7.2. Loginės operacijos
			2.4.7.3. Bitinės operacijos
			2.4.7.4. Stūmimo operacijos
		2.4.10. Objektų kūrimas
		2.4.11. Masyvų kūrimas
		2.4.12. Nurodomasis tipo keitimas

			Jeigu statiškai neįmanoma įrodyti keitimo korektiškumo, bet vartotojas žino, jog jis bus teisingas, galimas nurodomasis tipo keitimas. 
			Šiame keitime vartotojas nurodo tipą į kurį nori keisti naudojant tipo keitimo operatorių apskliaustą norimą tipą:

			(<naujas tipas>) <objektas kurio tipas keičiamas>

			pavyzdžiui „string“ tipo objekto nurodomasis tipo keitimas aprašomas taip:

			string bar = "bar";
			auto foo = (Object) bar; 

			Tipo keitimas yra galimas kai 
			•	Abu tipai yra primityvūs ir nei vienas jų nėra bool.
			•	Vienas iš tipų gali būti priskirtas kitam.


	2.5. Sakiniai

		Sakinys yra pats elementariausias LaborasLang kalbos elementas turintis semantinę prasmę.

		2.5.1 Deklaracija
		
			Deklaracijos sakinys yra naudojamas deklaruojant kintamajį.

				<atributai> <tipas> <identifikatorius>;
				<atributai> <tipas> <identifikatorius> = <inicializatorius>;

			Atributai yra sąrašas atributų atskirtų tarpais, palaikomi atributai priklauso nuo kintamojo tipo. Atributus galima praleisti.

			Tipas yra bet koks palaikomas tipas išskyrus "void".
			
			Šio kintamojo vardas bus identifikatorius.

			Jei nurodytas, inicializatoriaus reikšmė priskiriama kintamajam.

			Pavyzdžiai:

				int a; // "int" tipo kintamasis be inicializacijos
				float b = 5; // "float" tipo kintamasis su inicializacija
				string str = null; // teksto eilutė inicializuojama "null" reikšme.
			
				// funkcijos kintamasis su inicializacija
				int(int) incrementer = int(int num)	
				{
					return num + 1;
				};

			Verta atkreipti dėmesį, jog po funkcijos bloko uždarymo yra ";". Funkcijos deklracija nėra kontrolės blokas ir jis, kaip visi 
			įprasti sakiniai yra baigiami su ";".

			Inicializuojant deklaraciją, jos tipą galima nustatyti "auto". Tada kintamojo tipas bus toks pat kaip inicializatoriaus išraiškos. 

			auto numbers = int[5];
			auto sudoku = void() { sudoku(); };

			;; čia dubliuojasi su skyriumi Automatinis tipo radimas, galvosiu kaip keisti - D.
			Deklaruojant "auto" tipą taikomi du apribojimai:
			* Deklaracija privalo būti inicializuota.
			* Inicializatorius negali būti "null", kadangi "null" neturi tipo.

			Jei nesilaikoma vieno iš šių apribojimų, kintamojo tipo nustatyti neįmanoma ir yra gražinama klaida.

				auto foo; // klaida, nėra inicializacijos
				auto bar = null; // klaida, null neturi tipo
				auto baz = Console.WriteLine; // klaida, WriteLine yra metodų grupė

			Nors kintamųjų tuo pačiu vardu galiojimo sritys gali persidengti, neleidžiama vienoje vietoje deklaruoti kelių kintamųjų tuo pačiu vardu:
				* kodo bloke negali būti kelių kintamųjų tuo pačiu vardu.
				* funkcijos parametrai privalo turėti skirtingus vardus.
				* failo globalūs kintamieji privalo turėti skirtingus vardus.

			Vienintelė išimtis: faile galimi keli globalūs kintamieji tuo pačiu vardu, jei jie visi yra funkcijos skirtingais parametrais. 
			Privalo skirtis ne parametrų vardai, o jų tipai. Tai dažnai vadinama funkcijų perdengimu. 

			Teisingas perdengimas:

				auto foo = void(){};
				auto foo = void(int a){};

			Neteisingas perdengimas:

				auto foo = void(int a){};
				auto foo = void(int b){};

			Taip pat neteisinga:

				auto foo = void(){};
				auto foo = int() { return 4; };

			Kviečiant perdengtas funkcijas, kitap funkcijų grupę, reikiama funkcija parenkama pagal argumentų tipus (žr. §2.4.6.).

			Norint papildomai apriboti kintamuosius, deklaracijoje galima jiems pridėti atributus. LaborasLang turi dvi atributų rūšis - 
			pasiekiamumo ir kintamumo. Pasiekiamumo atributai apriboja kintamojo galiojimo sritį, o kitamumo leidžia kintamajį padaryti 
			konstanta. Deklaracijoje galima pridėti po vieną kiekvienos rūšies atributą. Nepridėjus atributo rūšies bus nustatoma 
			standartinis atributas, kuris priklauso nuo deklracijos.

			2.5.1.1 Kintatumo atributai

				Yra du priešingi kintamumo atributai: const ir mutable. const padaro kintamajį konstanta, o mutable atvirkščiai - pažymi, 
				jog kintamajo reikšmė gali kisti. Konstantoms negalima priskirti reikšmės ir jas būtina inicializuoti. 

					const int a = 5;
					a = 6; // klaida, a reikšmę galima tik skaityti

					mutable int b = 7;
					b = 8; // reikšmę galima ir skaityti ir rašyti

					const int c; // klaida, konstantas būtina inicializuoti

				;; dabar galvoju, gal čia compiler detalė - D?
				;; Ne. Butu implementacijos detale, jei pasakytumem, jog kompiliuojasi i metoda - T.

				Standartinis atributas yra mutable, išskrus vieną atvejį. Globalūs funkcijų tipo kintamieji yra deklaruojami su const atributu. Tokia 
				taisyklė leidžia funkcijų perdengimą ir kelias optimizacijas. Norint gauti globalų funkcijos kintamajį, kuris nėra konstanta, 
				būtina deklarauotį jį su mutable atributu. 

					void() foo; // klaida, jei tai globalus kintamasis

					mutable void() foo; // šis kodas veikia

				Kintamumo atributai yra palaikomi lokalių ir globalių kintamųjų. 
				
			2.5.1.2 Pasiekiamumo atributai

				Pasiekiamumo atributai naudojami apriboti globalių kintamųjų galiojimo sritį. Yra du pasiekiamumo atributai - private ir public. 
				private kintamieji yra pasiekiami tik iš failo kuriame yra deklaruoti, public kintamieji yra pasiekiami iš bet kurio failo. 
				Standartinis atributas yra private. 

				public auto foo = 5;
				private auto bar = 6;

				Pasiekiamumo atributai leidžiami tik globaliems kintamiesiems.

			2.5.1.3. Atributų kombinavimas

				Atributus galima kombinuoti. 

					public const int MAX_COUNT = 200;

				Bet deklaracijoje gali būti tik po vieną atributą iš kiekvieno tipo.

					public private int a; // klaida
					public public int b; // kompiliatoriui nereikia kartoti dalykų

		2.5.2 Vardų grupės importavimas

			Importavimo sakinys naudojamas į failo galiojimo sritį įterptį vardų grupes ir tipus iš kitos vardų grupės.

				use <vardų grupė>;

			Vardų grupė privalo būti pilna vardų grupė iš naudojamų asemblių.

			Po šio sakinio galima visus tipus ir vardų grupes iš nurodytos vardų grupės pasiekti tiesiogiai, nerašant importuotos grupės.

				use System;

				String a;
				Collections.ArrayList lst;

			yra analogiška

				System.String a;
				System.Collections.ArrayList lst;

			Importavimo sakiniai leidžiami tik viso failo galiojimo srityje.
			Faile gali būti neribotas skaičius importavimo sakinių.

			Nors sakinys importuoja ir vardų grupes, importavimo sakinyje privaloma rašyti pilną vardų grupę, net jei ji pasiekiama trumpiau per kitą sakinį.

				use System;
				use Collections; // klaida, nėra tokios vardų grupės
				use System.Collections; // Toks sakinys veikia

			Kompiliavimo metu importuoti tipai keičiami pilnais tipų vardais. Importavimas, kaip ir tipų pseudonimai, yra pagalbinė kompiliatoriaus funkcija. 
			Šių sakinių naudojimas visiškai neįtakoja gaunamo kodo veikimo.

		2.5.3 Grįžimo sakinys

			"return" sakinys naudojamas baigti funkcijos darbą. 

				return;
				return <reikšmė>;

			"return" sakinio tipas privalo atitikti funkcijos gražinamą tipą. Jei gražinas "void" tipas, leidžiamas tik tuščias "return" sakinys. Toks sakinys naudojamas tik užbaigti funkcijos darbą. "void" tipo funkcijos gali neturėti "return" sakinio, jų darbas bus baigtas pasiekus funkcijos bloko galą. 

			Jei funkcijos tipas nėra "void", ji privalo gražinti reikšmę, todėl privalomas bent vienas "return" sakinys su reikšme. Šios reikšmės tipas turi atitikti funkcijos tipą, arba turi egzistuoti automatinis keitimas iš reikšmės į funkcijos gražinamą tipą.

			Norint užtikrinti, jog funkcija tikrai gražins reikšmę, kompiliatoriuje įvedama gražinančio sakinio sąvoka.

			Sakinys gražina jei:
			* tai yra "return" sakinys
			* tai yra kodo blokas ir bent vienas jo sakinių gražina
			* tai yra sąlygos sakinys, jis turi abi atšakas ir jos abi yra gražinantys blokai

			Jei funkcijos blokas nėra gražinantis blokas, kompiliatorius gražina klaidą.

			Pavyzdžiai:

				// teisingas kodas, funkcijai nereikalingas return sakinys
				void()
				{
					int a = 5;
				}

				// klaida, ši funkcija negali gražinti
				void()
				{
					return 5;
				}

				// klaida, funcija negražina reikšmės
				int()
				{
					int a = 5;
				}

				// teisingas kodas, abi šakos gražina reikšmę
				int()
				{
					int a = GetNum();
					if (a > 6)
					{
						return a - 1;
					}
					else
					{
						return a + 1;
					}
				}

				// klaida, viena iš šakų negražina reikšmės
				int()
				{
					int a = GetNum();
					if (a > 6)
					{
						return a - 1;
					}
					else
					{
						a++;
					}
				}

				// klaida, viena iš šakų negražina reikšmės
				int()
				{
					int a = 5;
					if (a > 0)
					{
						return a;
					}
					else
					{
						a++;
					}
				}

			Šis kodo fragmentas parodo sistemos trūkumą. Nors jūs esatę įsitikinę, kad funkcija gražins reikšmę, kompiliatorius naudoja 
			paprastą analizę, kuri negali garantuoti šio fakto. Tokiu atveju tenka naudoti "return" sakinius, kurie niekada nebus įvykdyti.

		2.5.4 Tuščias sakinys

			Tuščią sakinį sudaro tik kabliataškis. Toks sakinys nedaro nieko ir gali būti naudojamas ten, kur sintaksė reikalauja sakinio, 
			bet nenorite nieko atlikti.

		2.5.5 Išraiškos sakinys

			Išraiškos sakinį sudaro pati išraikša ir kabliataškis:

				<išraiška>;

			Bet kokia išraiška taip pat gali būti panaudota kaip sakinys. Tokia išraiška bus įvykdyta ir jos gražinama reikšmė atmesta.

		2.5.6. Kontrolės blokai

			Kontrolės blokai yra sakiniai naudojami valdyti programos vykdymo seką. Kontrolės blokai gali būti panaudoti tik kodo bloko viduje.

			2.5.6.1. Kodo blokas

				LaborasLang kodo blokai sudaromi iš atidarančių kabučių, sąrašo sakinių ir uždarančių kabučių.

					{
						<sakinių sąrašas>
					}

				Blokas leidžia įrašyti kelis sakinius, kur sintaksė palaiko tik vieną. Vykdant kodo bloką, jame esantys sakiniai yra vykdomi paeiliui.

				Kodo bloke deklaruoti kintamieji galioja tik iki blogo galo, todėl blokai taip pat naudojami norint apriboti kintamojo galiojimo sirtį.

				Pavyzdys:

					{
						int a = 5;
						a++;
					}

				Kintamasis a galioja iki bloko pabaigos, bandymai jį naduoti vėliau gražins klaidą (nebent yra kitų kintamųjų vardu a).

					{
						int b = 5;
						{
							int a = b;
							b++;
						}

						Console.WriteLine(b);// išspausdintų 6
						Console.WriteLine(a);// bet yra klaida, kintamasis a čia neegzistuoja
					}

				Bloke kintamieji negali turėti to pačio vardo.

					{
						int a = 5;
						float a = 0.0f; // klaida, kintamasis "a" jau deklaruotas
					}

				Tačiau, vardas gali būti vėl panaudojamas gilesniame bloke.

					{
						int a = 5;
						{
							Console.WriteLine(a);
							int a = 16;
							Console.WriteLine(a);
						}
						Console.WriteLine(a);
					}

				Ši programa išspausdins

					5
					16
					5

				Blokas gali būti tuščias. Toks blokas daro tą patį ką tuščias sakinys - visiškai nieko.

			2.5.6.2. Sąlygos sakinys

				Sąlygos sakinys naudojamas parinkti vykdomą sakinį pagal sąlygą.

					if (<sąlyga>)
						<teigiamas sakinys>
			
					if (<sąlyga>)
						<teigiamas sakinys>
					else
						<neigiamas sakinys>

				Sąlyga yra bet kokia "bool" tipo dešininė išraiška.

				Jei sąlygos reikšmė yra "true", bus vykdomas tegiamas sakinys, jei "false" - neigiamas.

				"else" ir neigiamas sakinys gali būti praleisti.
				Pavyzdžiai:

					int num = GetNum();
					if (num >= 0)
						Console.WriteLine("Tegiamas skaičius");
					else
						Console.WriteLine("Neigiamas skaičius");

					num++;

					if (num < 0)
						return;

				"if" yra grupuojamas su artimiausiu "else" bloku. Norint sugrupuoti kitaip naudojami kodo blokai.

					int num = GetNum();
					if (num >= 0)
						if (num == 0)
							Console.WriteLine("Nulis");
					else
						Console.WriteLine("Neigiamas skaičius");

				Ši programa išspausdins "Neigiamas skaičius" visiems teigiamiems nenuliniams skaičiams, kadangi "else" yra grupuojamas su 
				artimiausiu "if". Pataisyta programa:

					int num = GetNum();
					if (num >= 0)
					{
						if (num == 0)
							Console.WriteLine("Nulis");
					}
					else
						Console.WriteLine("Neigiamas skaičius");


			2.5.6.3. Ciklai

				LaborasLang programavimo kalba palaiko trijų tipų ciklus: "while" tipo ciklą ir du "for" tipo ciklus.

				2.5.6.3.1. while ciklas
				
					while ciklas susideda iš dviejų dalių: ciklo sąlygos ir ciklo sakinio. Ciklas yra vykdomas tol, kol ciklo sąlyga 
					yra teisinga. Bendrą ciklo struktūrą galima aprašyti taip:

						while (<sąlyga>)
							<sakinys>

					Ciklo sakinys yra bet koks LaborasLang kalboje legalus sakinys (kodo blokas, sąlyga, ciklas ir t.t.).

					Sąlyga yra bet kokia "bool" tipo dešininė išraiška.
				
					Keletas while ciklo pavyzdžių:

						while (foo-- > 0)
							Report(foo);

						while (IsValid(bar))
						{
							if (bar % 2 == 0)
								Console.WriteLine(bar);

							bar = Transform(bar);
						}

				2.5.6.3.2. C stiliaus for ciklas
				
					LaborasLang kalba palaiko C stiliaus for ciklą - jis analogiškas C ciklui ir yra palaikomas daugumos C šeimos kalbų. 
					Šį for ciklą sudaro kelios dalys: ciklo inicializatorius, ciklo sąlyga, ciklo iteratorius ir ciklo sakinys. C stiliaus 
					for ciklo struktūra yra tokia:

						for (<inicializatorius>; <sąlyga>; <iteratorius>)
							<sakinys>

					Kiekviena iš šio for ciklo atraštės dalių gali būti praleista.

					Ciklo inicializatorius, jei toks yra, privalo būti kintamojo deklaracija arba bet kokia LaborasLang išraiška. 
					Deklaracija gali būti su inicializacija arba be. Ši deklaracija sukuria lokalų kintamajį, kurio galiojimo sritis apima visą 
					ciklą.

					Ciklo sąlyga, jei tokia yra, privalo būti "bool" tipo išraiška. Jei sąlygos nėra, ji pakeičiama išraiška "true".

					Ciklo iteratorius, jei toks yra, gali būti bet kokia išraiška.

					Ciklo sakinys yra bet koks LaborasLang sakinys, išskyrus "use" sakinį.

					Ciklo vykdymo tvaka:

						1. Jei aprašytas, įvykdomas ciklo inicializatorius.
						2. Įvykdoma ciklo sąlyga. Jei rezultatas nėra "true", baigiamas ciklo vykdymas.
						3. Įvykdomas ciklo sakinys.
						4. Jei nebuvo išeita iš sakinio (pavyzdžiui "return" sakiniu) ir yra aprašytas iteratorius, jis yra įvykdomas.
							Vykdymas gražinamas į 2 punktą.

					Naudojant "while" ciklą, "for" galima aprašyti taip:

						{
							<inicializatorius>;
							while (<sąlyga>)
							{
								<sakinys>;
								<iteratorius>;
							}
						}

					For ciklo pavyzdžiai:

						// Šis for ciklas spausdina "Spinning infinitely" be galo.
						for (;;)
							Console.WriteLine("Spinning infinitely");


						// Šis for ciklas atspausdina skaičius nuo 0 iki 9 imtinai.
						for (int i = 0; i < 10; i++)
							Console.WriteLine(i);


						// Šis ciklas analogiškas while ciklui
						int i = 0;
						for (; i < 10;)
						{
							Console.WriteLine(i);
							i++;
						}


				2.5.6.3.3. Kolekcijos iteravimo for ciklas

					Iteravimui per reikšmių kolekcijas dažnai naudojamas specialus ciklas, kitose kalbose vadinamas "foreach" ciklu. Šiame 
					cikle yra deklaruojamas kintamasis, kuris paeiliui įgyja visas rinkinio reikšmes. 

						for (<kintamojo tipas> <kintamojo pavadinimas> in <kolekcija>)
							<sakinys>

					Pagal kintamojo tipą ir pavadinimą yra deklaruojamas lokalus kintamasis. Šio kintamojo galiojimo sritis yra visas ciklas, 
					bet jam negalima kode priskirti reikšmės. Šis ciklas netinka, jei reikia modifikuoti kolekciją.

					Kolekcijos gali būti masyvai arba objektai turintys metodą GetEnumerator(). Kolekcijos išraiška bus įvykdyta vieną kartą 
					ir viso ciklo metu bus naudojamas tas pats enumeratorius. 

					Kadangi iš kolekcijos visada galima sužinoti elemento tipą, dažnai deklracijoje naudojamas tipas "auto".

					Ciklo pavyzdžiai:

						// iteruojama per masyvą
						// išspausdins skaičius 1 - 4
						auto arr = int[] { 1, 2, 3, 4 };
						for (auto i in arr)
							Console.WriteLine(i);

						// iterauojama per kolekciją
						// išspausdins kolekcijos objektų tekstines reprezentacijas
						ArrayList lst = ArrayList({1, 2, 3, 4});
						for (object i in lst)
							Console.WriteLine(i.ToString());

3. LaborasLang gramatika

	Kalbos gramatika nusako kaip leksemos yra sudaromos į prasmingas struktūras

	3.1. Programos apibrėžimas

		Programa yra vienas ar daugiau išeities kodo failų.

		Išeities kodo failus sudaro matomieji ir nematomieji tarpai (whitespace), žetonai, komentarai.
		* Nematomieji tarpai yra tarpo, įtraukos, eilutės pabaigos bei kiti panašūs simboliai, kompiliavimo metu jie yra ignoruojami.
		* Komentarai atitinka C šeimos kalbų komentarus, tai yra galimi vienos eilutės komentarai kurie yra pradedami simboliais "//" bei
		tęsiami iki eilutės pabaigos simbolio ir bloko tipo komentarai pradedami "/*" simboliu ir baigiami "*/" simboliu. Komentarų
		turinys kompiliavimo metu yra ignoruojamas
		* Žetonai yra gaunami sujungiant gretimus simbolius į prasmingas maksimalaus ilgio leksemas, kurios yra toliau analizuojamos
		kompiliuojant programą. Žetonai yra tokie simboliai kaip
		"*", "+", "=", ";" bei ilgesni dariniai - "auto", "penki", "+=", "while" bei kiti. Žetonai naudojami sudaryti kalbos
		struktūras, kurios savo ruožtu sudaro programą.

	3.2. Dviprasmybės

		LaborasLang gramatikoje dviprasmybės yra gailimos tik sudarant žetonus. Jos yra sprendžiamos sudarant maksimalaus galimio ilgio
		žetonus. Tai yra taikoma valdant tokius žetonus kaip "<<", "++", "--", tai reiška kad nors sakinys "i = i--1" galėtų būti 
		transformuotas į "i = i - (-1)" dėl žetonų ilgio maksimizavimo jis bus suprastas kaip "i = (i--) 1", kas yra nevalidus kodas (
		nėra jokio operatoriaus tarp dviejų operandų).

	3.3. Leksinė gramatika

		Leksiniu požiūriu gramatika nurodo kaip leksemos yra formuojamos į sakinius.

		Gramatiką sudaro aibė paprastų leksemų kurios sudaro programos kodą:
		
		LaborasLang gramatikoje naudojama aibė žetonus atitinkančių taisyklių:							

			;; Čia turėtų gautis kelios lentelės - A.
			Specialūs simboliai
			EndOfLine 				;
			Comma 					,
			Else 					else
			If 						if
			Return 					return
			Use 					use
			Virtual 				virtual
			While 					while
			For 					for
			In 						in

			Literalai
			CharLiteral 			'simbolis'
			StringLiteral 			"simbolių eilutė"
			Integer 				0
			Float 					0.0f
			Long 					0l
			Double 					0.0
			False 					false
			True 					true
			Null 					null

			Simbolis
			Symbol 					foo

			Sklaustai
			LeftCurlyBrace 			{
			RightCurlyBrace 		}
			LeftParenthesis 		(
			RightParenthesis 		)
			LeftBracket 			[
			RightBracket 			]

			Dvinariai operatoriai (InfixOperator)
			Period 					.
			BitwiseAnd 				&
			BitwiseAndEqual 		&=
			Plus 					+
			Minus 					-
			MinusEqual 				-=
			NotEqual 				!=
			PlusEqual 				+=
			BitwiseXor 				^
			BitwiseXorEqual 		^=
			BitwiseOr 				|
			BitwiseOrEqual 			|=
			LeftShiftEqual 			<<=
			LeftShift 				<<
			LessOrEqual 			<=
			Less 					<
			LogicalAnd 				&&
			LogicalAndEqual 		&&=
			LogicalOr 				||
			LogicalOrEqual 			||=
			More 					>
			RightShift 				>>
			RightShiftEqual 		>>=
			MoreOrEqual 			>=
			Divide 					/
			DivideEqual 			/=
			Multiply 				*
			MultiplyEqual 			*=
			Remainder 				%
			RemainderEqual 			%=
			Assignment 				=
			Equal 					==

			Vienanariai operatoriai
			PlusPlus 				++
			MinusMinus 				--
			Not 					!
			BitwiseComplement 		~

			Deklaracijų modifikatoriai (VariableModifier)
			Const 					const
			Private 				private
			Public 					public
			Mutable 				mutable
			Entry 					entry

			Šios leksemos yra naudojamos aprašyti taisyklėms kartu naudojant kitas taisykles atstojančias leksemas.

		3.3.x. Kalbos taisyklės
			Taisyklėms aprašyti naudojama forma yra
				<taisyklės pavadinimas>:
					<kableliais atskirtas taisyklės alternatyvų sąrašas>

				alternatyvas taisyklei sudaro leksemos ir taisyklės, kurioms gali būti taikomi modifikatorai
					? - elementas yra neprivalomas, jei jo nėra taisyklė alternatyva vis dar gali būti validi
					* - elementas yra neprivalomas bei gali būti kartojamas kelis kartus jei jis yra.

				Šie modifikatoriai gali būti taikomi taisyklių grupėms jas apskliaudžiant.

			Program:
				CodeConstruct*

			LaborasLang programą sudaro daugiau nei nulis CodeConstruct, tai yra daugiau nei nulis kalbos struktūrų. Jų gali būti ir nulis,
			tačiau tokia programa nėra itin naudinga.

			CodeConstruct:
			    CodeBlockNode,
			    WhileLoop,
			    ForLoop,
			    ForEachLoop,
			    ConditionalSentence,
			    StatementWithEndOfLine

			Galimos kalbos struktūros yra kodo blokas, ciklas "while", ciklai "for" bei "foreach", sąlygos sakiniai, ar sakiniai kurie
			baigiasi kabliataškiu.

			CodeBlockNode:
			    LeftCurlyBrace + CodeConstruct* + RightCurlyBrace
			Kodo bloko kalbos struktūrą sudaro kairysis figūrinis skliaustas "{", nulis ar daugiau kitų kodo konstrukcijų bei dešinysis
			figūrinis skliaustas "}"

			StatementNode:
			    UseNode,
			    DeclarationNode,
			    Value,
			    ReturnNode
			
			Sakinius sudaro importavimo sakinys "UseNode", deklaravimo sakinys "DeclarationNode", reikšmė (nesvarbu ar kairinė ar
			dešininė) "Value", grąžinimo sakinys. Šie sakiniai gali būti naudojami kaip kalbos struktūros prie jų pridėjus kabliataškį:

			StatementWithEndOfLine:
			    StatementNode? EndOfLine
			Šioje struktūroje sakinys yra neprivalomas - reikia bent vieno kabliataškio, bet jei jie kartojasi kelis kartus programa yra
			vis dar validi.

			UseNode:
			    Use FullSymbol
			Importavimo sakinį sudaro raktažodį "use" atitinkanti leksema bei pilnas simbolis - tai yra simbolių atskirtų taškais
			 rinkinys, kitur jis gali būti suprantamas kaip kairinė reikšmė.

			DeclarationNode:
			    VariableModifier* Type Symbol (Assignment Value)?
			Deklaravimo sakinį sudaro neprivalomi kintamojo modifikatoriai, jo tipas, kintamojo pavadinimas bei neprivalomas priskyrimo
			operatorius su dešinine reiškme

			ReturnNode:
			    Return Value?
			Grąžinimo sakinį sudaro raktažodis "return" bei neprivaloma dešininė reikšmė. Reikšmė neprivaloma nes void tipo funkcijose
			galima išeiti iš funkcijos negrąžinant jokios reikšmės

			Value:
			    (PrefixNode PostfixOperator*) (InfixOperator PrefixNode PostfixOperator*)* 
			Dešinines reikšmes atitinka taisyklė "Value". Dešininės reikšmės yra sudarytos iš priešdėlinių operatorių, dvinarių operatorių ir galūninių operatorių. galimi operandai apskliaustos dešininės reikšmės, dešininės reikšmės su masyvo narių pasiekimo operatoriumi ([x]), literalai, simboliai, funkcijų kvietiniai.

			PrefixNode:
		        PrefixOperator PrefixNode,
		        PrefixOperator ParenthesesNode,
		        ParenthesesNode

			PostfixOperator:
			    PlusPlus, 
			    MinusMinus,
			    IndexNode,
			    FunctionArgumentsList

			FunctionArgumentsList:
			    LeftParenthesis RightParenthesis,
			    LeftParenthesis Value CommaAndValue* RightParenthesis
			Funkcijos argumentai yra skliaustuose esančios dešininės reikšmės atskirtos kableliais

			PrefixOperator:
			    PlusPlus, 
			    MinusMinus, 
			    Minus, 
			    Not,
			    BitwiseComplement,
			    CastOperator

			CastOperator:
			    LeftParenthesis Type RightParenthesis			            
			        
			IndexNode:
			    LeftBracket Value CommaAndValue* RightBracket,
			    LeftBracket Comma* RightBracket),
			        
			ParenthesesNode:
			    LeftParenthesis Value RightParenthesis,
			    Operand
			            
			           
			Operand:
			    ArrayLiteral,
			    Function,
			    Symbol,
			    LiteralNode,
			    Null

			LiteralNode:
			    Float,
			    Integer,
			    Double,
			    Long,
			    CharLiteral,
			    StringLiteral,
			    True,
			    False
		        
			ArrayLiteral:
			    Type InitializerList,
			    InitializerList
			Masyvo tipo literalus sudaro masyvo tipas bei figūriniuose skliaustuose esantis sąrašas kableliu atskirtų dešininių reikšmių.

			InitializerList:
			    LeftCurlyBrace Value CommaAndValue* RightCurlyBrace,
			    LeftCurlyBrace RightCurlyBrace

			CommaAndValue:
			    Comma Value

			FullSymbol:
			    Symbol SubSymbol*
			FullSymbol taisyklė apima kairinius elementus - tai yra taškais atskirti simboliai.

			SubSymbol:
			    Period Symbol

			Type:
			    FullSymbol ParameterList*
			Tipą laborasLang kalboaje sudaro pilnas simbolis bei neprivalomas parametrų sąrašas.			
			ParameterList:
			    FunctorParameters,   
			    IndexNode                     
			Parametrai gali būti masyvo tipo arba funkcijos tipo

			FunctorParameters:
			    LeftParenthesis Type (Comma Type)* RightParenthesis,
			    LeftParenthesis Type Symbol (Comma Type Symbol)* RightParenthesis,
			    LeftParenthesis RightParenthesis
			Funkcijos tipo tipo parametrai sudaryti iš tipų, ar tipų ir simbolių sąrašo atskirto kableliais.
			
			Function:
			    Type CodeBlockNode                    
			Pačią funkciją sudaro tipas bei kodo blokas kuris bus vykdomas iškvietus funkciją.

			Išskiriami trys ciklų tipai ciklas "while", ciklas "foreach" bei ciklas "for"
			WhileLoop:
			    While LeftParenthesis Value RightParenthesis CodeConstruct
			ciklą while sudaro raktažodis "while", apskliausta dešininė reikšmė, bei kodo struktūra kuri bus kartojama

			ForEachLoop:
			    For LeftParenthesis Type Symbol In Value RightParenthesis CodeConstruct
			ciklą "foreach" sudaro raktažodis "for", skliaustuose esanti konstrukcija sudaryta iš iteravimo kintamojo deklaravimo,
			raktažodžio "in" bei dešininės reikšmės per kurią bus iteruojama
			
			ForLoop:
			    For LeftParenthesis Value? EndOfLine Value? EndOfLine Value? RightParenthesis CodeConstruct,
			    For LeftParenthesis DeclarationNode? EndOfLine Value? EndOfLine Value? RightParenthesis CodeConstruct
			paprastas "for" ciklas naudojamas taip pat kaip kitose C šiemos kalbose - naudojamas raktažodis "for", skliaustuose trys kodo
			segmentai atskirti kabliataškiais, kuriuose iš eilės aprašoma kintamojo deklaracija, dešininė reikšmė kuri atitinka ciklo
			sąlygą, bei sakinys kuris bus vykdomas kiekvienos po kiekvienos iteracijos. Šie segmentai gali neturėti jokio turinio.

			ConditionalSentence:
			    If LeftParenthesis Value RightParenthesis CodeConstruct (Else CodeConstruct)?
			sąlygos sakinys sudaromas iš raktažodžio "if", apskliaustos dešininės reikšmės, kodo struktūros kuri bus vykdoma jei sąlyga
			yra teisinga bei neprivalomo "else" raktažodžio kartu su kodo struktūra kuri bus vykdoma jei sąlyga yra neteisinga

4. LaborasLang programų pavyzdžiai
	
	Šiame skyriuje yra pateikiamos pavyzdinės LaborasLang programavimo kalbos programos.

	4.1. Hello world

		Tradicinė programa, atspausdinanti "Hello, world!".

			use System;

			entry auto Main = void()
			{
				Console.WriteLine("Hello, world!");
			};

	4.2. Begalinė rekursija

		Ši programa demonstruoja LaborasLang galinę rekursiją. Nors šioje programoje yra begalinė rekursija, ji niekada neperpildys dėklo, todėl programa veiks amžinai.

			auto IsEven = bool(int number)
			{
				return number % 2 == 0;
			};

			auto Func = void(int i)
			{
				if (IsEven(i))
				{
					System.Console.WriteLine("{0} is even", i);
					Func(i + 3);
				}
				else
				{
					System.Console.WriteLine("{0} is odd", i);
					Func(i + 5);
				}
			};

			entry auto Recursion = int()
			{
				Func(0);
				return 0;
			};

	4.3. Dainelė apie alaus butelius

		Ši programa deklamuoja dainelės apie alaus butelius tekstą.
		
			// Ši programa naudoja biblioteką System.Speech.dll
			use System;
			use System.Speech.Synthesis;

			entry auto BeerBottleSong = int()
			{
				auto synthesizer = SpeechSynthesizer();
				synthesizer.SetOutputToDefaultAudioDevice();
	
				const auto firstLine = string(int count) { return string.Format("{0} on the wall, {0}.", Bottles(count)); };
				const auto secondLine = string(int count) { return string.Format("Take one down and pass it around, {0} on the wall.", Bottles(count)); };
				const auto finalLine = string.Format("Go to the store and buy some more, {0} on the wall.", Bottles(99));

				auto count = 99;

				synthesizer.Speak(firstLine(count));

				while ((count -= 1) >= 0)
				{
					synthesizer.Speak(secondLine(count));
					synthesizer.Speak(firstLine(count));
				}
	
				synthesizer.Speak(finalLine);
				return 0;
			};

			auto Bottles = string(int count)
			{
				string ret;

				if (count > 0)
				{
					ret += count;

					if (count > 1)
					{
						ret += " bottles ";
					}
					else
					{
						ret += " bottle ";
					}
				}
				else
				{
					ret += "no more bottles ";
				}

				ret += "of beer";
				return ret;
			};

	4.4. Pirminiai skaičiai

		Ši programa spausdina, ar įvesti skaičiai yra pirminiai. Programa baigia darbą, kai įvedamas 0.

			use System;

			entry auto Main = void()
			{
				auto quit = false;
				Console.WriteLine("Enter 0 at any time to quit.");

				while (!quit)
				{
					int value;
					string line = Console.ReadLine();

					if (int.TryParse(line, value))
					{
						if (value == 0)
						{
							quit = true;
						}
						else
						{
							if (IsPrime(value))
							{
								Console.WriteLine("{0} is a prime number", value);
							}
							else
							{
								Console.WriteLine("{0} is not a prime number", value);
							}
						}
					}
					else
					{
						Console.WriteLine("Entered value is not a number!");
					}
				}
			};

			auto IsPrime = bool(int value)
			{
				if (value < 2)
					return false;
	
				auto isDivisor = bool(int value, int divisor) { return value % divisor == 0 && divisor < value; };

				auto isPrime = true;
				auto divisor = (int)Math.Sqrt(value) + 2;

				while (--divisor >= 2)
				{
					if (isDivisor(value, divisor))
						return false;
				}

				return true;
			};

	4.5. Interneto svetainės pavadinimas

		Pateikta programa iš įvestos interneto svetainės parsiunčia jos pavadinimą.

			// Ši programa naudoja biblioteką System.dll
			use System;
			use System.IO;
			use System.Net;

			entry auto Main = int()
			{
				auto website = Console.ReadLine();
				auto webResponse = WebRequest.Create(website).GetResponse();
				auto reader = StreamReader(webResponse.GetResponseStream());
				auto html = reader.ReadToEnd();

				reader.Close();
				webResponse.Close();
	
				const auto titleOpeningTag = "<title>";
				const auto titleClosingTag = "</title>";
				auto titleStartIndex = html.IndexOf(titleOpeningTag, StringComparison.InvariantCultureIgnoreCase) + titleOpeningTag.Length;
				auto titleEndIndex = html.IndexOf(titleClosingTag, titleStartIndex, StringComparison.InvariantCultureIgnoreCase);
				auto pageTitle = html.Substring(titleStartIndex, titleEndIndex - titleStartIndex);

				Console.WriteLine(pageTitle);
				Console.ReadKey();
				return 0;
			};

	4.6. Paprastas skaičiuotuvas

		Ši programa yra paprastas skaičiuotuvas, galintis atlikti keturias aritmetines operacijas: sudėti, atimti, dauginti ir dalinti.
		Ji grafinei sąsajai naudoja Windows Forms karkasą.

			// Ši programa naudoja bibliotekas System.Windows.Forms.dll ir System.Drawing.dll
			use System;
			use System.Drawing;
			use System.Globalization;
			use System.Text;
			use System.Windows.Forms;

			TextBox firstNumberTextBox;
			TextBox secondNumberTextBox;
			ComboBox operationComboBox;
			TextBox resultTextBox;

			Button calculateButton;

			const string kAdd = "Add";
			const string kSubtract = "Subtract";
			const string kMultiply = "Multiply";
			const string kDivide = "Divide";

			auto ValidateTextBox = void(object sender, EventArgs e)
			{
				auto textBox = (TextBox)sender;
				int decimalCount = 0;
				bool hasErrors = false;
				auto caretPosition = textBox.SelectionStart;

				for (int i = 0; i < textBox.Text.Length && !hasErrors; i++)
				{
					auto c = textBox.Text[i];

					if (c == '.')
					{
						decimalCount++;

						if (decimalCount > 1 || i == 0)
						{
							hasErrors = true;
						}
					}
					else if (c < '0' || c > '9')
					{
						hasErrors = true;
					}
				}
	
				if (!hasErrors)
					return;

				auto builder = StringBuilder();
				builder.Capacity = textBox.Text.Length;
				decimalCount = 0;
	
				for (int i = 0; i < textBox.Text.Length; i++)
				{
					auto c = textBox.Text[i];
		
					if (c >= '0' && c <= '9')
					{
						builder.Append(c);
					}
					else if (c == '.' && decimalCount == 0 && i > 0)
					{
						builder.Append(c);
						decimalCount++;
					}
					else if (i < caretPosition)
					{
						caretPosition--;
					}
				}

				textBox.Text = builder.ToString();
				textBox.Select(caretPosition, 0);
			};

			entry auto Main = void()
			{
				Application.EnableVisualStyles();
				Application.SetCompatibleTextRenderingDefault(false);

				const auto boxSize = Size(136, 20);
				const auto labelSize = Size(60, 20);
				const auto windowSize = Size(300, 350);

				const auto kControlCount = 4;
				const auto xPositions = { 20, 100 };
				const auto yPositions = { 30, 90, 150, 210, 270 };
		
				auto labels = Label[kControlCount];
				auto labelTexts = { "Number 1", "Operation", "Number 2", "Result" };
				auto controls =
				{
					firstNumberTextBox = TextBox(),
					operationComboBox = ComboBox(),
					secondNumberTextBox = TextBox(),
					resultTextBox = TextBox()
				};

				for (int i = 0; i < kControlCount; i++)
				{
					auto label = labels[i] = Label();
					label.Text = labelTexts[i];
					label.Location = Point(xPositions[0], yPositions[i]);
					label.Size = labelSize;
					label.TextAlign = ContentAlignment.MiddleRight;

					auto control = controls[i];
					control.Location = Point(xPositions[1], yPositions[i]);
					control.Size = boxSize;
					control.TabIndex = i;
				}
	
				firstNumberTextBox.add_TextChanged(ValidateTextBox);
				secondNumberTextBox.add_TextChanged(ValidateTextBox);

				operationComboBox.Items.AddRange({ kAdd, kSubtract, kMultiply, kDivide });
				operationComboBox.DropDownStyle = ComboBoxStyle.DropDownList;
				operationComboBox.SelectedIndex = 0;
				resultTextBox.ReadOnly = true;

				calculateButton = Button();
				calculateButton.Size = Size(75, 25);
				calculateButton.TabIndex = 4;
				calculateButton.Text = "Calculate";
				calculateButton.Location = Point(xPositions[1], yPositions[4]);
				calculateButton.UseVisualStyleBackColor = true;
				calculateButton.add_Click(void(object sender, EventArgs e)
				{
					auto leftText = firstNumberTextBox.Text;
					auto rightText = secondNumberTextBox.Text;
		
					if (leftText[leftText.Length - 1] == '.')
						leftText += '0';

					if (rightText[rightText.Length - 1] == '.')
						rightText += '0';

					auto leftOperand = double.Parse(leftText, CultureInfo.InvariantCulture);
					auto rightOperand = double.Parse(rightText, CultureInfo.InvariantCulture);
					auto operation = operationComboBox.SelectedItem;
					double result;

					if (operation == kAdd)
					{
						result = leftOperand + rightOperand;
					}
					else if (operation == kSubtract)
					{
						result = leftOperand - rightOperand;
					}
					else if (operation == kMultiply)
					{
						result = leftOperand * rightOperand;
					}
					else
					{
						result = leftOperand / rightOperand;
					}

					resultTextBox.Text = result.ToString(CultureInfo.InvariantCulture);
				});

				auto window = Form();
				window.Controls.AddRange(labels);
				window.Controls.AddRange(controls);
				window.Controls.Add(calculateButton);
				window.MinimumSize = windowSize;
				window.MaximumSize = windowSize;
				window.MaximizeBox = false;
				window.Text = "Simple Calculator";

				Application.Run(window);
			};

5. Pavyzdinis kompiliatorius

	Čia pateikiama pavyzdinio LaborasLang kompiliatoriaus dokumentacija. Šis kompiliatorius parašytas naudojantis C# programavimo kalba. Šio
	kompiliatoriaus išeities kodas yra publikuojamas GitHub terpėje (https://github.com/SusirinkeLaborams/LaborasLang-aka-ForScience-).

	5.1. Komponentai
	
		;; Truksta ivadinio sakinio
		5.1.1. „Lexer“

			Šis modulis iš programos išeities kodo sugeneruoja abstraktų sintaksės medį kuris yra toliau naudojamas semantinėje analizėje.
			Abstraktaus sintaksės medžio generavimas atliekamas trimis žingsniais:
				1. Išeities kodo skaidymas žetonais (leksemomis)
				2. Pirminis žetonų formavimas į abstraktų sintaksės medį
				3. AST medžio apdorojimas baigiamosiomis doroklėmis
			Pirmas žingsnis atliekamas "Tokenizer" komponento, antrasis - "Syntax matcher" modulio, trečiasis "Post processor" modulio. 
				;;todo išversti šitus žodžius, gal Jusas pasiūlys kokias lietuviškas alternatyvas
				;; Jusas sakė neversti - T.
				
			Lekserį sudaro šie komponentai:

			Tokenizer
				Šis komponentas iš išeities kodo teksto sugeneruoja sąrašą leksemų kurios turi tam tikrą tipą, turinį, vietą pradiniame
				išeities kode.
				RulePool
				Šis komponentas yra statinis kalbos gramatinių taisyklių sąrašas kuris naudojamas SyntaxMatcher modulio. Šis modulis
				nusako visą abstraktaus sintaksės medžio struktūrą kuri bus išlaikoma iki apdorojomo baigiamosiomis daryklėmis. Visos 
				aprašytos taisyklės yra bekontekstės, naudojama PEG gramatika. Konteksto nebuvimas apsunkina operatorių analizę, dėl to
					jų operacijų prioritetą atitinkantis medis yra suformuojamas baigiamosiomis daryklėmis.
			SyntaxMatcher
				Šis komponentas analizuoja leksemų sąrašą ir iš jo suformuoja medį pagal RulePool modulyje aprašytas taisykles.
			PostProcessors
				Šis komponentas leidžia atlikti kontektines operacijas su abstrakčiu sintaksės medžiu. Tai panaudojama atlikti veiksmus kurie
				yra labai sudėtingi naudojant PEG gramatiką. Šie veiksmai yra:
					Operatorių prioritetizavimas
					Funkcijų ir masyvų atskyrimas
					Neigiamų skaičių atpažinimas
					Taško operatoriaus apdorojimas
					Perteklinių medžio šakų minimizavimas

			5.1.1.1. „Tokenizer“

				Išeiteis kodas suskaidomas į leksemas. Leksema yra sudaryta iš jos turinio, tipo, vietos išeities kode.

				Modulio veikimo principas - iš eilės skaitomas tekstas po vieną simbolį kol nuskaityti simboliai gali būti sujungti į vieną 
				leksemą, pvz tekstas pirmas=antras+trečias; bus pradėtas skaityti, pirmas rastas simbolis yra raidė „p“, iš to 
				galima nuspręsti kad tai bus simbolis. Šis simbolis skaitomas kol bus rasta raidė netinkama simboliams - „=“, tada simbolis 
				bus užsaugotas, patikrita ar tai yra vienas iš rezervuotų žodžių tam kad nustatyti teisingą tipą ir pridėtas į leksemų sąrašą. 
				Analogiškai bus apdorojamas ir likęs išeities kodas.

			5.1.1.2. „RulePool“ (Taisyklių sąrašas)

				Saugomas kalbos gramatikos taisyklių sąrašas. Naudojama gramatika kuri yra panaši į PEG gramatiką[2].
				Taisyklės yra sudaromos iš terminalinių ir neterminalinių žetonų. Kiekvienam neterminaliniam žetonui yra nurodoma taisyklė 
				kuri jį aprašo terminaliniais ir neterminalianiais žetonais. Vieną neterminalinį žetoną galima aprašyti keliomis skirtingomis 
				taisyklėmis, jos bus taikomos iš eilės pagal deklaravimo tvarką. Taisyklėse naudjoami terminalinių ir neterminalinų žetonų 
				modifikatoriai: 
					* Vienas arba daugiau
					* nulis arba daugiau
					* neprivalomas galas
					* neprivalomas

				Modifikatorius „Vienas arba daugiau“					Naudojamas nurodyti kad šis elementas gali kartotis vieną arba daugiau kartų
				Modifikatorius „Nulis arba daugiau“
					Naudojamas nurodyti kad šis elementas gali kartotis nulį arba daugiau kartų. Gramatikoje naudojamas nurodyti neprivalomus 
					deklaracijos modifikatorius, vienanarius operatorius. 
				Modifikatorius „Neprivalomas galas“
					Šis modifikatorius naudojamas deklaracijose, juo nurodoma kad deklaracijose reikšmės priskyrimas nėra privalomas. Šis 
					operatorius gali būti pakeistas rekursiniu kreipiniu, tačiau toks kreipinys nėra optimalus dėklo naudojimo požiūriu bei 
					taisyklių skaitomumo atžvilgiu.
				Modifikatorius „Neprivalomas“
					Šis modifikatorius naudojamas nurodant neprivalomus žetonus. Šio modifikatoriaus naudojimo galima išvengti aprašant 
					alternatyvias taisykles.

				Taip pat taisyklės gali būti apibrėžtos kaip:
					* Taisyklė
					* Minimizuojama taisyklė
					* Visada minimizuojama taisyklė
				Minimizuojama ir visada minimizuojama taisyklės yra naudojamos tarpinių abstraktaus sintaksės medžio narių aprašymui kurie 
				turi prasmę tik leksikografinėje analizėje, tokie kaip "Kablelis ir reikšmė".

				Taisyklės palaiko ribotą rekursiją. Jos apribojimas yra tai kad rekursinis kreipinys privalo turėti bent vieną nerekursinį 
				kreipinį prieš rekursinį taisyklės panaudojimą. Nepaisant to tiesioginė rekursija taisyklių sąraše yra nenaudojama.

			5.1.1.3. „SyntaxMatcher“ (Sintaksės atpažinimo sistema)			
				
				Šis modulis leksemų sąrašą performuoja į abstraktų sintaksės medį pagal taisyklių sąrašą.

				Šis modulis perdirba Tokenizer sukurtą leksemų sąrašą į abstraktų sintaksės medį (AST). Taisyklių taikymas primena 
				Pacrat tipo analizę [3] primena „Pacrat Parser“, tačiau nenaudojamas tarpinių reikšmių įsiminimas.
				
				Bandoma pritaikyti RulePool aprašytas taisykles, pradedant nuo taisyklės kuri apima visą programą - tai yra taisyklė
				kuri sako jog programa yra sudaryta iš kodo struktūrų.
				Visos taisyklės analizuojamos vienodai - iš RulePool modulio parenkamos galimos taisyklės alternatyvos. Alternatyvos
				yra	sudarytos iš terminalinių žetonų ir kitų taisyklių. Gautos taisyklės alternatyvos yra lyginamos su žetonų sąrašu
				formuojant abstraktų sintaksės medį.
				
				Taisyklės alternatyvos atitikimas žetonų sąrašui tikrinamas lyginant taisyklę sudarančius žetonus su žetonų sąrašo
				elementais.
					Jei alternatyvos elementas yra nuoroda į kitą taisyklę mėginama pritaikyti tą taisyklę
					Jei alternatyvos elementas yra terminalinis žetonas tikrinama ar jis lygus dabar tikrinamam žetonų sąrašo
					žetonui.

				Jei bent vienas alternatyvos elementas neatitinka žetonų sąrašo elementų mėginama taikyti sekančią alternatyvą. Jei
				visos alternatyvos netinka teigiama kad ši taisyklė netinka šiam kodo segmentui, išvalomas šios taisyklės suformuotas
				medis ir grįžtama.
				Jei alternatyva atitiko žetonų sąrašą į abstraktų sintaksės medį įrašomas suformuotas medis ir grįžtama.

				Tikrinamos visos taisyklės alternayvos kol randama pirma tinkanti, pagal ją suformuojama medžio šaka ir grįžtama.
				Suformuotas AST savo struktūra atitinka taisykles.

				Tokia analizė yra bekontekstė, nes taikant taisyklė yra tikrinama tik ta kodo dalis kuri yra nepanaudota, nėra
				saugoma globali būsena.


				Jei programos kodas yra validus po taisyklių pritaikymo visi žetonai būna sunaudoti ir patalpinti abstrakčiame
				sintaksės medyje. Tačiau ne visas kodas yra validus, ir vartotojams reikia pranešti apie jų padarytas klaidas.
				Taisyklių taikymo mechanizmas to nepalaiko - kai taisyklė nebūna pritaikyta bandoma taikyti alternatyvą, dėl
				konteksto nebuvimo neina stebėti ar dar yra kitų galimų taisyklių. Tam yra sekama kiek žetonų buvo analizuota. Jei
				nebuvo sugeneruotas validus AST apimantis visą žetonų masyvą žetonai tarp paskutinio panaudoto žetono ir atsistatymo
				taško yra pažymimi kaip nesuprasti ir analizė yra tęsiama nuo atsistatymo taško siekiant pranešti daugiau nei vieną
				klaidą kompiliavimo metu.

				Atistatymo taškai yra žetonai kuriuos sekantis kodas gali būti išanalizuotas kaip kodo struktūra. Tai yra žetonai ";",
				"{", "}".

				SyntaxMatcher veikimo metodas nėra optimalus atminties naudojimo atžvilgiu - jam tikrinant taisykles yra plečiamas AST,
				jei taisyklė nepavyko jo dalis yra ištrinama ir kuriama iš naujo. Tai reiškia kad yra perkuriama itin daug objektų.
				Dėl to SyntaxMatcher modulio viduje AST struktūra saugoma ne Garbage Collector valdomoje atmintyje o kitame dėklo
				tipo konteineryje kuris leidžia perpanaudoti atminties blokus.
				
				Tam kad nereikėtų naudoti šios struktūros kituose moduliuose po suformavimo AST transformuojamas į medį kurio atmintį 
				valdo Garbage Collector.

			5.1.1.4. „PostProcessor“

				„PostProcessor“ yra modulis skirtas pridėti kontekstą į bekontekstinį lexerį. Po pirminės analizės kuri suformuoja abstraktų
				sintaksės medį medis yra transformuojamas kiekvienu aktyviu šio modulio elementu. Šio apdorojimo metu tikrinama medžio
				struktūra ir ji keičiama modifikuojant medžio šakas - keičiamos elementų pozicijos, jų tipai, šalinami ir pridedami
				elementai. Atliekamos operacijos:
					Operatorių prioritetizavimas
					Funkcijų ir masyvų atskyrimas
					Neigiamų skaičių atpažinimas
					Taško operatoriaus apdorojimas
					Perteklinių medžio šakų minimizavimas

				5.1.1.4.1. Operatorių prioritetizavimas

					Naudojamas Dijkstros „Shunting yard“ algoritmas ([4] §Making a Translator for ALGOL 60) įprastos, infiksinės, aritmetinių veiksmų 
					notacijos kurioje naudojami operatoriai yra tarp operandų transformavimui į atvikštinę lenkišką notaciją. Tai atliekama 
					nenaudojant „RulePool“ modulio, nes tai sudarė itin didelį kiekį papildomų taisyklių kurios turėjo būti naudojamos kiekvienai 
					reikšmei. Tai lėmė analizės sulėtėjimą bei sudėtingą „RulePool“ modulio taisyklių sąrašą.

				5.1.1.4.2. Funkcijų ir masyvų atskyrimas:

					Kalbos kūrimo metu pastebėta, kad kai kurios kalbos struktūros (taipai bei funkcijos) reikalauja tam tikro konteksto jų analizei. 
					Tai reiškia kad jie negali būti teisingai išanalizuoti naudojant „SyntaxMatcher“ modulį. Pasirinkta juos laikyti funkcijomis ir 
					kai žinomas papildomas kontekstas juos versti į teisingą tipą - funkcijos arba masyvo.					

				5.1.1.4.3. Neigiamų skaičių atpažinimas:
				
					Neigiami skaičiai yra išanalizuojami į vienanarį minuso operatorių bei skaičių. Tai reiškė kad modulyje „Parser“ jie negali būti
					teisingai atpažinti kaip neigiami skaičiai. Pridėta baigiamoji daryklė kuri randa tokius atvejus bei juos perdaro į neigiamų 
					skaičių leksemas.

				5.1.1.4.4. Taško opreratoriaus apdorojimas:

					Pilni tipai, objektų narių pasiekimas naudoja taško operatorių. Tokios struktūros yra analizuojamos į sąrašą taškais
					atskirtų leksemų, tačiau loginiu atžvilgiu tai turėtų būti medis kur kiekvienas sekantis taškas yra ankstesnio taško
					segmento vaikas - struktūra „System.Console.WriteLine“ turi būti išanalizuota į medį „System“ -> „Console“ -> „WriteLine“
					o ne [„System“, „.“, „Console“, „.“, „WriteLine“]. Tačiau medžio formavimas reikalauja rekursijos kuri lėtina
					analizę. Dėl to sąrašas yra performuojamas į medį naudojant papildomą baigiamąją daryklę.

				5.1.1.4.5. Perteklinių medžio šakų minimizavimas

					Vykdant analizę kai kurie medžio segmentai yra reikalingi tik palengvinti taisyklių aprašymą, pavyzdžiui operatorių grupavimas
					į infiksinius. Dėl to jie yra panaikinami siekiant sumažinti medį ir palengvinti jo analizę.
				
		5.1.2. „Parser“

			Parserio modulis analizuoja lekserio sukūrtą medį ir pagal jį sukuria naują panašios struktūros medį iš kalbos struktūras 
			aprašančių objektų. Dauguma šių objektų realizuoja §5.2.2. aprašytą sąsają, bet kai kurie objektai yra skirti vidiniam 
			naudojimui. Iš sąsajos pusės, parserio rezultatas yra miškas, kurio kiekvienas medis atitinka vieną metodą.
		
			Parserio veikimas yra pagrįstas lekserio medžio analize iteruojant žemyn. Kiekvienai kodo struktūrai yra sukuriama klasė su
			metodų Parse. Šiame metode vyksta lekserio mazgo analizė. 
			Klases galima skirstyti į tris kategorijas:
				* klasės skirtos apdoroti grupę struktūrų. Šios klasės iteruoja per lekserio mazgo vaikus, išparsina juos naudodamos kitas 
				klases ir renka gautus objektus. Pavyzdžiai: kodo bloko mazgas, klasės mazgas.

				* klasės skirtos apdoroti kelias vienos rūšies struktūras. Šios klasės gali gražinti skirtingus objektus atsižvelgiant į 
				tai, kokio tipo lekserio mazgas buvo paduotas. Pavyzdžiai: išraiškos mazgo klasė, literalo mazgo klasė.

				* klasės skirtos apdoroti vieną struktūrą. Šios klasės suformuoja mazgus, kurie bus naudojami gautame medyje. Paprastai 
				jos žemesnių mazgų parsinimą perduoda kitomis klasėsmis ir validuoda ar gautas mazgas yra teisingas. Pavyzdžiai: deklaracijos
				mazgo klasė, "while" ciklo klasė.

			5.1.2.x Kontekstinis medis

				Parserio darbui reikaligas antras kontekstinis medis. Šio medžio kryptis yra priešinga negu pagrindinio medžio - kiekvienas 
				mazgas turi nuorodą į aukštesnį kontekstinį mazgą. 
				Kontekstinis objektas duoda mazgui reikiamą informaciją apie jo aplinką:
					* mazgo metodas, jei toks yra
					* mazgo klasė
					* šio failo Parser objektas
					* mazgo asemblis

				Šis medis taip pat naudojamas pavienių simbolių parsinimui.

				ContextNode klasė:

					abstract class ContextNode : ParserNode
				    {
				        public ContextNode Parent { get; private set; }
				        public Parser Parser { get; private set; }
				        public AssemblyEmitter Assembly { get { return Parser.Assembly; } }

				        public abstract FunctionDeclarationNode GetMethod();
				        public abstract ClassNode GetClass();
				        public abstract ExpressionNode GetSymbol(string name, ContextNode scope, SequencePoint point);

				        protected ContextNode(Parser parser, ContextNode parent, SequencePoint point) : base(point)
				        {
				        	Parser = parser;
	            			Parent = parent;
				        }
			        }

		        Iš šios klasės paveldi:
		        	* ClassNode
		        	* CodeBlockNode
		        	* FieldDeclarationNode
		        	* ForEachNode
		        	* FunctionDeclarationNode

		        GetClass visada gražina šio failo klasę. GetMethod gražina metodą, jei mazgas yra metode. GetSymbol atlieka rekursinę 
		        identifikatoriaus paiešką ir gražina išraišką, jei identifikatorius buvo rastas.

		    5.1.2.x Laukai ir metodai

		    	Paprastai globalus kintamasis verčiamas klasės lauku. Kai kuriais atvejais vietoje lauko parseris gali sukurti metodą. 
		    	Tai yra daroma jei funkcijos tipo kintamasis yra konstanta ir taip pat yra inicializuotas. Kadangi kintamojo reikšmė 
		    	negali kisti, jį galima saugiai keisti metodu. Metodo iškvietimas yra greitesnis negu funkcijos objekto, taip pat metodai 
		    	leidžia naudoti perdengimą. Dėl šių priežasčių standartinis funkcijos kintamumo atributas yra "const". Metodas išlaiko 
		    	tą patį gražinamą tipą, pasiekiamumo atributą ir parametrus kaip funkcija.

			5.1.2.x Anoniminių metodų generavimas

				Funkcijos viduje negalima sukurti kitos funkcijos, kad ir kaip norėtusi. Dėl to, kompiliatorius turi sukčiauti ir iškelti 
				funkcijos objekto kodą į kitą metodą. Tokie metodai vadinami anoniminiais metodais, metodais, kurie neturi pasiekiamo 
				identifikatoriaus. Šie metodai būna toje pačioje klasėje, bet pavadinti vardais su vartotojui neleidžiamais simboliais. 
				Vardas generuojamas pagal šabloną $Lambda_<nr>, kur <nr> yra anoniminio metodo numeris. Šie vardai naudojami tik kompiliatoriaus viduje.

				Šis LaborasLang kodas:

					auto one = void()
					{
						auto two = void()
						{
							auto three = void()
							{
							};
						};
					};

				sugeneruoja kodą artimą:

					auto one = void()
					{
						auto two = $Lambda_0;
					};

					auto $Lambda_0 = void()
					{
						auto three = $Lambda_1;
					};

					auto $Lambda_1 = void()
					{
					};

			5.1.2.x Globalios galiojimo srities įgyvendinimas

				Globalių kintamųjų galiojimo sritis ypač apsunkina parsinimą. Kadangi kintamajį galima panaudoti anksčiau negu jis yra 
				deklaruojamas, tipinis parsinimas iteruojant per sakinius nebetinka. Šiai problemai išspresti kiekvienam failui yra 
				sukūriamas ClassNode objektas. Tada vykdomi 3 parsinimo etapai:

					1. Deklaracija. Parsinami "use" sakiniai ir kintamųjų deklaracijos. 
						Deklaracijose yra parsinami tik tipai ir identifikatoriai. Funkcijos kintamojo atveju yra išparsinama funkcijos 
						antraštė - gražinamas tipas ir parametrai. Tai reikalinga rekursijai - parsinant funkcijos kodą privalo egzistuoti 
						jos kintamasis. Visi metodai ir laukai, kurių tipas nėra "auto" yra deklaruojami klasės TypeEmitter.

					2. Inicializacija. Parsinami laukų inicializatoriai. 
						Inicializatoriai deklaruojami TypeEmitter, taip pat deklaruojami laukai, kurių tipas nebuvo žinomas anksčiau.

					3. Metodai. Parsinamas metodų kodas. 
						Visi metodai rasti pirmame etape yra parsinami ir perduodami kodo generatoriui. Jei metodų viduje yra funkcijos, 
						jos taip pat parsinamos.

				Tokie žingsniai leidžia deklaruoti visus klasių narius anksčiau negu yra parsinamas veikiantis kodas.

			5.1.2.x Automatinis tipo radimas

				Vienas iš parserio fundamentaliųjų tipų yra netikras tipas - "auto". Jei išparsinus deklaracijos tipą gaunamas šis tipas,
				 jis yra keičiamas inicializatoriaus tipu, arba gražinama klaida jei inicializatoriaus nėra ar jis netinkamas tipo radimui.

				Lokalių kintamųjų tipo radimas paprastas - išparsinamas inicializatorius ir naudojamas jo tipas. Sudėtingas yra globalių 
				kintamųjų tipo radimas. Kadangi inicializatoriaus parsinimas yra atidedamas, deklaracijos tipas gali būti nežinomas 
				deklaravimo stadijoje. Tokiu atveju kintamasis yra sukūriamas tik inicializavimo stadijoje.

			5.1.2.x Literalai

				Literalą nusako du objektai - lekserio mazgo tipas ir mazgo tekstinė reikšmė. 

				Literalų parsinimą sudaro šie žingsniai:

					1. Pagal lekserio mazgo tipą randamas literalo tipas.
					2. Pagal literalo tipą parenkamas reikšmės parsinimo algoritmas.

				Palengvinti darbą su literalais buvo sukurta klasė Literal. Ši klasė turi IConvertible tipo literalo reikšmę ir operatorius 
				skirtus konvertuoti šią reikšmę į norimus tipus. Todėl keičiant literalo tipą galima naudoti tą patį Literal objektą, 
				reikšmės konvertavimas bus atliktas tik tada, kada reikšmė bus reikalinga.

				Parsinimo algoritmai yra keli:
					* teksto eilutės ir loginės reikšmės: sukuriamas Literal objektas su mazgo reikšme.
					* tekstinis simbolis: taip pat kuriamas objektas, bet neleidžiamos reikšmės ilgesnės už 1.
					* realieji skaičiai: reikšmė parsinama naudojant Covert klasės .ToSingle arba .ToDouble metodus, atsižvelgiant į tipą.
					* sveikieji skaičiai: reikšmė parsinama naudojant BigInteger klasę. Gautas skaičius lyginamas su sveikųjų skaičių tipų 
					ribinėm reikšmėm. Jei gautas skaičius "telpa" į nurodytą tipą, naudojamas šis tipas. Kitu atveju parenkamas didesnis 
					tipas, arba gražinama klaida jei skaičius netelpa į nei vieną sveikųjų skaičių tipą.

			5.1.2.x IAmbiguousNode sąsaja

				Kai kurios išraiškos gali įgyti kelis tipus, iš kurių geriausią galima parinkti kompiliavimo metu. Šios išraiškos 
				realizuoja sąsają IAmbiguousNode.

				    interface IAmbiguousNode : IExpressionNode
				    {
				        ExpressionNode RemoveAmbiguity(ContextNode context, TypeReference expectedType);
				    }

				Jei išraiškos tipą įmanoma pakeisti į norimą, metodas gražina naują išraišką, kitu atveju gražinama ta pati išraiška.
				Toks tipo keitimas leidžia veiksmus, kurie kitaip būtų negalimi, taip pat leidžia panaikinti dviprasmybes kai kurios 
				išraiškose. Paprastai ši sąsaja naudojama ExpressionNode.Parse metode, gavus naują išraišką patikrinama ar jos tipą įmanoma pakeisti į norimą.

				Šią sąsają realizuoja dvi klasės: LiteralNode ir AmbiguousMethodNode.

			5.1.2.x Vidiniai medžio objektai

				Kai kurios išraiškos yra naudojamos tik parserio viduje kaip tarpiniai objektai. Tai yra išraiškos, kurios negali būti 
				įvykdytos, bet yra svarbios parsinimo metu.

				5.1.2.x.x Tipas ir vardų grupė

					Nors šios išraiškos neturi prasmės kodo generatoriui, jos yra naudojamos parsinant nario išraiškas. Vardų grupės 
					paprastai būna panaudotos toliau parsinti tipams arba importavimo sakiniams, o tipai tampa narių išraiškos dalimi, 
					arba jų informacija panaudojama deklaracijose.

				5.1.2.x.x Metodų grupė

					Ši išraiška gaunam, jei per nario išraišką pasiektas metodas yra perdengtas. Ji privalo būti pakeista metodo išraiška, 
					bet jos parsinimo metu nėra tam reikalingos infomacijos. Kviečiant tokią išraišką reikiamas metodas yra parenkamas 
					naudojant MetadataHelpers klasę. Naudojant šią išraišką tarp kitų išraiškų, metodas parenkamas pagal reikamą funckijos tipą. 

			5.1.2.x Nario išraiška

				Nario išraiškos veikimo principas - abu nariai parsinami kaip išraiškos, vėliau jungiami. Identifikatoriai nėra parsinami 
				pilnai - gražinama identifikatoriaus išraiška, o to identifikatoriau apdorojimas paliekamas nario išraiškai.

				Abi nario išraiškos dalys yra parsinamos kaip išraiškos. Jei išraiškos yra idenfitikatoriai, jos papildomai aprodojamos.

				Jei pagrindinė išraiška yra identifikatorius, ji toliau aprodojama kaip pavienis identifikatorius. Pagrindinė išraiška 
				išsaugojama. Ši išraiška gali būti bet kokio tipo.

				Nario identifikatoriaus yra paeiliui parsinamas kaip visos įmanomos identifikatoriaus kategorijos. Jei nepavyksta viena 
				kategorija, bandoma kita. Jei nepavyko nei viena kategorija, gražinama klaida. Bandymo tvarka:
					1. Laukas. Jei išraiška yra vardų grupė, bandomas kita kategorija. Jei išraiška yra tipas, ieškoma statinio lauko šiuo vardu. 
					Kitais atvejais, išraiškos tipe ieškoma nestatinio lauko.
					2. Metodas. Parisinimas analogiškas laukui. Ieškoma metodo arba metodų grupės.
					3. Tipas. Jei išraiška yra vardų grupė, joje ieškoma tipo šiuo vardu, jei tipas - tipe ieškoma šio tipo. Kitais atvejais 
					bandoma kita kategorija.
					4. Vardų grupė. Jei išraiška yra vardų grupė, joje ieškoma tipo arba vardų grupės identifikatoriaus vardu. 
					5. Savybė. Parsinimas analogiškas metodui ir laukui.

				Jei rezultatas nėra vardų grupė, po parsinimo tikrinama ar šią išraišką galima pasiekti. Tikrinimas priklauso nuo išraiškos, 
				jo veikimo principai atitinka CLI specifikaciją ([1] §I.8.5.3 Visibility, accessibility, and security).

			5.1.2.x Indekso išraiška

			5.1.2.x Kvietimo išraiška

			5.1.2.x Gražinimo validacija

				Parseris turi užtikrinti dvi gražinimo taisykles:
					1. gražinamos reikšmės tipas sutampa su funkcijos gražinamu tipu, arba yra galimas automatinis tipo keitimas
					2. jei funkcijos gražinamas tipas nėra "void", funkcija privalo garantuotai gražinti reikšmę

				Pirma taisyklė realizuojama "return" sakinio klasėje - parseris iš konteksto gauna funkciją, o iš jos gauna gražinamą tipą. 
				Patikrinama ar galimas tokios reikšmės gražinimas.

				Antrajai taisyklei buvo sukurta sąsaja IReturningNode. Šią sąsają realizuoja sakiniai, kuriuos įvykdžius galimas gražinimas iš metodo.

				    interface IReturningNode
				    {
				        bool Returns { get; }
				    }

				Realizacijos:
					* "return" sakinys. Šis sakinys garantuotai gražina.
					* kodo blokas. Šis sakinys gražina jei bent vienas jo sakinių gražina.
					* sąlygos sakinys. Šis sakinys gražina, jei egzistuoja abi atšakos ir jos abi yra gražinantys kodo blokai.

				Išparsinus funkcijos deklaraciją patikrinama ar jos blokas gražina. Jei negražina, o gražinamas tipas nėra "void", parseris gražina klaidą.

				Tokia realizacija leidžia nerašyti "return" sakinio metodo gale, jei garantuojama, kad toks sakinys yra anksčiau ir bus pasiektas.

					int(bool a)
					{
						if(a)
						{
							return 4;
						}
						else
						{
							return -4;
						}
					}

					Nors metodo bloke nėra "return" sakinio, jis garantuotai gražina, kadangi yra sąlygos sakinys, kurio abi atšakos garantuotai gražina.

			5.1.2.x Importavimo realizacija

				Importavimo sakinys nurodo parseriui, kad vardų grupę reikia įtraukti į importuotų sąrašą. Vėliau šios vardų grupės yra 
				naudojamos identifikatorių paieškoje. Kadangi tipai yra identifikuojami pagal jų pilną vardą, vardų grupės niekaip neįtakoja
				kompiliuotos programos veikimo, tik pakeičia identifikatorių, kuriuo galima jį pasiekti.

		5.1.3. Kodo generatorius
			
			Kodo generatorius yra kompiliatoriaus dalis, kuri tiesiogiai manipuliuoja CIL kodu ir metaduomenimis. Jį sudaro keletas subkomponentų:
				* Assembly Registry
				* Metadata Helpers
				* Assembly Emitter
				* Type Emitter
				* Method Emitter
				* Functor Emitter
				* Method Body Optimzers
			
			5.1.3.1. „Assembly Registry“ - asemblių registras
				 
				 Asemblių registras užkrauna bibliotekas ir saugoja jų metaduomenis. Jo paskirtis yra suteikti kompiliatoriui
				 žinias apie egzistuojančius tipus, metodus, laukus ir t.t. ir juos pateikti patogiu formatu. Kompiliavimo pradžioje, ši klasė
				 užkrauna visas vartotojo nurodytas bibliotekas - t.y. jų asemblius. Tai padaręs, asemblių registras sužino visus užkrautuose
				 asembliuose esančius tipus ir jų vidurius. Asemblių registras gali:

					* Pasakyti, ar tam tikra vardų grupė egzistuoja;
					* Surasti tipą pagal jo vardą;
					* Surasti tipe esančius metodus pagal vardą;
					* Surasti tipe esantį metodą, kuris labiausiai tinka iškviesti su pateiktais argumentų tipais;
					* Surasti tipe esantį lauką pagal vardą;
					* Surasti tipe esančią sąvybę pagal vardą;
					* Surasti tipe esantį indekso operatoriaus sąvybę pagal argumentų tipus;
					* Surasti funkcijos tipą pagal jos grąžinamą tipą ir argumentų tipus;
					* Sukurti masyvo tipą pagal jo elemento tipą ir matmenų skaičių;
					* Surasti specialius kolekcijos tipo metodus įgalinančius jos iteravimą.

			5.1.3.2. „Metadata Helpers“

				„Metadata Helpers“ - tai rinkinys funkcijų, skirtų padėti manipuliuoti metaduomenimis ir sužinoti jų sąvybes. Pagrindiniai Metadata Helpers

					* Pasakyti, ar tipas yra primityvus tipas, sveikasis skaičiaus tipas, slankiojančio kablelio skaičiaus tipas, funkcijos tipas ir t.t.;
					* Suskaičiuoti tipo dydį;
					* Nustatyti, ar vieno tipo kintamąjį galima priskirti kito tipo kintamajam;
					* Nustatyti, ar tipas paveldi kitą tipą visoje paveldimumo grandinėje;
					* Surasti tipo bazinį tipą;
					* Surasti visas sąsajas, kurias implementuoja tam tikras tipas;
					* Surasti nurodyto metodą deklaruojantį tipą;
					* Surasti nurodyto metodo grąžinamos reikšmės ir parametrų tipus;
					* Nustatyti, ar metodą galimą iškviesti su nurodytų tipų parametrais;
					* Nustatyti, ar tam tikras tipas, metodas ar laukas yra prieinami iš nurodyto tipo;
					* Importuoti tipą iš kito asemblio;
					* Nustatyti, ar per kolekciją galima iteruoti su kolekcijos iteravimo for ciklu.

				„Assembly Registry“ ir „Metadata Helpers“ subkomponentai įgalina kompiliatorių suprasti metaduomenų pasaulį ir leidžia parseriui validuoti visus
				LaborasLang programos atliekamus veiksmus.

			5.1.3.3. „Assembly Emitter“ ir „Type Emitter“

				„Assembly Emitter“ yra subkomponentas atsakingas už kompiliuojamo asemblio sukūrimą ir iššaugojimą diske. Kompiliatoriuje jis 
				yra objektas, simbolizuojantis kompiliavimo rezultatą. Kiekvienas asemblis iš esmės yra tipų konteineris ir dėl to, 
				„Assembly Emitter“ viena iš pagrindinių funkcijų ir yra kaupti sukurtus tipus.
				
				Kita svarbi „Assembly Emitter“ funkcija yra išsaugoti sukurtą asemblį diske. Prieš tai atlikdamas, „Assembly Emitter“ atlieka 
				keletą validacijos žingsnių:
					
					1. Patikrinti, ar asemblio tipuose nėra metodų su vienodais parametrų tipais. Tai yra geriausia vietą šiai validacijai 
					atlikti, nes visi metodai tuo metu yra galutinai sukurti. Ši validacija reikalinga, nes CLI specifikacija reikalauja, 
					jog viename tipe nebūtų daugiau, nei vieno metodo, turinčio tą patį vardą, tokį patį parametrų skaičių ir tokius pačius 
					parametrų tipus ([1], §I.10.2 Overloading).

					2. Atmesti visus programoje nenaudojamus funkcijų tipus. Kadangi šiuo metu programa jau yra sukompiliuota, 
					„Assembly Emitter“ geba surasti ir išmesti visus funkcijų tipus, kurie buvo matyti programoje, bet realiai niekada 
					nepanaudoti (pavyzdžiui, buvo deklaruota funkcija, kurios tipas void(), tačiau ji niekada niekam nebuvo priskirta).

					3. Jeigu asemblio tipas yra vykdomasis failas, patikrinti, ar yra metodas, esantis vykdomojo failo įeities taškas.

				Jei visi šie validacijos žingsniai pavyko, „Assembly Emitter“ gali saugiai išsaugoti asemblį diske.

				„Type Emitter“ yra tiesioginis kuriamo tipo atitikmuo kompiliatoriuje. Jis tiesiogiai valdo tipų laukus, jų inicializatorius ir metodus.

			5.1.3.4. „Method Emitter“

				„Method Emitter“ yra kodo generatoriaus širdis. Šis komponentas verčia parserio sudarytą medį tiesiai į CIL instrukcijas. 
				
				CIL yra dėklu pagrįsta žemo lygio objektinė programavimo kalba. Joje visos operacijos manipuliuoja duomenimis evaluacijos 
				dėkle. Pavyzdžiui, prieš kviečiant funkciją, visi argumentai yra įstumiami į evaluacijos dėklą, o funkcijos grąžinama 
				reikšmė yra reikšmė, esanti dėklo viršuje funkcijos pasibaigimo metu ([1], §I.12.1 Virtual Execution System).

				„Method Emitter“ veikimas pagrįstas parserio medžio (§5.2.2. „Parser“ ir kodo generatoriaus integracija) iteracija paieškos 
				gylyn metodu. Kiekviena parserio medžio viršūnė yra aplankoma iš eilės ir paverčiama į atitinkamą CIL kodą. Kadangi CIL
				kodas operuoja reikšmėmis, esančiomis evaluacijos dėkle, „Method Emitter“ gali tiesiogiai versti parserio medžio viršūnes
				į CIL instrukcijas nesirūpindamas jokia globalia būsena, tokia kaip procesoriaus registrų reikšmės.

				Pavyzdžiui, „Method Emitter“ parserio medyje aptikęs dvinarės operacijos viršūnę, reiškiančia sudėtį, suformuos instrukcijas 
				į evaluacijos dėklą įstumti abu sudėties operandus rekursiškai aplankydamas jų viršūnes, ir tada suformuos CIL instrukciją "add", 
				kuri sudeda dvi viršūtines evaluacijos dėklo reikšmės, o rezultatą įstumia atgal į evaluacijos dėklą.

				Kadangi kai kurios parserio medžio viršūnės tiesiogiai nesisieja su CIL instrukcijomis, „Method Emitter“ kartais reikšmes 
				turi saugoti laikinuosiuose kintamuosiuose. Šiam tikslui buvo panaudota speciali duomenų struktūra, kuri tiekia reikiamo 
				tipo lokaliuosius kintamuosius, ir gali juos pernaudoti, kai „Method Emitter“ žino, kad juose laikomos reikšmės nebereikės.
			
			5.1.3.5. „Functor Emitter“
				
				LaborasLang kalba palaiko tipus, kurių kintamiesiems galima priskirti funkcijas. Kodo generatorius šiuos tipus vadinas 
				funktoriais. „Functor Emitter“ tikslas yra surformuoti šiuos tipus.

				„Functor Emitter“ formuoja dviejų tipų funktorius: bazinius funktorius ir implementacijos funktorius.

				Kiekvienas funkcijos tipas LaborasLang kalboje atitinka vieną bazinį funktorių. Bazinis funktoriaus tipas yra abstrakti 
				klasė, turinti du metodus:
					1. Invoke(), kuris priima savyje laikomos funkcijos parametrus ir grąžina funkcijos gražinamą reikšmę;
					2. AsDelegate(), kuris funktorių paverčia į CLI specifikaciją atitinkantį "delegate" objektą ([1], §I.8.9.3. Delegates). 
					Šio gražinamo "delegate" objekto tipas yra deklaruotas kaip vidinis bazinio funktoriaus tipas.

				Funktoriaus implementacijos tipas paveldi iš atitinkančio bazinio tipo. Šis tipas yra sukuriamas, kai funkcijos tipo 
				kintamajam yra priskiriama tam tikra funkcija. Šio tipo Invoke() metodas iškvies priskirtą funkciją, o AsDelegate() metodas 
				sukurs "delegate" objektą kviečiamai funkcijai. Jei priskiriama funkcija nėra statinė, tai funktorius savyje taip pat laikys 
				objektą, ant kurio ši funkcija turi būti iškviesta.

				Kai LaborasLang kalboje yra kviečiamas kintamasis, kuris yra funkcija, tai atitinka funktoriaus Invoke() metodo kvietimą.

			5.1.3.6. „Method Body Optimizers“ - metodų optimizatoriai
			
				„Method Body Optimizers“ - metodų optimizatoriai - yra kodo generatoriaus dalis, kuri analizuoja ir optimizuoja „Method Emitter“
				sugeneruotą CIL kodą. Nors „Method Emitter“ stengiasi sugeneruotikuo efektyvesnį kodą, tai nėra visada įmanoma padaryti 
				pereinant visą parserio medį tik vieną kartą. Dėl šios priežasties, metodų optimizatoriai buvo pridėti į kodo generatorių.

				Šiuo metu, kompiliatoriuje yra keturi metodų optimizatorai. Iš jų kiekvienas yra pritaikytas optimizuoti skirtingus scenarijus.

				5.1.3.6.1. „nop“ instrukcijų šalinimas

					„nop“ instrukcija yra CIL instrukcija, kuri nieko nedaro. Ji naudojama kaip šuolių taikinys. Pavyzdžiui, jei sąlygos 
					sakinyje sąlyga nėra išpildoma, tai vykdomas šuolis į „nop“ instrukciją, kuri įdedama po sąlygos kodo bloko. Šis 
					optimizatorius iš metodo pašalina visas „nop“ instrukcijas, ir atnaujina visus šuolius, kad jų taikinys būtų sekanti 
					instrukcija po pašalintosios.

				5.1.3.6.2. Perteklinių šuolių šalinimas

					Šis optimizatorius aptinka situaciją, kai vykdomas šuolis į instrukciją, kuri grįžta iš metodo. Aptikęs tokią situaciją, 
					jis pakeičia šuolio instrukciją į grįžimo instrukciją. Šis optimizatorius padeda padidinti galinių kvietimų optimizacijos 
					efektyvumą (žr. §5.1.3.6.4.). Pavyzdžiui, šis optimizatorius būtų vykdoma tokiai LaborasLang funkcijai:					

						auto Func = void(int i)
						{
							if (IsEven(i))
							{
								System.Console.WriteLine("{0} is even", i);
								Func(i + 3);	// Po šito, vyksta šuolis į funkcijos pabaigą. Šis optimizatorius padaro, kad vietoj šuolio, funkcija grįžtų.
							}
							else
							{
								System.Console.WriteLine("{0} is odd", i);
								Func(i + 5);
							}
						};

				5.1.3.6.3. Negyvo kodo šalinimas

					Šis optimizatorius pašalina visą kodą, kuriam gali įrodyt, kad jis niekada nebus pasiektas. Tai pagreita JIT kompiliavimą 
					ir sumažina atminties naudojimą bei asemblio dydį. Optimizatorius visą metodą paverčia vienkrypčiu grafu: kiekviena instrukcija 
					tampa viršūne, kurios kaimynės yra sekanti instrukcija, šuolio taikinys arba abu, jei šuolis yra sąlyginis. Sudarius grafą, 
					vykdoma paieška gylyn ir pažymimos aplankytos viršūnės. Paieškos gale neaplankytos instrukcijos yra pašalinamos.

				5.1.3.6.4. Galinis metodo kvietimas

					Galinis metodo kvietimas - tai toks kvietimas, kuris neišsaugo dabartinės instrukcijų rodyklės adreso ir nepadidina 
					vykdymo dėklo - tai yra pernaudoja dėklo vietą, skirtą kviečiančiajam metodui. CLI specifikacija sako, jog galinis metodo 
					kvietimas yra validus tik tada, jei po kvietimo iš kart grįžtama iš kviečiančiojo metodo 
					([1], §I.12.4.1.2 Calling instructions). Šis reikalavimas yra natūralus: kadangi instrukcijos rodyklė nėra įrašoma į dėklą, 
					grįžtant iš iškviesto metodo yra grįžtama į praeitą metodą kvietimų dėkle, o ne šį dėklą. Jei po tokio kvietimoreiktų 
					atlikti kokią nors kitą operaciją, ji niekada nebūtų atlikta.

					Šis optimizatorius suranda visus metodų kvietimus, kuriuos gali paversti galiniai metodų kvietimais ir taip padaro. 
					Dėl CLI reikalavimo, kad galinis metodo kvietimas gali būti atliekamas tik prieš grįžimo instrukciją, perteklinių šuolių 
					optimizatorius turi galimybę smarkiai padidinti metodų kvietimų kiekį, kuriems atliema ši optimizacija.

	5.2. Komponentų integracija
	
		Šiame skyrelyje aprašyta, kaip skirtingi kompiliatoriaus komponentai bendrauja tarpusavyje, kokiu formatu ir sąsajomis perduoda duomenis.

		5.2.1. „Lexer“ ir „Parser“ integracija
		5.2.2. „Parser“ ir kodo generatoriaus integracija

			Parseris ir kodo generatoriaus bendrauja valdytojo-valdomojo principu: Kodo generatorius daro tai, ką jam liepia parseris. 
			Pagrindinis duomenų perdavimo mechanizmas, naudojamas duomenis perduoti iš parserio į kodo generatorių yra parserio medis. 
			Vienas parserio medis aprašo vienos funkcijos kūną. Toks medis kodo generatoriui suteikia visą reikalingą informaciją pilno
			metodo kodo generavimui.

			Pats parserio medis yra sudaromas iš 26 skirtingų sąsajų, kurios apibrėžia įvairias LaborasLang programavimo kalbos struktūras 
			(§8.1. Parserio medžio sąsajos). Kiekviena medžio viršūnė implementuoja vieną ar kelias iš šių 26 sąsajų. Pati elementariausia 
			sąsaja, kurią implementuoja visos kitos sąsajos, yra IParserNode, kuri tiesiogiai atitinka LaborasLang kalbos sakinį, kurį galima 
			naudoti funkcijos viduje (§2.5. Sakiniai). Ji yra apibrėžta taip:
						
				interface IParserNode
				{
					NodeType Type { get; }
					SequencePoint SequencePoint { get; }
				}

			NodeType nurodo sakinio tipą. SequencePoint susieja šią viršūnę su išeities failu ir vieta jame, kurioje šis sakinys buvo panaudotas.

			Pavyzdžiui, „Hello, world!“ programos parserio medis atrodo taip:

				ICodeBlockNode
					IReadOnlyList<IParserNode>
						IMethodCallNode
							Method: IMethodNode
								Instance: null
								Name: System.Void System.Console::WriteLine(System.String)
								Arguments: IReadOnlyList<IExpressionNode>
									ILiteralNode
										System.String "Hello, world"



	5.3. Testavimas

		Kuriant pavyzdinį LaborasLang kompiliatorių, jam buvo keliami dideli patikimumo ir regresijų nebuvimo reikalavimai. Dėl šios 
		priežasties, kompiliatoriui buvo rašomi testai, su tikslu ištestuoti kuo didesnę kompiliatoriaus funkcionalumo dalį. Tai yra ypač 
		svarbu kuriant tokią programą kaip kompiliatorius, nes testais padengus visą programos funkcionalumą galima nesibaiminti, jog 
		pakeitus tam tikro komponento veikimą netyčia bus sugriauta kokia nors kompiliatoriaus funkcija.
		
		LaborasLang pavyzdiniam kompiliatoriui iš viso buvo parašyti 446 testai. Šie testai skirtomi į keturias pagrindines grupes: 
		lekserio testai, parserio testai, kodo generatoriaus testai ir integracijos testai. 

		5.3.1. Lekserio testavimas
			Visi moduliai testuoti skirtingai, atsižvelgiant į jų veikimo principą.
			
			5.3.1.1 „Tokenizer“ testavimas
				Modulis testuojamas naudojant išeities kodo pavyzdžius kurie sudaryti taip kad testais būtų padengtas visas šio modulis. 
				Testai vyikdomi sugeneruojant leksemų sąrašą ir jį lyginant su anksčiau sugeneruotu leksemų sąrašu. Jei leksemų sąrašai 
				nesutampa apie tai pranešama programuotojui ir jie patikrinami, lyginant su siekiamu rezultatu. Pagal tai ar atitinka 
				rezultatą nusprendžiama ar testas yra sėkmingas ar nesėkmingas. Visi gauti sąrašai yra serializuojami ir saugomi kartu 
				su testų duomenų sąrašu.

			5.3.1.2 „RulePool“ testavimas

				Taisyklių sąrašas testuotas jį naudojant sintaksės atpažinimo modulyje bei atliekant taisyklių analizę:
					Tikrinama ar nėra nenaudojamų taisyklių
					Tikrinama ar visi galimi žetonai yra apibrėžti taisyklėse
					Tikrinama ar nėra begalinės rekursijos taisyklėse 

					5.3.1.2.1 Nenaudojamų taisyklių radimas
						Kalbos taisyklės sudaro grafą, kurio viršūnės yra taisyklių žetonai o lankai - ryšiai tarp taisyklių. Testo metu 
						vykdoma paieška gilyn, po kurios tikrinama ar yra neaplankytų viršūnių, neaplankyta taisyklė reiškia kad taisyklių 
						rinkinys yra neteisingas ir testas nėra sėkmingas.

					5.3.1.2.2 Nenaudojamų taisyklių žetonų radimas
						Vykdoma paieška gilyn taisyklių grafe, žymima kurie žetonai buvo paminėti taisyklėse, radus nepaminėtų žetonų 
						pabaigus paiešką testas laikomas nesėkmingu.

					5.3.1.2.3 Begalinės rekursijos paieška taisyklėse
						Taisyklių grafe ieškoma ciklų naudojant pirmus taisyklų elementus, nes tokia rekursija nėra paliakoma. Rasti ciklai
						reiškia kad testas yra nesėkmingas.
					
			5.3.1.3 „Syntax Matcher“ testavimas

				„SyntaxMatcher“ testuojamas regresiniais testais. Naudojant abię išeities kodo pavyzdžių yra sugeneurojami AST kurie yra lyginami 
				su ankstesnės versijos modulio sugeneruotais AST. Tai leidžia paprastai sukurti naujus testus - užtenka parašyti kodo segmentą
				kurį norima validuoti ir peržiūrėti sugeneruotą AST tikrinant jo korektiškumą.
				Tokio testavimo trūkumai - kartu su išeities kodu reikia saugoti serializuotus ast, jei keičiasi medžio API reikia pergeneruoti
				ir patikrinti daug duomenų.
				
				Testuose taip pat tikrinama kad medžiuose nėra nei vieno neatpažinto žetono. Neatpažinti žetonai rodo, kad taisyklių rinkinys
				nepadengia visos kalbos gramatikos.

		5.3.2. Parserio testavimas
		5.3.3. Kodo generatorius testavimas
			
			Kodo generatoriaus testai testuoja skirtingas kodo generatoriaus dalis. Šiuos testus galima suskirstyti į tris grupes: vienetų 
			testai, CIL kodo palyginimu grįsti testai ir vykdymu grįsti testai.

			5.3.3.1. Vienetų testai

				Kodo generatoriaus vienetų testai testuoja pavienių funkcijų veikimą. Jie naudojami testuoti funkcijas, kurios nepriklauso 
				nuo jokios globalios būsenos. Šiuos reikalavimus kodo generuotoriuje tenkina Assembly Registry ir Metadata Helpers 
				komponentai, todėl būtent jiems ir buvo rašomi vienetų testai. Šiems testas yra sudaroma baigtinė argumentų ir rezultatų 
				aibė, iš kurios argumentai yra paduodami pavienėms funkcijoms ir tikrinama, ar jos rezultatas sutapo su rezultatu, kurio 
				buvo tikėtasi. Šių testų pavyzdžiu galima laikyti testą, kuris testuoja, ar Metadata Helpers funkcija IsAssignableTo() 
				teisingai nustato, ar vieno tipo reikšmę galima priskirti kito tipo kintamajam.

			5.3.3.2. CIL kodo palyginimu grįsti testai

				Šie testai specialiai manipuliuoja kodo generatoriumi, kad šis sukurtų asemblį, turintį tam tikrą CIL kodą. Tada, iš gauto 
				asemblio yra nuskaitomas CIL kodas, ir jis yra palyginimas su iš anksto paruoštu CIL kodu. Šie testai yra naudojami vietose, 
				kur reikia užtikrinti, jog gautas CIL kodas yra stabilus ir niekada nekis su tokiomis pačiomis įvestimis. Vienas tokio 
				testo pavyzdys yra testas, kuris testuoja, ar kodo generatorius teisingai sugeneruoja funktorių vardus. Turint tokį testą 
				yra užtikrinama, jog funkctorių vardai netyčia nepasikeis keičiant kodo generatoriaus vidų.

			5.3.3.3. Vykdymu grįsti testai

				Kaip ir praeitame skyrelyje (§5.3.3.2. CIL kodo palyginimu grįsti testai) minėti testai, šie testai manipuliuoja kodo 
				generatoriumi, kad šis sugeneruotų asemblį su tam tikru CIL kodu. Tai yra atliekama jam paduodant ranka parašytą parserio 
				medį, kuris įvykdo tam tikras operacijas ir išspausdina rezultatą į standartinę išvestį. Sugeneravus asemblį yra paleidžiama 
				programa  „PEVerify“, kuri patikrina, ar sugeneruoto asemblio struktūra ir CIL kodas yra validūs. Po to, asemblis yra 
				paleidžiamas ir yra nuskaitoma jo standartinė išvestis. Ji yra lyginama su numatytaja išvestimi. Dauguma kodo generatoriaus 
				testų yra vykdymu grįsti testai. Ši testų struktūra leidžia laisvai keisti generuojamo kodo pavidalą ir vistiek ištestuoti, 
				ar kodo semantinė prasmė nepakito. Jei vietoje šių testų būtų naudojami CIL kodo palyginimu grįsti testai, tai kiekvieną 
				kartą pakeitus, kaip kodo generatorius generuoja kodą, testai sulūžtų.

		5.3.4. Integracijos testavimas

			Integracijos testai kompiliatoriuje yra naudojami ištestuoti visą kompiliatoriaus darbą: nuo komandinės eilutės analizės iki asemblio
			išsaugojimo diske. Šie testai susidaro iš trijų dalių: išeities kodo, kuris yra sukompiliuojamas, įvesties simbolių eilutės, kuri yra
			paduodama paleistam asemblis (kuris yra gautas sukompiliavus programos išeities kodą) ir išvesties simbolių eilutės, su kuria bus
			lyginama programos išvestis.

			Kiekvienas integracijos testas prasideda su komandinės eilutės, kuri bus paduodama kompiliatoriui, suformavimo. Joje būna nurodomas
			vienas arba daugiau išeities failų ir vieta diske, kur kompiliatorius turėtų sukurti asemblį. Suformavus šią eilutę, ji yra perduodama
			paleistam kompiliatoriui. Kai kompiliatorius baigia darbą, yra patikrinama jo grąžintas klaidos kodas operacinei sistemai: jei jis yra
			0, tai kompiliavimas pavyko. Kitu atveju, testas nepavyksta.

			Turint asemblį, testavimo karkasas paleidžia „PEVerify“ programą, jai perduodamas asemblio vietą diske, kad ši patikrintų, ar asemblio
			struktūra ir CIL kodas yra validūs. Nesėkmės atveju, testas yra nutraukiamas.

			Paskutinis integracijos testo žingsnis - paleidžiamas sukompiliuotas asemblis, jam paduodama įvesties simbolių eilutė ir nuskaitoma jo
			išvestis. Ši išvestis yra palyginima su numatytąja. Jei išvestis nesutampa, testas nepavyksta. Priešingu atveju, testas buvo sėkmingas.

		5.3.5. Kontraktai/statinė analizė

			Kuriant kompiliatorių, be testų naudojome papildomas kokybės kontrolės priemones: kontraktus ir statinę analizę. Kontraktai suteikia
			galimybę nustatyti priešsąlyginius ir posąlyginius reikavimus metodams. Priešsąlyginiai reikalavimai yra reikavimai, kurie turi galioti
			metodo iškvietimo metu, o posąlyginiai reikalavimai nustato sąlygas, galiojančias metodą įvykdžius. Kontraktai leidžia lengvai nustatyti,
			kokių įvesčių ar būsenų metodas tikisi ir garantuoti, ką jis grąžins ar tam tikrų būsenų būvimą. Tai yra ypač svarbu, kai vieno žmogaus
			rašyti komponentai turi bendrauti su kito žmogaus rašytais komponentais, kai jų bendravimas nėra visiškai specifikuotas, o sutartas tik
			žodžiu.
			
			Kontraktus pažįsta C# statinis analizatorius, kuris gali patikrinti, ar niekas nepažeidžia kontraktų. Pavyzdžiui, jei metodas,
			turintis sveiko skaičiaus parametrą, pažymimas, kad ko jo kontraktas reikalauja, jog skaičius būtų didesnis nei 10, tai statinis
			analizatorius suras visas vietas kode, kur yra kviečiamas šis metodas ir bandys įrodyti, kad visais įmanomais atvejais šis argumentas
			bus didesnis nei 10. Jei to įrodyti nepavyksta, statinė analizės rezultatas bus perspėjimas, jog gali būti, kad kontraktas yra
			nepaisomas.	Tokia statinė analizė yra atliekama kiekvieną kartą kompiliatorių kompiliuojant su „Checked“ konfigūracija.

			Kontraktai taip pat yra validuojami kompiliatoriaus vykdymo metu, jei kompiliatorius yra sukompiliuotas su „Debug“ arba „Checked“
			konfigūracija. Jei kontraktas yra pažeidžiamas vykdymo metu, kompiliatoriaus darbas yra sustabdomas. Kontraktai yra išoptimizuojami,
			jei kompiliatorius yra sukompiliuojamas su „Release“ konfigūracija.

	5.4. Naudotos bibliotekos

		Pavyzdinis LaborasLang programavimo kalbos kompiliatorius be standartinių .NET karkaso bibliotekų naudojo vieną biblioteką:	Mono.Cecil
		(https://github.com/jbevain/cecil). Ši biblioteka leidžia patogiai manipuliuoti CIL kodu ir asemblių metaduomenimis. Jos pagalba,
		kompiliatorius sugeba nuskaityti iš disko asemblius, sukurti naujus asemblius, modifikuoti jų vidų (pavyzdžiui, generuoti kodą) ir
		sukurti PDB failus, kurie leidžia įvairioms derintuvėms derinti sukompiliuotą programą.

	5.5. Vartotojo dokumentacija

		LaborasLang pavyzdinis kompiliatorius turi komandinės eilutės vartotojo sąsają. Kompiliatoriui visi parameterai yra paduodami juos
		perduodant kaip komandinės eilutės argumentus. Bendras komandinės eilutės formatas yra toks:
		
			LaborasLangCompiler.exe <kompiliatoriaus_argumentai>

		Visi argumentai yra atskiriami tarpu. Jei tam tikrame argumente yra tarpų, jį galima apgauti kabutėmis, taip pažymint, jog tai yra vienas
		argumentas. Galimi kompiatoriaus argumentai yra pateikiami žemiau pavaizduoje lentelėje.

		Argumento formatas           Argumento pavyzdžiai            Apibrėžimas ir pastabos

		<išeities_kodo_failas>       "C:\My Docs\HelloWorld.ll"      Šiuo parametru yra nurodomas programos išeities kodo failas. Programą gali
		                             ..\HelloWorld.ll                sudaryti vienas arba daugiau išeities kodo failų.
									 HelloWorld.ll

		/OUT:<asemblio_failas>		 /OUT:C:\out.exe                 Nurodo, kur kompiliatorius turi padėti ir kaip pavadinti
		                             /OUT:..\out.dll                 sukompiliuotą asemblį. Jei programą sudaro tik vienas išeities kodo failas,
									 /OUT:"hello world.exe"          šis argumentas nebūtinas - jo nenurodžius, kompiliatorius asemblį sukuria
																     šalia išeities kodo failo. Šį parametrą galima nurodyti tik vieną kartą.

		/REF:<bibliotekos_nuoroda>   /REF:System.dll                 Nurodo, jog kompiliuojama programa naudoja nurodytą biblioteką
		                             /REF:System.Forms.dll           (§5.5.2. Bibliotekų nuorodos)
									 /REF:E:\MyDotNetLibrary.dll

		/CONSOLE                                                     Nurodo sukompiliuoto asemblio tipą (§5.5.1. Išvesties tipai). Išvesties tipą
		/WINDOWS                                                     galima nurodyti tik vieną kartą. Šis parameteras nėra būtinas - jo nenurodžius
		/DLL                                                         naudojama jo numatytoji reikšmė „/CONSOLE“.
		
		/ROOT:<šakninė_directorija>  /ROOT:C:\SourceFiles            Nurodo šakninę programos direktoriją (§5.5.3. Šakninės direktorijos). Šakninių
		                             /ROOT:..\SomeOtherFolder        direktorijų gali būti daugiau nei viena, tačiau šis parameteras nėra būtinas.


		5.5.1. Išvesties tipai

			Pavyzdinis LaborasLang kompiliatorius palaiko trys asemblių tipus:

				* „Console“ - tai yra aplikacija, naudojanti komandinę eilutę vartotojo sąsajai. Tai yra numatytasis asemblio tipas. Šio tipo
				asembliai yra vykdomieji failai, jie turi galūnę „.exe“.
				* „Windows“ - tai yra aplikacija, kuri neturi komandinės eilutės lango. Šio tipo asembiai yra vykdomieji failai, jie turi
				galūnę „.exe“.
				* „DLL“ - tai yra LaborasLang biblioteka. Šio tipo asembiai nėra vykdomieji failai, jie turi galūnę „.dll“.

		5.5.2. Bibliotekų nuorodos

			LaborasLang programavimo kalba sugeba naudotis kitų .NET programavimo kalbų bibliotekomis. Tai galima pasiekti LaborasLang
			kompiliatoriui nurodant "/REF:<>" parametrą su bibliotekos asemblio failu. Nurodžius biblioteką, joje esančius tipus galima naudoti
			tiesiogiai.

		5.5.3. Šakninės direktorijos

			LaborasLang kalbos pavyzdinis kompiliatorius palaiko „Šakninių direktorijų“ sąvoką. Šios direktorijos nurodo kompiliatoriui į kokias
			vardų grupes įdėti LaborasLang tipus. Kadangi kiekvienas LaborasLang išeities kodo failas pavirsta į klasę kompiliavimu metu,
			tai kiekvienam failui galima priskirti po vardų grupę. Nurodytose šakninėse direktorijose esantys failai būna priskiriami į tuščią
			vardų grupę, o failai, esantys pakatalogiuose įgyja pakatalogių vardų grupę. Pavyzdžiui, jei nurodoma viena šaktininė direktorija
			„C:\MySource“, tai šie failai pateks į atitinkamas vardų grupes:

				C:\MySource\a.ll                                 (tuščia vardų grupė)

				C:\MySource\First\b.ll                           First

				C:\MySource\Second\b.ll                          Second

				C:\MySource\First\Sub\b.ll                       First.Sub

			Kiekvienoje vardų grupėje gali būti tik vienas išeities kodo failas, turintis tokį patį pavadinimą. Jei yra nurodyta bent viena
			šakninė direktorija, visi išeities kodo failai turi būti bent viename šakninės direktorijos pakatalogyje. Jei nenurodyta nei viena
			šakninė direktorija, failams, kurie yra nurodomi pilnu vardu (pvz. „C:\MySource\a.ll“), priskiriama tuščia vardų grupė, failas,
			kurie nurodomi naudojantis reliatyvų vardą (pvz. „..\MySource\a.ll“) yra priskiriama reliatyvią direktoriją atitinkanti vardų grupė.

6. Išvados

7. Literatūra

	[1] - Standard ECMA-335 - Common Language Infrastructure (CLI) (http://www.ecma-international.org/publications/standards/Ecma-335.htm)
	[2] - Parsing Expression Grammars: A Recognition-Based Syntactic Foundation (http://bford.info/pub/lang/peg.pdf)
	[3] - Packrat Parsing: Simple, Powerful, Lazy, Linear Time (http://bford.info/pub/lang/packrat-icfp02.pdf)
	[4] - ALGOL-60 Translation (http://www.cs.utexas.edu/~EWD/MCReps/MR35.PDF)
	

8. Priedai
	8.1. Parserio medžio sąsajos


SO FAR TODO:

komentarai
double check compilation of snippets

lekseris, parseris, syntax matcheris, postprocesorius -> kabutes ir lietuviskai