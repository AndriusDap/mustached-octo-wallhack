Programavimo kalba „LaborasLang“
Bakalauro baigiamasis darbas


Techininė užduotis
Autentiškumo patvirtinimas
Santrauka
Summary
Lentelių sąrašas
Paveikslų sąrašas
Terminų ir santrumpų žodynas

	Asemblis – failas, kuris yra LaborasLang programos kompiliavimo rezultatas. 
	CIL (Common Intermediate Language) – kalba, kurią supranta ir geba vykdyti CLI implementacijų vykdymo aplinkos.
	CLI (Common Language Infrastructure) – tai specifikacija, aprašanti virtualią vykdymo aplinką ir CIL kodą. CLI yra specifikuota ECMA-335 tarptautiniame standarte. Dvi populiariausios CLI implementacijos yra CLR (.NET karkaso dalis) ir Mono Runtime.
	LaborasLang programa – vienas ar daugiau išeities kodo failų, kurie nurodomi LaborasLang kompiliatoriui kaip duomenys. 
	Įeities taškas (entry point) – speciali funkcija, kuri yra iškviečiama paleidus aplikaciją.
	Išraiška (expression) – kodo fragmentas, kurį įvykdžius galima gauti reikšmę, arba jam nustatyti reikšmę.
	Skaitoma išraiška (gettable expression, rvalue) – išraiška, kuri garantuotai grąžina reikšmę.
	Rašoma išraiška (settable expression, lvalue) – išraiška, kuriai galima nustatyti reikšmę.
	Lokalus kintamasis (local variable) – kintamasis deklaruotas funkcijoje.
	Globalus kintamasis (global variable) – kintamasis deklaruotas faile.
	Galiojimo sritis (scope) – taisyklės nusakančios kintamųjų pasiekiamumą.
	Sąveika (interoperability) – sistemos galimybė bendrauti su kitomis sistemomis. Kalbos kontekste tai yra galimybė naudoti resursus sukurtus kitomis kalbomis, taip pat kitose kalbose naudoti LaborasLang resursus.
	Blokas, kodo blokas – Kodo fragmentas apribotas simboliais „{“ ir „}“.
	Literalas (literal) – Kode įrašyta reikšmė.
	Vertės tipas (value type) – tipas, kurio kintamasis laiko reikšmę.
	Nuorodos tipas (reference type) – tipas, kurio kintamasis laiko nuorodą į reikšmę.
	Daugybinis tipas (generic type) – tipas turintis kelis daugybinius parametrus, galintis aprašyti kelis skirtigus tipus.
	Tipo pseudonimas (type alias) – papildomas vardas skiriamas tipui.
	Dantytas masyvas (jagged array) – masyvas sudarytas iš kitų masyvų.
	Automatinis tipo keitimas (implicit cast) – reikšmės tipas pagal poreikį keičiamas be vartotojo reikalavimo.
	Nurodomasis tipo keitimas (explicit cast) – reikšmės tipas keičiamas, nes taip nurodė vartotojas.
	Funkcijos parametras (function parameter) - funkcijos deklaruojamas kintamasis, kuris įgyja funkcijos argumento reikšmę. ;;geriau nemoku parašyti, bet niekas nežino kuo arg nuo param skirias
	Funkcijos argumentas (function argument) - reikšmė paduodama funkcijai.
	Vardų grupė (namespace) - ;; dunno, lol - D.


Įvadas

	Ši specifikacija aprašo programavimo kalbą, pavadinimu „LaborasLang“. LaborasLang kalbos autoriai yra Andrius Dapševičius, Darius Lapūnas ir Tautvydas Žilys. 
	Pagrindiniai tikslai, keliami LaborasLang, yra:
	•	Esamiems programuotojams pažįstama sintaksė. Yra siekiama, kad programuotojai,  pažystami su bet kuria programavimo kalba, kurios sintaksė yra kilusi iš C kalbų šeimos, galėtų greitai išmokti programuoti su LaborasLang.
	•	Statinė tipų sistema. LaborasLang kompiliatorius turi sugebėti statiškai patikrinti tipų naudojimą.
	•	Funkcijos – pirmos klasės nariai. LaborasLang programavimo kalboje, funkcijas galima naudoti lygiai taip pat, kaip ir bet kurį kitą duomenų tipą.
	•	Paprastumas. Vienas iš LaborasLang uždavinių – būti kuo įmanoma paprastesnei.
	•	Vykdymo greitis. LaborasLang kalba parašytos programos turi galėti efektyviai išnaudoti kompiuterio resursus. ;;Ar čia kalbos ar implementacijos dalis? A.
	•	Sąveika su kitomis programavimo kalbomis. LaborasLang kalba parašytos programos turi galėti naudotis bibliotekomis, kurios yra parašytos kitomis .NET programavimo kalbomis. Dėl šios priežasties, LaborasLang programos yra kompiliuojamos į CIL. Taip pat bibliotekos parašytos LaborasLang turi veikti kitose .NET kalbose.


1. Apimtis ;;siūlau Specifikacijos apimtis A.

	Ši specifikacija apibrėžia LaborasLang programavimo kalbą. Tai apima:
	•	LaborasLang kalbos leksinę ir sintaksinę gramatiką;
	•	LaborasLang kalbos semantiką;
	•	LaborasLang kalbos apribojimus.
	Kartu su specifikacija pateikiamas pavyzdinio LaborasLang kalbos kompiliatoriaus aprašas.

2. LaborasLang apžvalga
	LaborasLang yra statiškai tipuojama, procedūrinė, kompiliuojama, bendros paskirties programavimo kalba, turinti funkcinio programavimo elementų. Šis skyrius aprašo pagrindines LaborasLang kalbos savybes.

	2.1. Pirmoji LaborasLang programa

		Pavyzdinė „Hello, world“ programa LaborasLang kalboje gali būti užrašoma taip:

		use System;         

		entry auto HelloWorld = void()
		{
		    Console.WriteLine("Hello, world!");
		};

		Išnagrinėkime šią programą po eilutę:
		•	Sakinys  use System; nurodo, jog šiame faile tipai ir vardų grupės iš System vardų grupės bus tiesiogiai pasiekiami.
		•	entry auto HelloWorld = void() šioje eilutėje yra deklaruojamas kintamasis HelloWorld. Šiam kintamajam yra priskiriama funkcija, kurios tipas – void(). Kadangi kintamojo deklaravimo metu jam yra priskiriama reikšmė, tai jo tipą galima nustatyti automatiškai – tai nurodo specialus tipas auto. Raktinis žodis entry nurodo, jog šis kintamasis yra programos įeities taškas.
		•	{ pažymima funkcijos pradžia.
		•	Console.WriteLine("Hello, world!"); iškviečiama funkcija WriteLine esanti Console tipe. Tai yra standartinė CLI funkcija.
		•	}; pažymima funkcijos pabaiga ir užbaigiamas priskyrimo sakinys.


2.2. Tipai
	LaborasLang palaiko dviejų rūšių tipus: vertės tipus ir nuorodinius tipus. Vertės tipai, skiriasi nuo nuorodinių tipų tuo, kad jie 
	savyje laiko reikšmę. Nuorodiniai tipai laiko nuorodą į reikšmę. Dvi nuorodos gali rodyti į tą pačią reikšmę, o reiškia, kad 
	pakeitimai per vieną nuorodą gali atsirasti kitoje. Tai neįmanoma su vertės tipais, nes vertės tipo kintamieji turi savo reikšmės kopiją. Pavyzdžiui:

	use System;         
	use System.Runtime.InteropServices.ComTypes;
	use System.Text;

	entry auto MyFunction = void()
	{
	    FILETIME value;
	    value.dwLowDateTime = 15;

	    auto reference = StringBuilder("Laboras");

	    Console.WriteLine(value.dwLowDateTime);
	    Console.WriteLine(reference);

	    auto valueCopy = value;
	    valueCopy.dwLowDateTime = 20;

	    auto referenceCopy = reference;
	    referenceCopy.Append("Lang");

	    Console.WriteLine(value.dwLowDateTime);
	    Console.WriteLine(valueCopy.dwLowDateTime);

	    Console.WriteLine(reference);
	    Console.WriteLine(referenceCopy);
	};

	Ši programa atspausdina:
	15
	Laboras
	15
	20
	LaborasLang
	LaborasLang

	Visi palaikomi CLI tipai paveldi iš System.Object. Reikšmės tipai paveldi iš System.ValueType, kuris paveldi iš System.Object. 
	LaborasLang taip pat palaiko sąsajos tipus, kurių objektai gali būti vertės arba nuorodiniai tipai, priklausomai nuo realizacijos.

	2.2.1. Fundamentalieji tipai

		LaborasLang turi keletą fundamentaliųjų tipų, kurie atitinka fundamentaliuosius CLI tipus:

		Tipo vardas	     CLI tipo atitikmuo	     Pastabos
		bool	         System.Boolean	         Loginis tipas, galintis laikyti 2 reikšmes: true ir false.
		int8	         System.SByte	         1 baito dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-128; 127].
		uint8	         System.Byte	         1 baito dydžio sveikasis skaičius be ženklo, Galimos reikšmės: [0; 255].
		int16	         System.Int16	         2 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-32768; 32767].
		uint16	         System.UInt16	         2 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 65535].
		char	         System.Char	         2 baitų dydžio simbolio tipas.
		int32, int	     System.Int32	         4 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-2147483648; 2147483647].
		uint32, uint	 System.UInt32	         4 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 4294967295].
		int64, long	     System.Int64	         8 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės:  [–9,223,372,036,854,775,808; 9,223,372,036,854,775,807].
		uint64, ulong	 System.UInt64	         8 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 18,446,744,073,709,551,615].
		float	         System.Single	         4 baitų dydžio slankaus kablelio skaičius, atitinkantis IEC 60559:1989 standartą.
		double	         System.Double	         8 baitų dydžio slankaus kablelio skaičius, atitinkantis IEC 60559:1989 standartą.
		void	         System.Void	         Tipas neturintis reikšmės. Naudojamas pažymėti, jog funkcija negražina rezultato.
		object	         String.Object	         Objektas – fundamentaliausias tipas. Jis gali laikyti bet kurio kito tipo reikšmes.
		string	         System.String	         Simbolių eilutės tipas.

		Fundamentalieji tipai išskyrus void, object ir string yra taip pat vadinami primityviaisiai tipais. Jie yra naudojami atliekant 
		standartines operacijas ir sudaro kitus CLI tipus. 
		;;might be BS, bet kažkaip noriu parašyti kad yra primitives. paskui primitives naudoju apie castus rašydamas

		Fundamentaliųjų tipų vardai yra pseudonimai CLI tipams ir jie yra kompiliavimo metu verčiami į tikruosius tipus.
		Todėl:

		string foo;
		ir 
		System.String foo;

		yra sukompiliuojami į identišką kodą.

	2.2.2. Funkcijų tipai

		LaborasLang kalboje, funkcijų tipus apibrėžia funkcijos gražinamas tipas ir jos priimamų argumentų tipai. 
		Pilna funkcijos tipo sintaksė yra:

		<grąžinamas tipas>(<parametrų tipai atskirti kableliais>)

		Ir grąžinamas tipas, ir parametrų tipai gali būti bet kokie LaborasLang palaikomi tipai. Keletas funkcijų tipų pavydžių:

		void() – funkcija negrąžina rezultato ir nepriima jokių argumentų.

		void(int, double) - funkcija negrąžina jokio rezultato, ir priima du argumentus, kurių tipai yra int ir double.

		string(string, string()) - funkcija grąžina rezultatą, kurio tipas yra string, ir priima du argumentus, kurių tipai yra string ir 
		funkcija, kuri grąžina string tipo rezultatą.

		int[](System.Collections.IList) - funkcija grąžina masyvą, kurio elemento tipas yra int, ir priima vieną argumentą, kurio tipas 
		yra System.Collections.IList.

		void tipas gali būti naudojamas tik kaip funkcijos gražinamas tipas. C stiliaus sintaksė int(void), kurioje void parametrų sąraše 
		reikšdavo parametrų nebuvimą nėra leidžiama, tam yra naudojamas tuščias parametrų sąrašas.

		Kadangi funkcijos yra pirmos klasės nariai, funkcijos taip pat gali gražinti kitas funkcijas. Pavyzdys: 

		string()() - funkcija, kuri gražina string() tipo funkciją ir neima jokių argumentų.

		Funkcijų tipams yra naudojamos kompiliatoriaus generuotos klasės, kurių tiksli realizacija gali priklausyti nuo kompiliatoriaus. Taip 
		funkcijos gali be jokių papildomų išlygų tapti tipų sistemos dalimi.

		;; compiler spece reiktų parašyti tą tikslią realizaciją, tipo jei kas norės su laboraslang interopintis

		;; IMO, čia visai ne į temą. skyrius vadinasi Funkcijų tipai, o rašai apie calls, higer order functions ir panašius dalykus
		;; galima parašyti "daugiau apie funkcijas ir funkcijų tipus skyriuje Funkcijos"

		;; Aš manau, jog čia tam sakiniui apie implementacija tikrai ne vieta - T.

		Funkcija, kurią laiko funkcijos tipo kintamasis, yra iškviečiama šalia kintamojo parašant skliausteliuose argumentus, atskirtus kableliais. Pavyzdžiui:
		void(int, double) myVariable = someFunction;
		myVariable(3, 5.8);

		Funkcijų tipus galima naudoti perduodant funkcijas kaip argumentus kitoms funkcijoms: ;;Patogu - šališka nuomonė, nėra įrodymo kad patogu ar ne. A.
		int(int()) GetFunctionResultPlusOne = int(int() function)
		{
		    return function() + 1;
		};

		void() PrintSix = void()
		{
		    Console.WriteLine(GetFunctionResultPlusOne(int() { return 5; }));
		};

	2.2.3. Masyvų tipai

		LaborasLang palaiko masyvų kūrimą iš visų palaikomų tipų. Masyvo tipą sudaro elemento tipas ir matmenų skaičius, visi masyvai yra 
		indeksuojami nuo nulio. Tipų sistema nedengia masyvo matmenų ilgio, tik jų skaičių. Skaičius deklaruojamas kableliais tarp laužtinių 
		skliaustų. Gautas masyvas turės vienu matmeniu daugiau negu tipe yra kablelių. 

		Masyvo tipas yra nuorodos tipas, vieno matmens masyvai atitinka CLI vektoriaus specifikaciją, kelių matmenų masyvai (matricos) atitinka 
		CLI masyvo specifikaciją. Maksimalus masyvo matmenų skaičius yra 32. 

		<elemento tipas>[<matmenų skaičiaus deklaracija>]

		Pavyzdžiai:
		int[] //vienmatis int masyvas
		float[,] //dvimatis float masyvas
		System.Version[,,] // Trimatis versijų masyvas

		Taip pat, galima deklaruoti funkcijų masyvus.

		int(int)[]

		Arba masyvus sudarytus iš kitų masyvų (t.y. dantytus masyvus).

		int[][]

		Kadangi dantytą masyvą sudaro tik nuorodos į kitus masyvus, tokio masyvo matmenų ilgis yra neribojamas. Maksimalus įmanomas matmenų 
		skaičius priklauso nuo kompiliatoriaus realizacijos, taip pat nuo veikimo aplinkos (kompiliatoriaus ir gautos programos).

	2.2.4. Tipų keitimas

		LaborasLang tipų sistema nėra griežta, norint galima keisti reikšmių tipus, bet kompiliatorius užtikrina keitimo korektiškumą jei 
		tai yra įmanoma. Kadangi korektiškumą garantuoti yra įmanoma tik labai retais atvejais ir naudojant sudėtingą statinę analizę, 
		kompiliatorius leidžia tik akivaizdžiai teisingus keitimus.

		Tipo keitimas yra reikalingas keliose situacijose. Pirma, yra daug sveikųjų skaičių tipų, kurie visi laiko tą pačią informaciją 
		panašiu formatu. Taip galima pasirinkti geriausią tipą, bet gali reikėti keitimų perduodant duomenis. Antra, objektinis programavimas 
		reikalauja keitimų. Su keitimais objektų tipai neturi atitikti kintamųjų tipų, užtenka, kad paveldėtų jų tipus. 

		Yra naudojami du keitimų tipai: automatinis keitimas ir nurodomasis keitimas.

		2.2.4.1 Automatinis tipo keitimas

			Kai kuriais atvejais nesutampa reikšmės tipas ir reikalaujamas tipas, bet kompiliatorius gali nustatyti, kad keitimas galimas. Keitimo pagrindinės taisyklės:
			•	Jei tipai vienodi, keitimas nereikalingas. 
			•	Jei tai primityvūs tipai, ar norimas tipas gali įgyti visas keičiamo tipo reikšmes.
			•	Jei tai yra funkcijų tipai, ar sutampa parametrų skaičius? Ar reikšmės parametrus galima automatiškai keisti į norimo tipo parametrus?
			•	Jei tai masyvų tipai, ar sutampa matmenų skaičius? Ar reikšmės elemento tipą galima keisti į norimo tipo elementą?
			•	Ar reikšmės tipas paveldi iš norimo tipo?
			Jei netenkinama nei viena šių taisyklių, keitimas neleidžiamas ir rodoma klaida.
			Keičiant primityvius tipus, naudojama galimų keitimų lentelė.

			;;čia mano papaišyta nuostabi lentelė "assignment map.jpg"

			Šios taisyklės yra tranzityvios, t.y. jei uint8 galima keisti į int16, o int16 į int32, leidžiama ir uint8 keitimas į int32. 
			Vienintelė išlyga reikalavimui dėl korektiškumo yra sveikųjų skaičių keitimas į realiuosius, nors tai gali neduodi tikslių 
			rezultatų artėjant prie kraštutinių reikšmių, dėl paprastumo šis keitimas leidžiamas.

		2.2.4.2 Nurodomasis tipo keitimas

			Jeigu statiškai neįmanoma įrodyti keitimo korektiškumo, bet vartotojas žino, jog jis bus teisingas, galimas nurodomasis keitimas. 
			Šiame keitime vartotojas nurodo tipą į kurį nori keisti. Kompiliatorius draudžia tik tuos nurodomuosius keitimus, kurie yra garantuotai neteisingi. 
			Turi būti patenkinta viena iš sąlygų:
			•	Vienas iš tipų gali būti automatiškai keičiamas kitu;
			•	Abu tipai yra primityvūs ir nei vienas jų nėra bool.

	2.2.5 Null reikšmės tipas

		null yra išskirtinė reikšmė tuo, kad ji neturi tipo. Ją gali įgyti bet koks nuorodinio tipo kintamasis.

	2.2.6 Automatinis tipo radimas

		LaborasLang palaiko ribotą automatinį tipų radimą. Deklaruojant kintamuosius galima nurodyti auto tipą. Tokioje deklaracijoje tipas 
		bus randamas automatiškai, bet kintamąjį būtina inicializuoti. Kompiliavimo metu kintamojo tipas nustatomas toks pat kaip inicializatoriaus. Pavyzdys:

		auto str = "text";

		ir

		string str = "text";

		Abi deklaracijos sukompiliuojamos į identišką kodą.

	2.3. Kintamieji

		LaborasLang palaiko trijų tipų kintamuosius: lokalius kintamuosius, globalius kintamuosius ir funkcijų parametrus. Pagrindiniai 
		kintamųjų panaudojimo skirtumai yra jų galiojimo sritis.
		;; kiti skirtumai yra kur alokuojama, kada dealokuojama, gal šitą kada reikės parašyti

		2.3.1. Lokalūs kintamieji

			Lokalūs kintamieji yra kintamieji deklaruoti funkcijos viduje. Šių kintamųjų galiojimo sritis yra kodo blokas, kuriame jie buvo 
			deklaruoti, su keliomis išlygomis. Kintamieji pradeda galioti nuo jų deklaracijos ir baigia uždarant jų bloką. Jeigu kintamojo 
			galiojimo srityje yra deklaruota funkcija, iš šios funkcijos galima pasiekti kintamąjį, bet tik kaip skaitomą reikšmę.

		2.3.2. Globalūs kintamieji

			Deklaruojant kintamajį tiesiogiai faile, bus sukuriamas globalus kintamasis. Tokio kintamojo galiojimo sritis yra visas failas, 
			juo galima naudotis anksčiau negu jis yra deklaruotas. Kintamajį, priklausomai nuo deklaracijos, taip pat galima pasiekti iš 
			kitų failų. Plačiau apie tai skyriuje "Atributai".

		2.3.3. Funkcijų parametrai

			Funkcijos deklaraciją sudaro jos parametrai. Šie parametrai yra kintamieji, kurie įgis funkcijai perduotų argumentų reikšmes. 
			Parametrų galiojimo sritis yra visas funkcijos blokas, bet jų panaudojimas nesiskiria nuo lokalių kintamųjų.

	2.4. Išraiškos
		2.4.1. Literalai ;;include null
		2.4.2. Simboliai
		2.4.2. Indeksavimas
		2.4.3. Funkcijos
		2.4.4. Funkcijos kvietimai
		2.4.5. Priskyrimo operacija
		2.4.6. Vienanarės operacijos
			;;2.4.6.1. Aritmeninės operacijos
			;;2.4.6.2. Loginės operacijos
			;;2.4.6.3. Bitinės operacijos
			;;Joined
		2.4.7. Dvinarės operacijos
			2.4.7.1. Aritmetinės operacijos
			2.4.7.2. Loginės operacijos
			2.4.7.3. Bitinės operacijos
			2.4.7.4. Stūmimo operacijos
		2.4.8. Objektų kūrimas
		2.4.9. Masyvų kūrimas
		2.4.10. Klasių nariai
	2.5. Teiginiai

		;; kaip parašyti kas yra teiginys - D?

		2.5.1 Deklaracija

			;; Šitas skyrius labai išsipūtė, gal ką praleidau - D.

			Deklaracijos teiginys yra naudojamas deklaruojant kintamajį.

			<atributai> <tipas> <identifikatorius>;
			<atributai> <tipas> <identifikatorius> = <inicializatorius>;

			Atributai yra sąrašas atributų atskirtų tarpais, palaikomi atributai priklauso nuo kintamojo tipo. Atributus galima praleisti.

			Tipas yra bet koks palaikomas tipas išskyrus "void".

			Identifikatorius yra bet koks legalus simbolis. ;; reiktų kokio link į lexer skyriu kas yra legalus simbolis - D.

			Inicialiatorius yra bet kokia skaitoma išraška.

			Pavyzdžiai:

			int a; // "int" tipo kintamasis be inicializacijos
			float b = 5; // "float" tipo kintamasis su inicializacija
			string str = null; // teksto eilutė inicializuojama "null" reikšme.

			int(int) incrementer = int(int num)
			{
				return num + 1;
			};
			// funkcijos kintamasis su inicializacija

			Verta atkreipti dėmesį, jog po funkcijos bloko uždarymo yra ";". Funkcijos deklracija nėra kontrolės blokas ir jis, kaip visi 
			įprasti teiginiai yra baigiamas ";".
			;; pats šitą klaidą padariau ne kartą - D.

			Inicializuojant deklaraciją, jos tipą galima nustatyti "auto". Tada kintamojo tipas bus toks pat kaip inicializatoriaus išraiškos. 

			auto numbers = int[5];
			auto sudoku = void() { sudoku(); };	
			;; Ar pažiūrėjai, kad buildintųsi? Aš galvojau toks capture neveikia.
			;; yes, jei tai global var. O jei ir ne, šitas spece tinka, nes pagal spec veikia capture - D.

			;; čia dubliuojasi su skyriumi Automatinis tipo radimas, galvosiu kaip keisti - D.
			Deklaruojant "auto" tipą taikomi du apribojimai:
			* Deklaracija privalo būti inicializuota.
			* Inicializatorius negali būti "null", kadangi "null" neturi tipo.

			Jei nesilaikoma vieno iš šių apribojimų, kintamojo tipo nustatyti neįmanoma ir yra gražinama klaida.

			auto foo; // klaida
			auto bar = null; // klaida

			Norint papildomai apriboti kintamuosius, deklaracijoje galima jiems pridėti atributus. LaborasLang turi dvi atributų rūšis - 
			pasiekiamumo ir kintamumo. Pasiekiamumo atributai apriboja kintamojo galiojimo sritį, o kitamumo leidžia kintamajį padaryti 
			konstanta. Deklaracijoje galima pridėti po vieną kiekvienos rūšies atributą. Nepridėjus atributo rūšies bus nustatoma 
			standartinis atributas, kuris priklauso nuo deklracijos.

			2.5.1.1 Kintatumo atributai

				Yra du priešingi kintamumo atributai: const ir mutable. const padaro kintamajį konstanta, o mutable atvirkščiai - pažymi, 
				jog kintamajo reikšmė gali kisti. Konstantoms negalima priskirti reikšmės ir jas būtina inicializuoti. 

				const int a = 5;
				a = 6; // klaida, a reikšmę galima tik skaityti

				mutable int b = 7;
				b = 8; // reikšmę galima ir skaityti ir rašyti

				const int c; // klaida, konstantas būtina inicializuoti

				Standartinis atributas yra mutable, išskrus vieną atvejį. Globalūs funkcijų tipo kintamieji yra deklaruojami su const atributu. Tokia 
				taisyklė leidžia funkcijų perdengimą ir kelias optimizacijas. Norint gauti globalų funkcijos kintamajį, kuris nėra konstanta, 
				būtina deklarauotį jį su mutable atributu. 

				void() foo; // klaida, jei tai globalus kintamasis

				mutable void() foo; // šis kodas veikia

				Kintamumo atributai yra palaikomi lokalių ir globalių kintamųjų. 
				;; Koks tas atvejis kai kintamasis yra ne mutable by default? A.
				;; global functors, nes tada kompiliuojam į metodus. greičiau veikia ir galima naudoti overloading - D.

				
			2.5.1.2 Pasiekiamumo atributai

				Pasiekiamumo atributai naudojami apriboti globalių kintamųjų galiojimo sritį. Yra du pasiekiamumo atributai - private ir public. 
				private kintamieji yra pasiekiami tik iš failo kuriame yra deklaruoti, public kintamieji yra pasiekiami iš bet kurio failo. 
				Standartinis atributas yra private. 

				public auto foo = 5;
				private auto bar = 6;

				Pasiekiamumo atributai leidžiami tik globaliems kintamiesiems.

			Atributus galima kombinuoti. 

			public const int MAX_COUNT = 200;

			Bet deklaracijoje gali būti tik po vieną atributą iš kiekvieno tipo.

			public private int a; // klaida
			public public int b; // kompiliatoriui nereikia kartoti dalykų

		2.5.2 Vardų grupės importavimo ;; Gal kas geriau sugalvosit - D.

			Importavimo teiginys naudojamas į failo galiojimo sritį įterptį vardų grupes ir tipus iš kitos vardų grupės.

			use <vardų grupė>;

			Vardų grupė privalo būti pilna vardų grupė iš naudojamų asemblių.

			Po šio teiginio galima visus tipus ir vardų grupes iš nurodytos vardų grupės pasiekti tiesiogiai, nerašant pačios grupės.

			use System;

			String a;
			Collections.ArrayList lst;

			yra analogiška

			System.String a;
			System.Collections.ArrayList lst;

			Importavimo teiginiai leidžiami tik faile. ;; Kaip kitaip parašyti - D?
			Faile gali būti neribotas skaičius importavimo teiginių.

			Nors teiginys importuoja ir vardų grupes, importavimo teiginyje privaloma rašyti pilną vardų grupę, net jei ji pasiekiama trumpiau per kitą teiginį.

			use System;
			use Collections; // klaida, nėra tokios vardų grupės
			use System.Collections; // Toks teiginys veikia

			Kompiliavimo metu importuoti tipai keičiami pilnais tipų vardais. Importavimas, kaip ir tipų pseudonimai, yra pagalbinė kompiliatoriaus funkcija. 
			Šių sakinių naudojimas visiškai neįtakoja gaunamo kodo veikimo.


		2.5.3 return
		2.5.4 Tuščias teiginys

			Tuščią teiginį sudaro tik kabliataškis. Toks teiginys nedaro nieko ir gali būti naudojamas ten, kur sintaksė reikalauja teiginio, 
			bet nenorite nieko dėti.

		2.5.5 Išraiškos teiginys

			<išraiška>;

			Bet kokia išraiška taip pat gali būti panaudota kaip teiginys. Tokia išraiška bus įvykdyta ir jos gražinama reikšmė atmesta.

	2.6. Kontrolės blokai

		Kontrolės blokai yra teiginiai naudojami valdyti programos vykdymo seką. 

		2.6.1. Kodo blokas

			LaborasLang kodo blokai sudaromi iš atidarančių kabučių, sąrašo teiginių ir uždarančių kabučių.

			{
				<teiginių sąrašas>
			}

			Blokas leidžia įrašyti kelis teiginius, kur sintaksė palaiko tik vieną. Vykdant kodo bloką, jame esantys teiginiai yra vykdomi paeiliui.

			Kodo bloke deklaruoti kintamieji galioja tik iki blogo galo, todėl blokai taip pat naudojami norint apriboti kintamojo galiojimo sirtį.

			Pavizdys:

			{
				int a = 5;
				a++;
			}

			Kintamasis a galioja iki bloko pabaigos, bandymai jį naduoti vėliau gražins klaidą (nebent yra kitų kintamųjų vardu a).

			{
				int b = 5;
				{
					int a = b;
					b++;
				}

				Console.WriteLine(b);// išspausdintų 6
				Console.WriteLine(a);// bet yra klaida, kintamasis a čia neegzistuoja
			}

			Bloke kintamieji negali turėti to pačio vardo.

			{
				int a = 5;
				float a = 0.0; // klaida, kintamasis "a" jau deklaruotas
			}

			Tačiau, vardas gali būti vėl panaudojamas gilesniame bloke.

			{
				int a = 5;
				{
					Console.WriteLine(a);
					int a = 16;
					Console.WriteLine(a);
				}
				Console.WriteLine(a);
			}

			Ši programa išspausdins

			5
			16
			5

			Blokas gali būti tuščias. Toks blokas daro tą patį ką tuščias teiginys - visiškai nieko.

		2.6.2. Sąlygos sakiniai
		2.6.3. Ciklai

			LaborasLang programavimo kalba palaiko trijų tipų ciklus: "while" tipo ciklą ir du "for" tipo ciklus.	
			;; Worde pakeisti kabutes į keyword style

			2.6.3.1. while ciklas
				
				while ciklas susideda iš dviejų dalių: ciklo sąlygos ir ciklo teiginio. Ciklas yra vykdomas tol, kol ciklo sąlyga 
				yra teisinga. Bendrą ciklo struktūrą galima aprašyti taip:

				while (<sąlyga>)
				    <teiginys>

				Ciklo teiginys yra bet koks LaborasLang kalboje legalus teiginys (kodo blokas, sąlyga, ciklas ir t.t.).

				Sąlyga yra bet kokia "bool" tipo skaitoma išraiška.
				
				Keletas while ciklo pavyzdžių:

				while (foo-- > 0)
				    Report(foo);

				while (IsValid(bar))
				{
					if (bar % 2 == 0)
						Console.WriteLine(bar);

					bar = Transform(bar);
				}

			2.6.3.2. C stiliaus for ciklas

				;; Mes teiginiais vadinam use, deklaciją, return, visokie ciklai yra kontrolės blokai. Reikia suvienodinti semantiką ir pataisyti taisyklę - D.

				LaborasLang kalba palaiko C stiliaus for ciklą - jis analogiškas C ciklui ir yra palaikomas daugumos C šeimos kalbų. 
				Šį for ciklą sudaro kelios dalys: ciklo inicializatorius, ciklo sąlyga, ciklo iteratorius ir ciklo teiginys. C stiliaus 
				for ciklo struktūra yra tokia: ;; nepasiskolinom o atėmėm A.

				for (<inicializatorius>; <sąlyga>; <iteratorius>)
					<teiginys>

				Kiekviena iš šio for ciklo atraštės dalių gali būti praleista.

				Ciklo inicializatorius, jei toks yra, privalo būti kintamojo deklaracija arba bet kokia LaborasLang išraiška. 
				Deklaracija gali būti su inicializacija arba be. Ši deklaracija sukuria lokalų kintamajį, kurio galiojimo sritis apima visą 
				ciklą.

				Ciklo sąlyga, jei tokia yra, privalo būti "bool" tipo skaitoma išraiška. Jei sąlygos nėra, ji pakeičiama išraiška "true".

				Ciklo iteratorius, jei toks yra, gali būti bet kokia išraiška.

				Ciklo teiginys yra bet koks LaborasLang teiginys, išskyrus "use" teiginį.

				Ciklo vykdymo tvaka:

					1. Jei aprašytas, įvykdomas ciklo inicializatorius.
					2. Įvykdoma ciklo sąlyga. Jei rezultatas nėra "true", baigiamas ciklo vykdymas.
					3. Įvykdomas ciklo teiginys. 
					4. Jei nebuvo išeita iš teiginio (pavyzdžiui "return" sakiniu) ir yra aprašytas iteratorius, jis yra įvykdomas.
						Vykdymas gražinamas į 2 punktą.

				;; Man šitas padeda suvokti kaip tiksliai vykdomas for - D.
				Naudojant "while" ciklą, "for" galima aprašyti taip:

				{
					<inicializatorius>;
					while (<sąlyga>)
					{
						<teiginys>;
						<iteratorius>;
					}
				}

				For ciklo pavyzdžiai:

				// Šis for ciklas spausdina "Spinning infinitely" be galo.
				for (;;)
				    Console.WriteLine("Spinning infinitely");


				// Šis for ciklas atspausdina skaičius nuo 0 iki 9 imtinai.
				for (int i = 0; i < 10; i++)
				    Console.WriteLine(i);


				// Šis ciklas analogiškas while ciklui
				for(;i < 10;)
				{
					Console.WriteLine(i);
					i++;
				}


			2.6.3.3. Kolekcijos iteravimo for ciklas

				Iteravimui per reikšmių kolekcijas dažnai naudojamas specialus ciklas, kitose kalbose vadinamas "foreach" ciklu. Šiame 
				cikle yra deklaruojamas kintamasis, kuris paeiliui įgyja visas rinkinio reikšmes. 

				for(<kintamojo tipas> <kintamojo pavadinimas> in <kolekcija>)
					<teiginys>

				Pagal kintamojo tipą ir pavadinimą yra deklaruojamas lokalus kintamasis. Šio kintamojo galiojimo sritis yra visas ciklas, 
				bet jo reikšmę galima tik perskaityti. Šis ciklas netinka, jei reikia modifikuoti kolekciją.

				Kolekcijos gali būti masyvai arba objektai turintys metodą GetEnumerator(). Kolekcijos išraiška bus įvykdyta vieną kartą 
				ir viso ciklo metu bus naudojamas tas pats enumeratorius. 
				;; čia gal tik biški BS.
				;; norėjau parašyti, kad jei iteruosi per call, nebus kviečiama 500 kartų - D.

				Kadangi iš kolekcijos visada galima sužinoti elemento tipą, dažnai deklracijoje naudojamas tipas "auto".

				Ciklo pavyzdžiai:

				// iteruojama per masyvą
				auto arr = int[] { 1, 2, 3, 4 };
				for (auto i in arr)
					Console.WriteLine(i);
				// išspausdins skaičius 1 - 4

				// iterauojama per kolekciją
				ArrayList lst = ...
				for (object i in lst)
					Console.WriteLine(i.ToString());
				// išspausdinami kolekcijos objektų tekstinės reprezentacijos ;; gal geresnis žodis tam yra - D.

3. LaborasLang gramatika
	3.1. Programos apibrėžimas
		Programa yra vienas ar daugiau išeities kodo failų.
	3.2. Dviprasmybės
		LaborasLang gramatikoje dviprasmybės yra gailimos tik sudarant žetonus. Jos yra sprendžiamos sudarant maksimalaus galimio ilgio
		žetonus. Tai yra taikoma valdant tokius žetonus kaip "<<", "++", "--", tai reiška kad nors teiginys "i = i--1" galėtų būti 
		transformuotas į "i = i - (-1)" dėl žetonų ilgio maksimizavimo jis bus suprastas kaip "i = (i--) 1", kas yra nevalidus kodas (
		nėra jokio operatoriaus tarp dviejų operandų).
	3.3. Leksinė gramatika
		3.3.x. Programa leksiniu požiūriu
			Išeities kodo failus sudaro matomieji ir nematomieji tarpai (whitespace), žetonai, komentarai.
			* Nematomieji tarpai yra tarpo, įtraukos, eilutės pabaigos bei kiti panašūs simboliai, kompiliavimo metu jie yra ignoruojami.
			* Komentarai atitinka C šeimos kalbų komentarus, tai yra galimi vienos eilutės komentarai kurie yra pradedami simboliais "//" bei
			tęsiami iki eilutės pabaigos simbolio ir bloko tipo komentarai pradedami "/*" simboliu ir baigiami "*/" simboliu. Komentarų
			turinys kompiliavimo metu yra ignoruojamas
			* Žetonai yra gaunami sujungiant gretimus simbolius į prasmingas maksimalaus ilgio leksemas, kurios yra toliau analizuojamos
			kompiliuojant programą. Žetonai yra tokie simboliai kaip
			"*", "+", "=", ";" bei ilgesni dariniai - "auto", "penki", "+=", "while" bei kiti. Žetonai naudojami sudaryti kalbos
			struktūras, kurios savo ruožtu sudaro programą.

			Programa leksiniu požiūriu yra kalbos struktūrų rinkinys. Galimos kalbos struktūros yra kodo blokas, ciklas, sąlygos sakinys,
			sakinys.
		3.3.X Kalbos struktūros
			3.3.x.x Sakinys
				Sakinys yra pagrindinė kalbos struktūra kuri nusako tam tikrą veiksmą. Ši kalbos struktūra yra grupė mažesnių struktūrų kurios turi tam tikras formavimo taisykles:
				"Use" sakinys
				Deklaravimo sakinys
				Reikšmės sakinys
				Grąžinimo sakinys.
				3.3.x.x.x. Sakinių leksinė sandara
					Use sakinys
					PEG tipo gramatika:
					UseNode:
						Use Symbol (Period Symbol)* EndOfLine

					Šį sakinį sudaro dvi dalys: Raktažodis "Use", tekstinis simbolis, nulis ar daigiau taško ir tekstinio simoblio grupių 
					bei eilutės pabaigos simbolis - kabliataškis.
					"Use" sakinio pavyzdys:
						use Foo.Bar;
					čia use yra "Use" taisykės dalį atitinkantis raktažodis, Foo atitinka pirmąjį simbolį, taško simbolis bei "Bar" yra
					vienas pasikartojimas "Period" bei "Symbol" grupės o ";" yra "EndOfLine" reiškiantis simbolis. 
				
			3.3.x.x Kodo blokas			
			3.3.x.x Sąlygos sakinys
			3.3.x.x Ciklas


		3.3.1. Komentarai
		3.3.2. Raktiniai žodžiai
		3.3.3. Terminaliniai žetonai
	3.3. Sintaksinė gramatika
4. LaborasLang programų pavyzdžiai
5. Pavyzdinis kompiliatorius
	5.1. Komponentai
		5.1.1. Lekseris
		5.1.2. Parseris
		5.1.3. Kodo generatorius
	5.2. Testavimas
		5.2.1. Lekserio testavimas
		5.2.2. Parserio testavimas
		5.2.3. Kodo generatorius testavimas
			5.2.3.1. CIL kodo palyginimu grįsti testai
			5.2.3.2. Vykdymu grįsti testai
		5.2.4 Kontraktai/statinė analizė
	5.3. Vartotojo dokumentacija
		5.3.1. Išvesties tipai
		5.3.2. Bibliotekų nuorodos
		5.3.3. Šakninės direktorijos
6. Išvados
7. Literatūra
