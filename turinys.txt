Programavimo kalba „LaborasLang“
Bakalauro baigiamasis darbas


Techininė užduotis
Autentiškumo patvirtinimas
Santrauka
Summary
Lentelių sąrašas
Paveikslų sąrašas
Terminų ir santrumpų žodynas

	Asemblis – failas, kuris yra LaborasLang programos kompiliavimo rezultatas. 
	CIL (Common Intermediate Language) – kalba, kurią supranta ir geba vykdyti CLI implementacijų vykdymo aplinkos.
	CLI (Common Language Infrastructure) – tai specifikacija, aprašanti virtualią vykdymo aplinką ir CIL kodą. CLI yra specifikuota ECMA-335 tarptautiniame standarte. Dvi populiariausios CLI implementacijos yra CLR (.NET karkaso dalis) ir Mono Runtime.
	LaborasLang programa – vienas ar daugiau išeities kodo failų, kurie nurodomi LaborasLang kompiliatoriui kaip duomenys. 
	Įeities taškas (entry point) – speciali funkcija, kuri yra iškviečiama paleidus aplikaciją.
	Išraiška (expression) – kodo fragmentas, kurį įvykdžius galima gauti reikšmę, arba jam nustatyti reikšmę.
	Skaitoma išraiška (gettable expression, rvalue) – išraiška, kuri garantuotai grąžina reikšmę.
	Rašoma išraiška (settable expression, lvalue) – išraiška, kuriai galima nustatyti reikšmę.
	Lokalus kintamasis (local variable) – kintamasis deklaruotas funkcijoje.
	Globalus kintamasis (global variable) – kintamasis deklaruotas faile.
	Galiojimo sritis (scope) – taisyklės nusakančios kintamųjų pasiekiamumą.
	Sąveika (interoperability) – sistemos galimybė bendrauti su kitomis sistemomis. Kalbos kontekste tai yra galimybė naudoti resursus sukurtus kitomis kalbomis, taip pat kitose kalbose naudoti LaborasLang resursus.
	Blokas, kodo blokas – Kodo fragmentas apribotas simboliais „{“ ir „}“.
	Literalas (literal) – Kode įrašyta reikšmė.
	Vertės tipas (value type) – tipas, kurio kintamasis laiko reikšmę.
	Nuorodos tipas (reference type) – tipas, kurio kintamasis laiko nuorodą į reikšmę.
	Daugybinis tipas (generic type) – tipas turintis kelis daugybinius parametrus, galintis aprašyti kelis skirtigus tipus.
	Tipo pseudonimas (type alias) – papildomas vardas skiriamas tipui.
	Dantytas masyvas (jagged array) – masyvas sudarytas iš kitų masyvų.
	Automatinis tipo keitimas (implicit cast) – reikšmės tipas pagal poreikį keičiamas be vartotojo reikalavimo.
	Nurodomasis tipo keitimas (explicit cast) – reikšmės tipas keičiamas, nes taip nurodė vartotojas.
	Funkcijos parametras (function parameter) - funkcijos deklaruojamas kintamasis, kuris įgyja funkcijos argumento reikšmę. ;;geriau nemoku parašyti, bet niekas nežino kuo arg nuo param skirias
	Funkcijos argumentas (function argument) - reikšmė paduodama funkcijai.
	Vardų grupė (namespace) - ;; dunno, lol - D.
	PEG - parsing expression grammar ;; jei ką čia žemaitiškai o ne angliškai - A.


Įvadas

	Ši specifikacija aprašo programavimo kalbą, pavadinimu „LaborasLang“. LaborasLang kalbos autoriai yra Andrius Dapševičius, Darius Lapūnas ir Tautvydas Žilys. 
	Pagrindiniai tikslai, keliami LaborasLang, yra:
	•	Esamiems programuotojams pažįstama sintaksė. Yra siekiama, kad programuotojai,  pažystami su bet kuria programavimo kalba, kurios sintaksė yra kilusi iš C kalbų šeimos, galėtų greitai išmokti programuoti su LaborasLang.
	•	Statinė tipų sistema. LaborasLang kompiliatorius turi sugebėti statiškai patikrinti tipų naudojimą.
	•	Funkcijos – pirmos klasės nariai. LaborasLang programavimo kalboje, funkcijas galima naudoti lygiai taip pat, kaip ir bet kurį kitą duomenų tipą.
	•	Paprastumas. Vienas iš LaborasLang uždavinių – būti kuo įmanoma paprastesnei.
	•	Vykdymo greitis. LaborasLang kalba parašytos programos turi galėti efektyviai išnaudoti kompiuterio resursus. ;;Ar čia kalbos ar implementacijos dalis? A.
	•	Sąveika su kitomis programavimo kalbomis. LaborasLang kalba parašytos programos turi galėti naudotis bibliotekomis, kurios yra parašytos kitomis .NET programavimo kalbomis. Dėl šios priežasties, LaborasLang programos yra kompiliuojamos į CIL. Taip pat bibliotekos parašytos LaborasLang turi veikti kitose .NET kalbose.


1. Apimtis ;;siūlau Specifikacijos apimtis A.

	Ši specifikacija apibrėžia LaborasLang programavimo kalbą. Tai apima:
	•	LaborasLang kalbos leksinę ir sintaksinę gramatiką;
	•	LaborasLang kalbos semantiką;
	•	LaborasLang kalbos apribojimus.
	Kartu su specifikacija pateikiamas pavyzdinio LaborasLang kalbos kompiliatoriaus aprašas.

2. LaborasLang apžvalga
	LaborasLang yra statiškai tipuojama, procedūrinė, kompiliuojama, bendros paskirties programavimo kalba, turinti funkcinio programavimo elementų. Šis skyrius aprašo pagrindines LaborasLang kalbos savybes.

	2.1. Pirmoji LaborasLang programa

		Pavyzdinė „Hello, world“ programa LaborasLang kalboje gali būti užrašoma taip:

		use System;         

		entry auto HelloWorld = void()
		{
		    Console.WriteLine("Hello, world!");
		};

		Išnagrinėkime šią programą po eilutę:
		•	Sakinys  use System; nurodo, jog šiame faile tipai ir vardų grupės iš System vardų grupės bus tiesiogiai pasiekiami.
		•	entry auto HelloWorld = void() šioje eilutėje yra deklaruojamas kintamasis HelloWorld. Šiam kintamajam yra priskiriama funkcija, kurios tipas – void(). Kadangi kintamojo deklaravimo metu jam yra priskiriama reikšmė, tai jo tipą galima nustatyti automatiškai – tai nurodo specialus tipas auto. Raktinis žodis entry nurodo, jog šis kintamasis yra programos įeities taškas.
		•	{ pažymima funkcijos pradžia.
		•	Console.WriteLine("Hello, world!"); iškviečiama funkcija WriteLine esanti Console tipe. Tai yra standartinė CLI funkcija.
		•	}; pažymima funkcijos pabaiga ir užbaigiamas priskyrimo sakinys.


2.2. Tipai

	LaborasLang palaiko dviejų rūšių tipus: vertės tipus ir nuorodinius tipus. Vertės tipai, skiriasi nuo nuorodinių tipų tuo, kad jie 
	savyje laiko reikšmę. Nuorodiniai tipai laiko nuorodą į reikšmę. Dvi nuorodos gali rodyti į tą pačią reikšmę, o reiškia, kad 
	pakeitimai per vieną nuorodą gali atsirasti kitoje. Tai neįmanoma su vertės tipais, nes vertės tipo kintamieji turi savo reikšmės kopiją. Pavyzdžiui:

	use System;         
	use System.Runtime.InteropServices.ComTypes;
	use System.Text;

	entry auto MyFunction = void()
	{
	    FILETIME value;
	    value.dwLowDateTime = 15;

	    auto reference = StringBuilder("Laboras");

	    Console.WriteLine(value.dwLowDateTime);
	    Console.WriteLine(reference);

	    auto valueCopy = value;
	    valueCopy.dwLowDateTime = 20;

	    auto referenceCopy = reference;
	    referenceCopy.Append("Lang");

	    Console.WriteLine(value.dwLowDateTime);
	    Console.WriteLine(valueCopy.dwLowDateTime);

	    Console.WriteLine(reference);
	    Console.WriteLine(referenceCopy);
	};

	Ši programa atspausdina:
	15
	Laboras
	15
	20
	LaborasLang
	LaborasLang

	Visi palaikomi CLI tipai paveldi iš System.Object. Reikšmės tipai paveldi iš System.ValueType, kuris paveldi iš System.Object. 
	LaborasLang taip pat palaiko sąsajos tipus, kurių objektai gali būti vertės arba nuorodiniai tipai, priklausomai nuo realizacijos.

	2.2.1. Fundamentalieji tipai

		LaborasLang turi keletą fundamentaliųjų tipų, kurie atitinka fundamentaliuosius CLI tipus:

		Tipo vardas	     CLI tipo atitikmuo	     Pastabos
		bool	         System.Boolean	         Loginis tipas, galintis laikyti 2 reikšmes: true ir false.
		int8	         System.SByte	         1 baito dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-128; 127].
		uint8	         System.Byte	         1 baito dydžio sveikasis skaičius be ženklo, Galimos reikšmės: [0; 255].
		int16	         System.Int16	         2 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-32768; 32767].
		uint16	         System.UInt16	         2 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 65535].
		char	         System.Char	         2 baitų dydžio simbolio tipas.
		int32, int	     System.Int32	         4 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-2147483648; 2147483647].
		uint32, uint	 System.UInt32	         4 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 4294967295].
		int64, long	     System.Int64	         8 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės:  [–9,223,372,036,854,775,808; 9,223,372,036,854,775,807].
		uint64, ulong	 System.UInt64	         8 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 18,446,744,073,709,551,615].
		float	         System.Single	         4 baitų dydžio slankaus kablelio skaičius, atitinkantis IEC 60559:1989 standartą.
		double	         System.Double	         8 baitų dydžio slankaus kablelio skaičius, atitinkantis IEC 60559:1989 standartą.
		void	         System.Void	         Tipas neturintis reikšmės. Naudojamas pažymėti, jog funkcija negražina rezultato.
		object	         String.Object	         Objektas – fundamentaliausias tipas. Jis gali laikyti bet kurio kito tipo reikšmes.
		string	         System.String	         Simbolių eilutės tipas.

		Fundamentalieji tipai išskyrus void, object ir string yra taip pat vadinami primityviaisiai tipais. Jie yra naudojami atliekant 
		standartines operacijas ir sudaro kitus CLI tipus. 
		;;might be BS, bet kažkaip noriu parašyti kad yra primitives. paskui primitives naudoju apie castus rašydamas

		Fundamentaliųjų tipų vardai yra pseudonimai CLI tipams ir jie yra kompiliavimo metu verčiami į tikruosius tipus.
		Todėl:

		string foo;
		ir 
		System.String foo;

		yra sukompiliuojami į identišką kodą.

	2.2.2 Vardų erdvė ir pilnas vardas

		Tipo pilnas vardas yra sudaromas iš jo vardų grupės ir vardo atskirtu tašku. Pavyzdžiai:

			Pilnas vardas                  Vardų grupė          Vardas
			System.Collections.ArrayList   System.Collections   ArrayList
			System.String                  System               String
			System.IO.File                 System.IO            File

		Vardų grupės turi dvi funkcijas: suskirstyti tipus pagal paskirtį ir leisti keliem tipam turėti tą patį vardą. Kadangi 
		tipo identifikatorius yra jo pilnas vardas, keli tipai gali turėti tą patį vardą, kol jų vardų grupės skiriasi. Sakoma, 
		kad tipas String priklauso vardų grupei System. Taip pat vardų grupė Collections priklauso vardų grupei System.

	2.2.2. Funkcijų tipai

		LaborasLang kalboje, funkcijų tipus apibrėžia funkcijos gražinamas tipas ir jos priimamų argumentų tipai. 
		Pilna funkcijos tipo sintaksė yra:

		<grąžinamas tipas>(<parametrų tipai atskirti kableliais>)

		Ir grąžinamas tipas, ir parametrų tipai gali būti bet kokie LaborasLang palaikomi tipai. Keletas funkcijų tipų pavydžių:

		void() – funkcija negrąžina rezultato ir nepriima jokių argumentų.

		void(int, double) - funkcija negrąžina jokio rezultato, ir priima du argumentus, kurių tipai yra int ir double.

		string(string, string()) - funkcija grąžina rezultatą, kurio tipas yra string, ir priima du argumentus, kurių tipai yra string ir 
		funkcija, kuri grąžina string tipo rezultatą.

		int[](System.Collections.IList) - funkcija grąžina masyvą, kurio elemento tipas yra int, ir priima vieną argumentą, kurio tipas 
		yra System.Collections.IList.

		void tipas gali būti naudojamas tik kaip funkcijos gražinamas tipas. C stiliaus sintaksė int(void), kurioje void parametrų sąraše 
		reikšdavo parametrų nebuvimą nėra leidžiama, tam yra naudojamas tuščias parametrų sąrašas.

		Kadangi funkcijos yra pirmos klasės nariai, funkcijos taip pat gali gražinti kitas funkcijas. Pavyzdys: 

		string()() - funkcija, kuri gražina string() tipo funkciją ir neima jokių argumentų.

		Funkcijų tipams yra naudojamos kompiliatoriaus generuotos klasės, kurių tiksli realizacija gali priklausyti nuo kompiliatoriaus. Taip 
		funkcijos gali be jokių papildomų išlygų tapti tipų sistemos dalimi.

		;; compiler spece reiktų parašyti tą tikslią realizaciją, tipo jei kas norės su laboraslang interopintis

		;; IMO, čia visai ne į temą. skyrius vadinasi Funkcijų tipai, o rašai apie calls, higer order functions ir panašius dalykus
		;; galima parašyti "daugiau apie funkcijas ir funkcijų tipus skyriuje Funkcijos"

		;; Aš manau, jog čia tam sakiniui apie implementacija tikrai ne vieta - T.

		Funkcija, kurią laiko funkcijos tipo kintamasis, yra iškviečiama šalia kintamojo parašant skliausteliuose argumentus, atskirtus kableliais. Pavyzdžiui:
		void(int, double) myVariable = someFunction;
		myVariable(3, 5.8);

		Funkcijų tipus galima naudoti perduodant funkcijas kaip argumentus kitoms funkcijoms: ;;Patogu - šališka nuomonė, nėra įrodymo kad patogu ar ne. A.
		int(int()) GetFunctionResultPlusOne = int(int() function)
		{
		    return function() + 1;
		};

		void() PrintSix = void()
		{
		    Console.WriteLine(GetFunctionResultPlusOne(int() { return 5; }));
		};

	2.2.3. Masyvų tipai

		LaborasLang palaiko masyvų kūrimą iš visų palaikomų tipų. Masyvo tipą sudaro elemento tipas ir matmenų skaičius, visi masyvai yra 
		indeksuojami nuo nulio. Tipų sistema nedengia masyvo matmenų ilgio, tik jų skaičių. Skaičius deklaruojamas kableliais tarp laužtinių 
		skliaustų. Gautas masyvas turės vienu matmeniu daugiau negu tipe yra kablelių. 

		Masyvo tipas yra nuorodos tipas, vieno matmens masyvai atitinka CLI vektoriaus specifikaciją, kelių matmenų masyvai (matricos) atitinka 
		CLI masyvo specifikaciją. Maksimalus masyvo matmenų skaičius yra 32. 

		<elemento tipas>[<matmenų skaičiaus deklaracija>]

		Pavyzdžiai:
		int[] //vienmatis int masyvas
		float[,] //dvimatis float masyvas
		System.Version[,,] // Trimatis versijų masyvas

		Taip pat, galima deklaruoti funkcijų masyvus.

		int(int)[]

		Arba masyvus sudarytus iš kitų masyvų (t.y. dantytus masyvus).

		int[][]

		Kadangi dantytą masyvą sudaro tik nuorodos į kitus masyvus, tokio masyvo matmenų ilgis yra neribojamas. Maksimalus įmanomas matmenų 
		skaičius priklauso nuo kompiliatoriaus realizacijos, taip pat nuo veikimo aplinkos (kompiliatoriaus ir gautos programos).

	2.2.4. Tipų keitimas

		LaborasLang tipų sistema nėra griežta, norint galima keisti reikšmių tipus, bet kompiliatorius užtikrina keitimo korektiškumą jei 
		tai yra įmanoma. Kadangi korektiškumą garantuoti yra įmanoma tik labai retais atvejais ir naudojant sudėtingą statinę analizę, 
		kompiliatorius leidžia tik akivaizdžiai teisingus keitimus.

		Tipo keitimas yra reikalingas keliose situacijose. Pirma, yra daug sveikųjų skaičių tipų, kurie visi laiko tą pačią informaciją 
		panašiu formatu. Taip galima pasirinkti geriausią tipą, bet gali reikėti keitimų perduodant duomenis. Antra, objektinis programavimas 
		reikalauja keitimų. Su keitimais objektų tipai neturi atitikti kintamųjų tipų, užtenka, kad paveldėtų jų tipus. 

		Yra naudojami du keitimų tipai: automatinis keitimas ir nurodomasis keitimas.

		2.2.4.1 Automatinis tipo keitimas

			Kai kuriais atvejais nesutampa reikšmės tipas ir reikalaujamas tipas, bet kompiliatorius gali nustatyti, kad keitimas galimas. Keitimo pagrindinės taisyklės:
			•	Jei tipai vienodi, keitimas nereikalingas. 
			•	Jei tai primityvūs tipai, ar norimas tipas gali įgyti visas keičiamo tipo reikšmes.
			•	Jei tai yra funkcijų tipai, ar sutampa parametrų skaičius? Ar reikšmės parametrus galima automatiškai keisti į norimo tipo parametrus?
			•	Jei tai masyvų tipai, ar sutampa matmenų skaičius? Ar reikšmės elemento tipą galima keisti į norimo tipo elementą?
			•	Ar reikšmės tipas paveldi iš norimo tipo?
			Jei netenkinama nei viena šių taisyklių, keitimas neleidžiamas ir rodoma klaida.
			Keičiant primityvius tipus, naudojama galimų keitimų lentelė.

			;;čia mano papaišyta nuostabi lentelė "assignment map.jpg"

			Šios taisyklės yra tranzityvios, t.y. jei uint8 galima keisti į int16, o int16 į int32, leidžiama ir uint8 keitimas į int32. 
			Vienintelė išlyga reikalavimui dėl korektiškumo yra sveikųjų skaičių keitimas į realiuosius, nors tai gali neduodi tikslių 
			rezultatų artėjant prie kraštutinių reikšmių, dėl paprastumo šis keitimas leidžiamas.

		2.2.4.2 Nurodomasis tipo keitimas

			Jeigu statiškai neįmanoma įrodyti keitimo korektiškumo, bet vartotojas žino, jog jis bus teisingas, galimas nurodomasis keitimas. 
			Šiame keitime vartotojas nurodo tipą į kurį nori keisti. Kompiliatorius draudžia tik tuos nurodomuosius keitimus, kurie yra garantuotai neteisingi. 
			Turi būti patenkinta viena iš sąlygų:
			•	Vienas iš tipų gali būti automatiškai keičiamas kitu;
			•	Abu tipai yra primityvūs ir nei vienas jų nėra bool.

	2.2.5 Null reikšmės tipas

		null yra išskirtinė reikšmė tuo, kad ji neturi tipo. Ją gali įgyti bet koks nuorodinio tipo kintamasis.

	2.2.6 Automatinis tipo radimas

		LaborasLang palaiko ribotą automatinį tipų radimą. Deklaruojant kintamuosius galima nurodyti auto tipą. Tokioje deklaracijoje tipas 
		bus randamas automatiškai, bet kintamąjį būtina inicializuoti. Kompiliavimo metu kintamojo tipas nustatomas toks pat kaip inicializatoriaus. Pavyzdys:

		auto str = "text";

		ir

		string str = "text";

		Abi deklaracijos sukompiliuojamos į identišką kodą.

	2.3. Kintamieji

		LaborasLang palaiko trijų tipų kintamuosius: lokalius kintamuosius, globalius kintamuosius ir funkcijų parametrus. Pagrindiniai 
		kintamųjų panaudojimo skirtumai yra jų galiojimo sritis.
		;; kiti skirtumai yra kur alokuojama, kada dealokuojama, gal šitą kada reikės parašyti

		2.3.1. Lokalūs kintamieji

			Lokalūs kintamieji yra kintamieji deklaruoti funkcijos viduje. Šių kintamųjų galiojimo sritis yra kodo blokas, kuriame jie buvo 
			deklaruoti, su keliomis išlygomis. Kintamieji pradeda galioti nuo jų deklaracijos ir baigia uždarant jų bloką. Jeigu kintamojo 
			galiojimo srityje yra deklaruota funkcija, iš šios funkcijos galima pasiekti kintamąjį, bet tik kaip skaitomą reikšmę.

		2.3.2. Globalūs kintamieji

			Deklaruojant kintamajį tiesiogiai faile, bus sukuriamas globalus kintamasis. Tokio kintamojo galiojimo sritis yra visas failas, 
			juo galima naudotis anksčiau negu jis yra deklaruotas. Kintamajį, priklausomai nuo deklaracijos, taip pat galima pasiekti iš 
			kitų failų. Plačiau apie tai skyriuje "Atributai".

		2.3.3. Funkcijų parametrai

			Funkcijos deklaraciją sudaro jos parametrai. Šie parametrai yra kintamieji, kurie įgis funkcijai perduotų argumentų reikšmes. 
			Parametrų galiojimo sritis yra visas funkcijos blokas, bet jų panaudojimas nesiskiria nuo lokalių kintamųjų.

	2.4. Išraiškos

		;; man dabar skaitoma/rašoma išraiška nepatinka. gal kas sugalvosit geriau - D.
		Išraiška yra kodo framgentas, kurios gali gražinti reikšmę, arba priimti reikšmę. Išraiškos, kurios gražina reikšmę, dar vadinamos 
		skaitomomis išraiškomis. Dauguma išraiškų yra skaitomos. Išraiškos, kurios gali priimti reikšmę vadinamos rašomomis išraiškomis. 
		Rašomomis išraiškomis gali būti yra simboliai, klasių nariai ir indeksavimas. Ar išraiška yra skaitoma arba rašoma priklauso nuo 
		išraiškos. Šios taisyklės tiksliai aprašomos prie kiekvieno išraiškos tipo.

		2.4.1. Literalai

			Literalai yra reikšmės įrašytos kode. Literalai yra tik skaitomos išraiškos.

			2.4.1.1 Loginiai literalai

				Reikšmės "true" ir "false" yra loginiai literalai. Jie gali būti naudojami kaip "bool" tipo skaitomos išraiškos.

				
		2.4.2. Simboliai
		2.4.2. Indeksavimas
		2.4.3. Funkcijos
		2.4.4. Funkcijos kvietimai
		2.4.5. Priskyrimo operacija
		2.4.6. Vienanarės operacijos
			;;2.4.6.1. Aritmeninės operacijos
			;;2.4.6.2. Loginės operacijos
			;;2.4.6.3. Bitinės operacijos
			;;Joined
		2.4.7. Dvinarės operacijos
			2.4.7.1. Aritmetinės operacijos
			2.4.7.2. Loginės operacijos
			2.4.7.3. Bitinės operacijos
			2.4.7.4. Stūmimo operacijos
		2.4.8. Objektų kūrimas
		2.4.9. Masyvų kūrimas
		2.4.10. Klasių nariai ;; C# vadina member-access
	2.5. Teiginiai

		;; kaip parašyti kas yra teiginys - D?

		2.5.1 Deklaracija

			;; Šitas skyrius labai išsipūtė, gal ką praleidau - D.

			Deklaracijos teiginys yra naudojamas deklaruojant kintamajį.

			<atributai> <tipas> <identifikatorius>;
			<atributai> <tipas> <identifikatorius> = <inicializatorius>;

			Atributai yra sąrašas atributų atskirtų tarpais, palaikomi atributai priklauso nuo kintamojo tipo. Atributus galima praleisti.

			Tipas yra bet koks palaikomas tipas išskyrus "void".

			Identifikatorius yra bet koks legalus simbolis. ;; reiktų kokio link į lexer skyriu kas yra legalus simbolis - D.

			Inicialiatorius yra bet kokia skaitoma išraška.

			Pavyzdžiai:

			int a; // "int" tipo kintamasis be inicializacijos
			float b = 5; // "float" tipo kintamasis su inicializacija
			string str = null; // teksto eilutė inicializuojama "null" reikšme.

			int(int) incrementer = int(int num)
			{
				return num + 1;
			};
			// funkcijos kintamasis su inicializacija

			Verta atkreipti dėmesį, jog po funkcijos bloko uždarymo yra ";". Funkcijos deklracija nėra kontrolės blokas ir jis, kaip visi 
			įprasti teiginiai yra baigiamas ";".
			;; pats šitą klaidą padariau ne kartą - D.

			Inicializuojant deklaraciją, jos tipą galima nustatyti "auto". Tada kintamojo tipas bus toks pat kaip inicializatoriaus išraiškos. 

			auto numbers = int[5];
			auto sudoku = void() { sudoku(); };	
			;; Ar pažiūrėjai, kad buildintųsi? Aš galvojau toks capture neveikia.
			;; yes, jei tai global var. O jei ir ne, šitas spece tinka, nes pagal spec veikia capture - D.

			;; čia dubliuojasi su skyriumi Automatinis tipo radimas, galvosiu kaip keisti - D.
			Deklaruojant "auto" tipą taikomi du apribojimai:
			* Deklaracija privalo būti inicializuota.
			* Inicializatorius negali būti "null", kadangi "null" neturi tipo.

			Jei nesilaikoma vieno iš šių apribojimų, kintamojo tipo nustatyti neįmanoma ir yra gražinama klaida.

			auto foo; // klaida
			auto bar = null; // klaida

			Norint papildomai apriboti kintamuosius, deklaracijoje galima jiems pridėti atributus. LaborasLang turi dvi atributų rūšis - 
			pasiekiamumo ir kintamumo. Pasiekiamumo atributai apriboja kintamojo galiojimo sritį, o kitamumo leidžia kintamajį padaryti 
			konstanta. Deklaracijoje galima pridėti po vieną kiekvienos rūšies atributą. Nepridėjus atributo rūšies bus nustatoma 
			standartinis atributas, kuris priklauso nuo deklracijos.

			2.5.1.1 Kintatumo atributai

				Yra du priešingi kintamumo atributai: const ir mutable. const padaro kintamajį konstanta, o mutable atvirkščiai - pažymi, 
				jog kintamajo reikšmė gali kisti. Konstantoms negalima priskirti reikšmės ir jas būtina inicializuoti. 

				const int a = 5;
				a = 6; // klaida, a reikšmę galima tik skaityti

				mutable int b = 7;
				b = 8; // reikšmę galima ir skaityti ir rašyti

				const int c; // klaida, konstantas būtina inicializuoti

				Standartinis atributas yra mutable, išskrus vieną atvejį. Globalūs funkcijų tipo kintamieji yra deklaruojami su const atributu. Tokia 
				taisyklė leidžia funkcijų perdengimą ir kelias optimizacijas. Norint gauti globalų funkcijos kintamajį, kuris nėra konstanta, 
				būtina deklarauotį jį su mutable atributu. 

				void() foo; // klaida, jei tai globalus kintamasis

				mutable void() foo; // šis kodas veikia

				Kintamumo atributai yra palaikomi lokalių ir globalių kintamųjų. 
				;; Koks tas atvejis kai kintamasis yra ne mutable by default? A.
				;; global functors, nes tada kompiliuojam į metodus. greičiau veikia ir galima naudoti overloading - D.

				
			2.5.1.2 Pasiekiamumo atributai

				Pasiekiamumo atributai naudojami apriboti globalių kintamųjų galiojimo sritį. Yra du pasiekiamumo atributai - private ir public. 
				private kintamieji yra pasiekiami tik iš failo kuriame yra deklaruoti, public kintamieji yra pasiekiami iš bet kurio failo. 
				Standartinis atributas yra private. 

				public auto foo = 5;
				private auto bar = 6;

				Pasiekiamumo atributai leidžiami tik globaliems kintamiesiems.

			Atributus galima kombinuoti. 

			public const int MAX_COUNT = 200;

			Bet deklaracijoje gali būti tik po vieną atributą iš kiekvieno tipo.

			public private int a; // klaida
			public public int b; // kompiliatoriui nereikia kartoti dalykų

		2.5.2 Vardų grupės importavimo ;; Gal kas geriau sugalvosit - D.

			Importavimo teiginys naudojamas į failo galiojimo sritį įterptį vardų grupes ir tipus iš kitos vardų grupės.

			use <vardų grupė>;

			Vardų grupė privalo būti pilna vardų grupė iš naudojamų asemblių.

			Po šio teiginio galima visus tipus ir vardų grupes iš nurodytos vardų grupės pasiekti tiesiogiai, nerašant importuotos grupės.

			use System;

			String a;
			Collections.ArrayList lst;

			yra analogiška

			System.String a;
			System.Collections.ArrayList lst;

			Importavimo teiginiai leidžiami tik faile. ;; Kaip kitaip parašyti - D?
			Faile gali būti neribotas skaičius importavimo teiginių.

			Nors teiginys importuoja ir vardų grupes, importavimo teiginyje privaloma rašyti pilną vardų grupę, net jei ji pasiekiama trumpiau per kitą teiginį.

			use System;
			use Collections; // klaida, nėra tokios vardų grupės
			use System.Collections; // Toks teiginys veikia

			Kompiliavimo metu importuoti tipai keičiami pilnais tipų vardais. Importavimas, kaip ir tipų pseudonimai, yra pagalbinė kompiliatoriaus funkcija. 
			Šių sakinių naudojimas visiškai neįtakoja gaunamo kodo veikimo.

		2.5.3 Grįžimo teiginys

			"return" teiginys naudojamas baigti funkcijos darbą. 

			return;
			return <reikšmė>;

			"return" sakinio tipas privalo atitikti funkcijos gražinamą tipą. Jei gražinas "void" tipas, leidžiamas tik tuščias "return" sakinys. Toks sakinys naudojamas tik užbaigti funkcijos darbą. "void" tipo funkcijos gali neturėti "return" sakinio, jų darbas bus baigtas pasiekus funkcijos bloko galą. 

			Jei funkcijos tipas nėra "void", ji privalo gražinti reikšmę, todėl privalomas bent vienas "return" sakinys su reikšme. Šios reikšmės tipas turi atitikti funkcijos tipą, arba turi egzistuoti automatinis keitimas iš reikšmės į funkcijos gražinamą tipą.

			Norint užtikrinti, jog funkcija tikrai gražins reikšmę, kompiliatoriuje įvedama gražinančio teiginio sąvoka.

			Teiginys gražina jei:
			* tai yra "return" teiginys
			* tai yra kodo blokas ir bent vienas jo teiginių gražina
			* tai yra sąlygos sakinys, jis turi abi atšakas ir jos abi yra gražinantys blokai

			Jei funkcijos blokas nėra gražinantis blokas, kompiliatorius gražina klaidą.

			Pavyzdžiai:

			void()
			{
				int a = 5;
			}// teisingas kodas, funkcijai nereikalingas return sakinys

			void()
			{
				return 5; // klaida, ši funkcija negali gražinti
			}

			int()
			{
				int a = 5;
			}// klaida, funcija negražina reikšmės

			int()
			{
				int a = GetNum();
				if(a > 6)
				{
					return a - 1;
				}
				else
				{
					return a + 1;
				}
			}// teigingas kodas, abi šakos gražina reikšmę


			int()
			{
				int a = GetNum();
				if(a > 6)
				{
					return a - 1;
				}
				else
				{
					a++;
				}
			}// klaida, viena iš šakų negražina reikšmės


			int()
			{
				int a = 5;
				if(a > 0)
				{
					return a;
				}
				else
				{
					a++;
				}
			}// klaida, viena iš šakų negražina reikšmės

			Šis kodo fragmentas parodo sistemos trūkumą. Nors jūs esatę įsitikinę, kad funkcija gražins reikšmę, kompiliatorius naudoja 
			paprastą analizę, kuri negali garantuoti šio fakto. Tokiu atveju tenka naudoti "return" sakinius, kurie niekada nebus įvykdyti.

		2.5.4 Tuščias teiginys

			Tuščią teiginį sudaro tik kabliataškis. Toks teiginys nedaro nieko ir gali būti naudojamas ten, kur sintaksė reikalauja teiginio, 
			bet nenorite nieko atlikti.

		2.5.5 Išraiškos teiginys

			<išraiška>;

			Bet kokia išraiška taip pat gali būti panaudota kaip teiginys. Tokia išraiška bus įvykdyta ir jos gražinama reikšmė atmesta.

	2.6. Kontrolės blokai

		Kontrolės blokai yra teiginiai naudojami valdyti programos vykdymo seką. Kontrolės blokai gali būti panaudoti tik kodo bloko viduje.

		2.6.1. Kodo blokas

			LaborasLang kodo blokai sudaromi iš atidarančių kabučių, sąrašo teiginių ir uždarančių kabučių.

			{
				<teiginių sąrašas>
			}

			Blokas leidžia įrašyti kelis teiginius, kur sintaksė palaiko tik vieną. Vykdant kodo bloką, jame esantys teiginiai yra vykdomi paeiliui.

			Kodo bloke deklaruoti kintamieji galioja tik iki blogo galo, todėl blokai taip pat naudojami norint apriboti kintamojo galiojimo sirtį.

			Pavizdys:

			{
				int a = 5;
				a++;
			}

			Kintamasis a galioja iki bloko pabaigos, bandymai jį naduoti vėliau gražins klaidą (nebent yra kitų kintamųjų vardu a).

			{
				int b = 5;
				{
					int a = b;
					b++;
				}

				Console.WriteLine(b);// išspausdintų 6
				Console.WriteLine(a);// bet yra klaida, kintamasis a čia neegzistuoja
			}

			Bloke kintamieji negali turėti to pačio vardo.

			{
				int a = 5;
				float a = 0.0; // klaida, kintamasis "a" jau deklaruotas
			}

			Tačiau, vardas gali būti vėl panaudojamas gilesniame bloke.

			{
				int a = 5;
				{
					Console.WriteLine(a);
					int a = 16;
					Console.WriteLine(a);
				}
				Console.WriteLine(a);
			}

			Ši programa išspausdins

			5
			16
			5

			Blokas gali būti tuščias. Toks blokas daro tą patį ką tuščias teiginys - visiškai nieko.

		2.6.2. Sąlygos sakinys

			Sąlygos sakinys naudojamas parinkti vykdomą teiginį pagal sąlygą.

			if(<sąlyga>)
				<teigiamas teiginys>
			
			if(<sąlyga>)
				<teigiamas teiginys>
			else
				<neigiamas teiginys>

			Sąlyga yra bet kokia "bool" tipo skaitoma išraiška.

			Jei sąlygos reikšmė yra "true", bus vykdomas tegiamas teiginys, jei "false" - neigiamas.

			"else" ir neigiamas teiginys gali būti praleisti.
			Pavyzdžiai:

			int num = GetNum();
			if(num >= 0)
				Console.WriteLine("Tegiamas skaičius");
			else
				Console.WriteLine("Neigiamas skaičius");

			num++;

			if(num < 0)
				return;

			"if" yra grupuojamas su artimiausiu "else" bloku. Norint sugrupuoti kitaip naudojami kodo blokai.

			int num = GetNum();
			if(num >= 0)
				if(num == 0)
					Console.WriteLine("Nulis");
			else
				Console.WriteLine("Neigiamas skaičius");

			Ši programa išspausdins "Neigiamas skaičius" visiems teigiamiems nenuliniams skaičiams, kadangi "else" yra grupuojamas su 
			artimiausiu "if". Pataisyta programa:

			int num = GetNum();
			if(num >= 0)
			{
				if(num == 0)
					Console.WriteLine("Nulis");
			}
			else
				Console.WriteLine("Neigiamas skaičius");


		2.6.3. Ciklai

			LaborasLang programavimo kalba palaiko trijų tipų ciklus: "while" tipo ciklą ir du "for" tipo ciklus.	
			;; Worde pakeisti kabutes į keyword style

			2.6.3.1. while ciklas
				
				while ciklas susideda iš dviejų dalių: ciklo sąlygos ir ciklo teiginio. Ciklas yra vykdomas tol, kol ciklo sąlyga 
				yra teisinga. Bendrą ciklo struktūrą galima aprašyti taip:

				while (<sąlyga>)
				    <teiginys>

				Ciklo teiginys yra bet koks LaborasLang kalboje legalus teiginys (kodo blokas, sąlyga, ciklas ir t.t.).

				Sąlyga yra bet kokia "bool" tipo skaitoma išraiška.
				
				Keletas while ciklo pavyzdžių:

				while (foo-- > 0)
				    Report(foo);

				while (IsValid(bar))
				{
					if (bar % 2 == 0)
						Console.WriteLine(bar);

					bar = Transform(bar);
				}

			2.6.3.2. C stiliaus for ciklas

				;; Mes teiginiais vadinam use, deklaciją, return, visokie ciklai yra kontrolės blokai. Reikia suvienodinti semantiką ir pataisyti taisyklę - D.

				LaborasLang kalba palaiko C stiliaus for ciklą - jis analogiškas C ciklui ir yra palaikomas daugumos C šeimos kalbų. 
				Šį for ciklą sudaro kelios dalys: ciklo inicializatorius, ciklo sąlyga, ciklo iteratorius ir ciklo teiginys. C stiliaus 
				for ciklo struktūra yra tokia: ;; nepasiskolinom o atėmėm A.

				for (<inicializatorius>; <sąlyga>; <iteratorius>)
					<teiginys>

				Kiekviena iš šio for ciklo atraštės dalių gali būti praleista.

				Ciklo inicializatorius, jei toks yra, privalo būti kintamojo deklaracija arba bet kokia LaborasLang išraiška. 
				Deklaracija gali būti su inicializacija arba be. Ši deklaracija sukuria lokalų kintamajį, kurio galiojimo sritis apima visą 
				ciklą.

				Ciklo sąlyga, jei tokia yra, privalo būti "bool" tipo skaitoma išraiška. Jei sąlygos nėra, ji pakeičiama išraiška "true".

				Ciklo iteratorius, jei toks yra, gali būti bet kokia išraiška.

				Ciklo teiginys yra bet koks LaborasLang teiginys, išskyrus "use" teiginį.

				Ciklo vykdymo tvaka:

					1. Jei aprašytas, įvykdomas ciklo inicializatorius.
					2. Įvykdoma ciklo sąlyga. Jei rezultatas nėra "true", baigiamas ciklo vykdymas.
					3. Įvykdomas ciklo teiginys. 
					4. Jei nebuvo išeita iš teiginio (pavyzdžiui "return" sakiniu) ir yra aprašytas iteratorius, jis yra įvykdomas.
						Vykdymas gražinamas į 2 punktą.

				;; Man šitas padeda suvokti kaip tiksliai vykdomas for - D.
				Naudojant "while" ciklą, "for" galima aprašyti taip:

				{
					<inicializatorius>;
					while (<sąlyga>)
					{
						<teiginys>;
						<iteratorius>;
					}
				}

				For ciklo pavyzdžiai:

				// Šis for ciklas spausdina "Spinning infinitely" be galo.
				for (;;)
				    Console.WriteLine("Spinning infinitely");


				// Šis for ciklas atspausdina skaičius nuo 0 iki 9 imtinai.
				for (int i = 0; i < 10; i++)
				    Console.WriteLine(i);


				// Šis ciklas analogiškas while ciklui
				for(;i < 10;)
				{
					Console.WriteLine(i);
					i++;
				}


			2.6.3.3. Kolekcijos iteravimo for ciklas

				Iteravimui per reikšmių kolekcijas dažnai naudojamas specialus ciklas, kitose kalbose vadinamas "foreach" ciklu. Šiame 
				cikle yra deklaruojamas kintamasis, kuris paeiliui įgyja visas rinkinio reikšmes. 

				for(<kintamojo tipas> <kintamojo pavadinimas> in <kolekcija>)
					<teiginys>

				Pagal kintamojo tipą ir pavadinimą yra deklaruojamas lokalus kintamasis. Šio kintamojo galiojimo sritis yra visas ciklas, 
				bet jo reikšmę galima tik perskaityti. Šis ciklas netinka, jei reikia modifikuoti kolekciją.

				Kolekcijos gali būti masyvai arba objektai turintys metodą GetEnumerator(). Kolekcijos išraiška bus įvykdyta vieną kartą 
				ir viso ciklo metu bus naudojamas tas pats enumeratorius. 
				;; čia gal tik biški BS.
				;; norėjau parašyti, kad jei iteruosi per call, nebus kviečiama 500 kartų - D.

				Kadangi iš kolekcijos visada galima sužinoti elemento tipą, dažnai deklracijoje naudojamas tipas "auto".

				Ciklo pavyzdžiai:

				// iteruojama per masyvą
				auto arr = int[] { 1, 2, 3, 4 };
				for (auto i in arr)
					Console.WriteLine(i);
				// išspausdins skaičius 1 - 4

				// iterauojama per kolekciją
				ArrayList lst = ...
				for (object i in lst)
					Console.WriteLine(i.ToString());
				// išspausdinami kolekcijos objektų tekstinės reprezentacijos ;; gal geresnis žodis tam yra - D.

3. LaborasLang gramatika
	3.1. Programos apibrėžimas
		Programa yra vienas ar daugiau išeities kodo failų.
	3.2. Dviprasmybės
		LaborasLang gramatikoje dviprasmybės yra gailimos tik sudarant žetonus. Jos yra sprendžiamos sudarant maksimalaus galimio ilgio
		žetonus. Tai yra taikoma valdant tokius žetonus kaip "<<", "++", "--", tai reiška kad nors teiginys "i = i--1" galėtų būti 
		transformuotas į "i = i - (-1)" dėl žetonų ilgio maksimizavimo jis bus suprastas kaip "i = (i--) 1", kas yra nevalidus kodas (
		nėra jokio operatoriaus tarp dviejų operandų).
	3.3. Leksinė gramatika
		3.3.x. Programa leksiniu požiūriu
			Išeities kodo failus sudaro matomieji ir nematomieji tarpai (whitespace), žetonai, komentarai.
			* Nematomieji tarpai yra tarpo, įtraukos, eilutės pabaigos bei kiti panašūs simboliai, kompiliavimo metu jie yra ignoruojami.
			* Komentarai atitinka C šeimos kalbų komentarus, tai yra galimi vienos eilutės komentarai kurie yra pradedami simboliais "//" bei
			tęsiami iki eilutės pabaigos simbolio ir bloko tipo komentarai pradedami "/*" simboliu ir baigiami "*/" simboliu. Komentarų
			turinys kompiliavimo metu yra ignoruojamas
			* Žetonai yra gaunami sujungiant gretimus simbolius į prasmingas maksimalaus ilgio leksemas, kurios yra toliau analizuojamos
			kompiliuojant programą. Žetonai yra tokie simboliai kaip
			"*", "+", "=", ";" bei ilgesni dariniai - "auto", "penki", "+=", "while" bei kiti. Žetonai naudojami sudaryti kalbos
			struktūras, kurios savo ruožtu sudaro programą.
			
			Galimi žetonai:
			;; Tik terminal tokens čia turi būti minimi. Visi kiti yra implementacijos detalė - A.
				Tiesioginės reikšmės
					Sveikieji skaičiai
					Slankaus kablelio skaičiai
					Simbolių eilutės
				Operatoriai
				Eilutės pabaigos simbolis
				Skliaustai
					()
					{}
					[]
				Raktažodžiai
					entry, auto ...
				Simboliai
					Foo, Bar


			Programa leksiniu požiūriu yra kalbos struktūrų rinkinys. Galimos kalbos struktūros yra kodo blokas, ciklas, sąlygos sakinys,
			sakinys: ;; Šitą reikia perfrazuot, dabartinis sakinys per arti implementacijos - A.
			CodeConstruct:
				CodeBlockNode,

				WhileLoop,
				ForLoop,
				ForEachLoop,
				
				ConditionalSentence,
				
				StatementWithEndOfLine

		3.3.X Kalbos struktūros
			3.3.x.x Sakinys
				Sakinys yra pagrindinė kalbos struktūra kuri nusako tam tikrą veiksmą. Ši kalbos struktūra yra grupė mažesnių struktūrų kurios turi tam tikras formavimo taisykles:
				"Use" sakinys
				Deklaravimo sakinys
				Reikšmės sakinys
				Grąžinimo sakinys.
				3.3.x.x.x. Sakinių leksinė sandara
					Use sakinys
					PEG tipo gramatika:
					UseNode:
						Use Symbol (Period Symbol)* EndOfLine

					Šį sakinį sudaro dvi dalys: Raktažodis "Use", tekstinis simbolis, nulis ar daigiau taško ir tekstinio simoblio grupių 
					bei eilutės pabaigos simbolis - kabliataškis.
					"Use" sakinio pavyzdys:
						use Foo.Bar;
					čia use yra "Use" taisykės dalį atitinkantis raktažodis, Foo atitinka pirmąjį simbolį, taško simbolis bei "Bar" yra
					vienas pasikartojimas "Period" bei "Symbol" grupės o ";" yra "EndOfLine" reiškiantis simbolis. 

					Deklaravimo sakinys
					PEG tipo gramatika:
					DeclarationNode:
						VariableModifier* Type Symbol Assignment Value
						VariableModifier* Type Symbol
				
			3.3.x.x Kodo blokas			
			3.3.x.x Sąlygos sakinys
			3.3.x.x Ciklas

	3.3. Sintaksinė gramatika
4. LaborasLang programų pavyzdžiai
5. Pavyzdinis kompiliatorius
	5.1. Komponentai
		5.1.1. Lekseris
			Apžvalga/aprašas ;;Nežinau kaip šitas turėtų vadintis
				Šis modulis iš programos išeities kodo sugeneruoja abstraktų sintaksės medį kuris yra toliau naudojamas semantinėje analizėje.
				Abstraktaus sintaksės medžio generavimas atliekamas trimis žingsniais:
					1. Išeities kodo skaidymas žetonais (leksemomis)
					2. Pirminis žetonų formavimas į abstraktų sintaksės medį
					3. AST medžio apdorojimas baigiamosiomis doroklėmis (post processors)
				Pirmas žingsnis atliekamas "Tokenizer" komponento, antrasis - "Syntax matcher" modulio, trečiasis "Post processor" modulio. 
				;;todo išversti šitus žodžius, gal Jusas pasiūlys kokias lietuviškas alternatyvas
			Komponentai
				Tokenizer
					Šis komponentas iš išeities kodo teksto sugeneruoja sąrašą leksemų kurios turi tam tikrą tipą, turinį, vietą pradiniame
					išeities kode.
					RulePool
					Šis komponentas yra statinis kalbos gramatinių taisyklių sąrašas kuris naudojamas SyntaxMatcher modulio. Šis modulis
					nusako visą abstraktaus sintaksės medžio struktūrą kuri bus išlaikoma iki apdorojomo baigiamosiomis daryklėmis. Visos 
					aprašytos taisyklės yra bekontekstės, naudojama PEG gramatika. Konteksto nebuvimas apsunkina operatorių analizę, dėl to
					 jų operacijų prioritetą atitinkantis medis yra suformuojamas baigiamosiomis daryklėmis.
				SyntaxMatcher
					Šis komponentas analizuoja leksemų sąrašą ir iš jo suformuoja medį pagal RulePool modulyje aprašytas taisykles.
				PostProcessors
					Šis komponentas leidžia atlikti kontektines operacijas su abstrakčiu sintaksės medžiu. Tai panaudojama atlikti veiksmus kurie
					yra labai sudėtingi naudojant PEG gramatiką. Šie veiksmai yra:
						Operatorių prioritetizavimas
						Funkcijų ir masyvų atskyrimas
						Neigiamų skaičių atpažinimas
						Taško operatoriaus apdorojimas
						Perteklinių medžio šakų minimizavimas

			Tokenizer ("Žetonatorius")
				Atliekama funkcija
					Išeiteis kodas suskaidomas į leksemas. Leksema yra sudaryta iš jos turinio, tipo, vietos išeities kode.
				veikimo principas
					Modulio veikimo principas - iš eilės skaitomas tekstas po vieną simbolį kol nuskaityti simboliai gali būti sujungti į vieną 
					leksemą, pvz tekstas {code}pirmas=antras+trečias;{code} bus pradėtas skaityti, pirmas rastas simbolis yra raidė 'p', iš to 
					galima nuspręsti kad tai bus simbolis. Šis simbolis skaitomas kol bus rasta raidė netinkama simboliams - '=', tada simbolis 
					bus užsaugotas, patikrita ar tai yra vienas iš rezervuotų žodžių tam kad nustatyti teisingą tipą ir pridėtas į leksemų sąrašą. 
					Analogiškai bus apdorojamas ir likęs išeities kodas.
				Testavimas
					Modulis testuojamas naudojant išeities kodo pavyzdžius kurie sudaryti taip kad testais būtų padengtas visas šio modulis. 
					Testai vyikdomi sugeneruojant leksemų sąrašą ir jį lyginant su anksčiau sugeneruotu leksemų sąrašu. Jei leksemų sąrašai 
					nesutampa apie tai pranešama programuotojui ir jie patikrinami, lyginant su siekiamu rezultatu. Pagal tai ar atitinka 
					rezultatą nusprendžiama ar testas yra sėkmingas ar nesėkmingas. Visi gauti sąrašai yra serializuojami ir saugomi kartu 
					su testų duomenų sąrašu.
			RulePool ("Taisyklių sąrašas")
				Atliekama funkcija
					Saugomas kalbos gramatikos taisyklių sąrašas. Naudojama gramatika kuri yra panaši į PEG gramatiką.
					Taisyklės yra sudaromos iš terminalinių ir neterminalinių žetonų. Kiekvienam neterminaliniam žetonui yra nurodoma taisyklė 
					kuri jį aprašo terminaliniais ir neterminalianiais žetonais. Vieną neterminalinį žetoną galima aprašyti keliomis skirtingomis 
					taisyklėmis, jos bus taikomos iš eilės pagal deklaravimo tvarką. Taisyklėse naudjoami terminalinių ir neterminalinų žetonų 
					modifikatoriai: 
						* Vienas arba daugiau
						* nulis arba daugiau
						* neprivalomas galas
						* neprivalomas
					Modifikatorius "Vienas arba daugiau"
						Naudojamas nurodyti kad šis elementas gali kartotis vieną arba daugiau kartų
					Modifikatorius "Nulis arba daugiau"
						Naudojamas nurodyti kad šis elementas gali kartotis nulį arba daugiau kartų. Gramatikoje naudojamas nurodyti neprivalomus 
						deklaracijos modifikatorius, vienanarius operatorius. 
					Modifikatorius "Neprivalomas galas"
						Šis modifikatorius naudojamas deklaracijose, juo nurodoma kad deklaracijose reikšmės priskyrimas nėra privalomas. Šis 
						operatorius gali būti pakeistas rekursiniu kreipiniu, tačiau toks kreipinys nėra optimalus dėklo naudojimo požiūriu bei 
						taisyklių skaitomumo atžvilgiu.
					Modifikatorius "Neprivalomas"
						Šis modifikatorius naudojamas nurodant neprivalomus žetonus. Šio modifikatoriaus naudojimo galima išvengti aprašant 
						alternatyvias taisykles.

					Taip pat taisyklės gali būti apibrėžtos kaip:
						* Taisyklė
						* Minimizuojama taisyklė
						* Visada minimizuojama taisyklė
					Minimizuojama ir visada minimizuojama taisyklės yra naudojamos tarpinių abstraktaus sintaksės medžio narių aprašymui kurie 
					turi prasmę tik leksikografinėje analizėje, tokie kaip "Kablelis ir reikšmė".

					Taisyklės palaiko ribotą rekursiją. Jos apribojimas yra tai kad rekursinis kreipinys privalo turėti bent vieną nerekursinį 
					kreipinį prieš rekursinį taisyklės panaudojimą. Nepaisant to tiesioginė rekursija taisyklių sąraše yra nenaudojama.
				Testavimas
					Taisyklių sąrašas testuotas jį naudojant sintaksės atpažinimo modulyje bei atliekant taisyklių analizę:
						Tikrinama ar nėra nenaudojamų taisyklių
						Tikrinama ar visi galimi žetonai yra apibrėžti taisyklėse
						Tikrinama ar nėra begalinės rekursijos taisyklėse 

			SyntaxMatcher ("Sintaksės atpažinimo sistema")
				Atliekama funkcija
					Šis modulis leksemų sąrašą performuoja į abstraktų sintaksės medį pagal taisyklių sąrašą.
				veikimo principas
					Syntax matcher nauoja taisyklių sąrašą kad sugeneruoti teisiną ast iš rule poo'lo. Viskas pradedama nuo pagrindinės taisyklės
					 kuri nusako programos struktūrą, tai yra abiė sakinių. Taisyklės taikomos jų neterminalines leksemas keičiant kitomis 
					 tiasuuklėmis ir jas pritaikant. Jei bent viena alternatyva iš taisyklės sprendimųš tinka tai ji pridedama į ast, jei ne
					  - nepridedama, ir mėginama kita alternatyvi taisyklė. Taip kiekviena netermianlinė taisyklė yra išskleidžiama iki 
					  terminalinių žetonų kurie atitinka leksemų sąrašo narius. Jei nei viena taisuklė netiko laikoma kad išeities kodas yra 
					  nekorektiškas, tačiau dėl geresnės statinės analizės kompiliavimas nėra nutraukiamas. SyntaxMatcher bando surasti iš kur 
					  galėtų vėl pradėti analize, tam naudoja ; ar { simbolius. Simbiliai kurie nėra pridėti į ast ir yra iki to recovery point 
					  pridedami pire ast kaip Unkown node. tai leidžia pranešti daugiua nei vieną klaidą kompiliaciojs metu. Syntax matcher 
					  taisyklių taikymas yra godus, jei taisyklė tinka tai ji yra pritaikoma ir kitos nemėginamos, laikoma kad pirma tikusi 
					  taisyklė yra geriausia. Taisyklės yra prioretizuotos, jų deklaravimo travka nurodo prioritetą, dėl to išvengiama vietų 
					  kur gali būti pritaikyta daiugiau nei viena taiskylė. 
						Toks syntax matcher veikimo algoritmas yra tragiškas atminties naudojimo atžvilgiu nes pastoviai deklaruojama labai daug 
						ast nodes kurie yra nebenaudojami - jei kokia taisyklė sufailino yra grįžtama iki jos alternatyvos, dėl to daug objektų 
						tampa nebenaudojami ir GC turi juos visus surinkti. Tai darė didelę įtaką analizės greičiui, dėl to sudarant ast 
						naudojamas rankinis atminties valdymas. Aprašyta RootNode kuri atitinka atminties valdymo objektą kuris suteikia 
						resursus, Tai liedžia pranešti kad tam tikra medžiop šaka nebus naudojama ir ją galima perpanaudoti tolimesniam medžio 
						formavimui, taip išvengiant bereikalingų objektų alokacijų ir deadlokacijų.

					Galima teigti kad šis modulis yra bekontekstis lexeris, nes nėra saugoma jokia globali būsena kuri naudojama tikrinti 
					leksemų sąrašui, jis yra lyginamas tik su taisyklių sąrašu. Tai leidžia naudoti metaprogramą - taisyklių sąrašą ir jo 
					interpretatorių - SyntaxMatcher. Taip labai lengvai atskirtas taisykjlės nu o jų pritaikymo logikos, tas leido RulePool 
					naudoti kaip dalinę ast dokumentaciją

						Šio modulio sugeneruotas ast yra laikomas specifiniame optimizuotame formate - RootNode valdomame atminties bloke. Nors 
						jis yra optimalus atminties naudojimo atžvilgiu brute force taisyklių taikymo metu jis tampa sudėtingu kai reikia naudoti 
						post procesorius. Dėl to po syntax matcher praleidimo jis yra keičiamas paprastu adt-ish medžiu.
				Testavimas
					SyntaxMatcher testuojamas regresiniais testais. Naudojant abię išeities kodo pavyzdžių yra sugeneurojami ast kurie yra lyginami 
					su modifikuoto rulePool ast. Tai leidžia paprastai sukurti naujus testus - užtenka parašyti kodo gabaliuką ir peržiūrėti 
					sugeneruotą AST dėl korektiškuom. Tokio testavimo trūkumai - kartu su išeities kodu reikia saugoti serializuotus ast, jei 
					keičiasi medžio API reikia pergeneruoti ir rankois patikrinti daug failų.
					Testuose taip pat tikrinama kad medžiuose nėra nei vieno UnknownNode kuris rieškia kad neišėjo pritaikyti nei vienos taisyklės 
					šiam kodo blokui.

			PostProcesorius
				Atliekama funkcija
					PostProcesoirius yra hackas skirtas pridėti kontekstą į bekontekstinį lexerį. Post procesoriai vykdomi iteruojant per ast ir 
					tikrinant kuris simbolis rastas, jie gali būti keičiami, restrukūtrizuojami, pašalinami. Aktyvšs post'ai:
						Operatorių prioritetizavimas
						Funkcijų ir masyvų atskyrimas
						Neigiamų skaičių atpažinimas
						Taško operatoriaus apdorojimas
						Perteklinių medžio šakų minimizavimas

					Operatorių prioritetizavimas:
					Naudojamas Dijkstros Shunting yard algoritmas infix notacijos vertimui į medžio formos postfix notaciją. Toks metodas parinktas 
					dėl sudėtingumo išreikšiant operatorius per rule pool - jį sudėtinga debuginti, sudėtinga nustatyti okie pakitimai sulaužys 
					kitas taisykles. Po perėjimo prie psot'o pastebėtas ir gana žymus pagreitėjimas - taip nutiko dėl to kad kiekvienas value 
					eidavo per 10 bereikalingų taisykjlių lygių, tą panaikinus dabar eina tik per tris, tai reiškia kad kiekviena vertė, reiškėm, 
					function call yra išleksinami žymiai greičiau.
					Funkcijų ir masyvų atskyrimas:
						Kalbos gramatika nėra context free. function call ir tipai atrodo identiškai. Kadangi lexeris yra pritaikytas cfg 
						gramatikai funkcijų tipus teko analizuoti kontekstą turinčioje dalyje. Šis postas atpažysta ar tai yra funkcija ar taipas 
						ar masyvas. 
					Neigiamų skaičių atpažinimas:
						Parseriui netiko kai minusas yra unary operatorius, reikia kad kai pirmas narys yra skaičius jis būtų neigiamas skaičius o 
						ne skaičius plius unary operatorius. Tai išsprendžiama šio post'o
					Taško opreratoriaus apdorojimas:
						Taškas yra įterpiamas trarp simbolių. Taip gaunamas sąrašįas kurio kas antras narys yra taškas. Tokį parseriui apdoroti 
						sunkiau, jis performuojamas į medį kuris sudarytas iš kairės, taško, dešinės - taškas tampa paprastu dvinariu operatoriumi.

					perteklinių medžio šakų minimizavimas
						Kai kurie nodes yra nereikalingi - jie neturi jokio turinio, trukdo parseriui dirbti, dėl to jei jie yra tušti jie yra 
						collapsinami į. Taip gunamas mažesnis ir prpaastesnis medis. vėliau yra tikimasi panaikinti ir kitus nereikalingus 
						operatorius kaip taškas, kabliataškus, priskyrimas ar kita.
				
				Testavimas
					Rankomis suformuojamas siekiamas medžio snippet'as kuris yra lyginamas su gautu medžiu. Toks testavimo būdas parinktas vietoje 
					serializavimo dėl mažesnio postų sudėtingumo nei syntax matcherio ir sudėtingo analizavimo, nelabai aišku kaip medis geras ar 
					ne, jei jis formuotas rankomis tai galima nustatyti nesudėtingai. Šis metodas gali būti naudojamas ir paprasto lexerio 
					testavime, bet tai neturi įeiti į šią ataskaitą.
		5.1.2. Parseris
		5.1.3. Kodo generatorius
	5.2. Testavimas
		5.2.1. Lekserio testavimas
		5.2.2. Parserio testavimas
		5.2.3. Kodo generatorius testavimas
			5.2.3.1. CIL kodo palyginimu grįsti testai
			5.2.3.2. Vykdymu grįsti testai
		5.2.4 Kontraktai/statinė analizė
	5.3. Vartotojo dokumentacija
		5.3.1. Išvesties tipai
		5.3.2. Bibliotekų nuorodos
		5.3.3. Šakninės direktorijos
6. Išvados
7. Literatūra
