Programavimo kalba „LaborasLang“
Bakalauro baigiamasis darbas


Techininė užduotis
Autentiškumo patvirtinimas
Santrauka
Summary
Lentelių sąrašas
Paveikslų sąrašas
Terminų ir santrumpų žodynas

	Asemblis – failas, kuris yra LaborasLang programos kompiliavimo rezultatas. 
	CIL (Common Intermediate Language) – kalba, kurią supranta ir geba vykdyti CLI implementacijų vykdymo aplinkos.
	CLI (Common Language Infrastructure) – tai specifikacija, aprašanti virtualią vykdymo aplinką ir CIL kodą. CLI yra specifikuota ECMA-335 tarptautiniame standarte. Dvi populiariausios CLI implementacijos yra CLR (.NET karkaso dalis) ir Mono Runtime.
	LaborasLang programa – vienas ar daugiau išeities kodo failų, kurie paduodami LaborasLang kompiliatoriui kaip duomenys. 
	Įeities taškas (entry point)– speciali funkcija, kuri yra iškviečiama paleidus aplikaciją.
	Išraiška (expression)– kodo fragmentas, kurį įvykdžius galima gauti reikšmę, arba jam nustatyti reikšmę.
	Skaitoma išraiška (gettable expression, rvalue) – išraiška, kuri garantuotai gražina reikšmę.
	Rašoma išraiška (settable expression, lvalue) – išraiška, kuriai galima nustatyti reikšmę.
	Lokalus kintamasis (local variable) – kintamasis deklaruotas funkcijoje.
	Globalus kintamasis (global variable) – kintamasis deklaruotas faile.
	Galiojimo sritis (scope) – taisyklės nusakančios kintamųjų pasiekiamumą.
	Sąveika (interoperability) – sistemos galimybė bendrauti su kitomis sistemomis. Kalbos kontekste tai yra galimybė naudoti resursus sukurtus kitomis kalbomis, taip pat kitose kalbose naudoti LaborasLang resursus.
	Blokas, kodo blokas – Kodo fragmentas apribotas simboliais „{“ ir „}“.
	Literalas (literal) – Kode įrašyta reikšmė.
	Vertės tipas (value type) – tipas, kurio kintamasis laiko reikšmę.
	Nuorodos tipas (reference type) – tipas, kurio kintamasis laiko nuorodą į reikšmę.
	Daugybinis tipas (generic type) – tipas turintis kelis daugybinius parametrus, galintis aprašyti kelis skirtigus tipus.
	Tipo pseudonimas (type alias) – papildomas vardas skiriamas tipui.
	Dantytas masyvas (jagged array) – masyvas sudarytas iš kitų masyvų.
	Automatinis tipo keitimas (implicit cast) – reikšmės tipas pagal poreikį keičiamas be vartotojo reikalavimo.
	Nurodomasis tipo keitimas (explicit cast) – reikšmės tipas keičiamas, nes taip nurodė vartotojas.
	Funkcijos parametras (function parameter) - funkcijos deklaruojamas kintamasis, kuris įgyja funkcijos argumento reikšmę. ;;geriau nemoku parašyti, bet niekas nežino kuo arg nuo param skirias
	Funkcijos argumentas (function argument) - reikšmė paduodama funkcijai.


Įvadas

	Ši specifikacija aprašo programavimo kalbą, pavadinimu „LaborasLang“. LaborasLang kalbos autoriai yra Andrius Dapševičius, Darius Lapūnas ir Tautvydas Žilys. 
	Pagrindiniai tikslai, keliami LaborasLang, yra:
	•	Esamiems programuotojams pažįstama sintaksė. Yra siekiama, kad programuotojai,  pažystami su bet kuria programavimo kalba, kurios sintaksė yra kilusi iš C kalbų šeimos, galėtų greitai išmokti programuoti su LaborasLang.
	•	Statinė tipų sistema. LaborasLang kompiliatorius turi sugebėti statiškai patikrinti tipų naudojimą.
	•	Funkcijos – pirmos klasės nariai. LaborasLang programavimo kalboje, funkcijas galima naudoti lygiai taip pat, kaip ir bet kurį kitą duomenų tipą.
	•	Paprastumas. Vienas iš LaborasLang uždavinių – būti kuo įmanoma paprastesnei.
	•	Vykdymo greitis. LaborasLang kalba parašytos programos turi galėti efektyviai išnaudoti kompiuterio resursus.
	•	Sąveika su kitomis programavimo kalbomis. LaborasLang kalba parašytos programos turi galėti naudotis bibliotekomis, kurios yra parašytos kitomis .NET programavimo kalbomis. Dėl šios priežasties, LaborasLang programos yra kompiliuojamos į CIL. Taip pat bibliotekos parašytos LaborasLang turi veikti kitose .NET kalbose.


1. Apimtis

	Ši specifikacija apibrėžia LaborasLang programavimo kalbą. Tai apima:
	•	LaborasLang kalbos leksinę ir sintaksinę gramatiką;
	•	LaborasLang kalbos semantiką;
	•	LaborasLang kalbos apribojimus.
	Kartu su specifikacija pateikiamas pavyzdinio LaborasLang kalbos kompiliatoriaus aprašas.

2. LaborasLang apžvalga
	LaborasLang yra statiškai tipuojama, procedūrinė, kompiliuojama, bendros paskirties programavimo kalba, turinti funkcinio programavimo elementų. Šis skyrius aprašo pagrindines LaborasLang kalbos savybes.

	2.1. Pirmoji LaborasLang programa

		Pavyzdinė „Hello, world“ programa LaborasLang kalboje gali būti užrašoma taip:

		use          System;         

		entry auto HelloWorld = void()
		{
		    Console.WriteLine("Hello, world!");
		};

		Išnagrinėkime šią programą po eilutę:
		•	Sakinys  use System; nurodo, jog šiame faile tipai ir vardų grupės iš System vardų grupės pus tiesiogiai pasiekiami.
		•	entry auto HelloWorld = void() šioje eilutėje yra deklaruojamas kintamasis HelloWorld. Šiam kintamajam yra priskiriama funkcija, kurios tipas – void(). Kadangi kintamojo deklaravimo metu jam yra priskiriama reikšmė, tai jo tipą galima nustatyti automatiškai – tai nurodo specialus tipas auto. Raktinis žodis entry nurodo, jog šis kintamasis yra įeities taškas.
		•	{ pažymima funkcijos pradžia.
		•	Console.WriteLine("Hello, world!"); iškviečiama funkcija WriteLine esanti Console tipe. Tai yra standartinė CLI funkcija.
		•	}; pažymima funkcijos pabaiga ir užbaigiamas priskyrimo sakinys.


2.2. Tipai
	LaborasLang palaiko dviejų rūšių tipus: vertės tipus ir nuorodinius tipus. Vertės tipai, skiriasi nuo nuorodinių tipų tuo, kad jie savyje laiko reikšmę. Nuorodiniai tipai laiko nuorodą į reikšmę. Dvi nuorodos gali rodyti į tą pačią reikšmę, o reiškia, kad pakeitimai per vieną nuorodą gali atsirasti kitoje. Tai neįmanoma su vertės tipais, nes vertės tipo kintamieji turi savo reikšmės kopiją. Pavyzdžiui:

	use System;         
	use System.Runtime.InteropServices.ComTypes;
	use System.Text;

	entry auto MyFunction = void()
	{
	    FILETIME value;
	    value.dwLowDateTime = 15;

	    auto reference = StringBuilder("Laboras");

	    Console.WriteLine(value.dwLowDateTime);
	    Console.WriteLine(reference);

	    auto valueCopy = value;
	    valueCopy.dwLowDateTime = 20;

	    auto referenceCopy = reference;
	    referenceCopy.Append("Lang");

	    Console.WriteLine(value.dwLowDateTime);
	    Console.WriteLine(valueCopy.dwLowDateTime);

	    Console.WriteLine(reference);
	    Console.WriteLine(referenceCopy);
	};

	Ši programa atspausdina:
	15
	Laboras
	15
	20
	LaborasLang
	LaborasLang

	Visi palaikomi CLI tipai paveldi iš System.Object. Reikšmės tipai paveldi iš System.ValueType, kuris paveldi iš System.Object. LaborasLang taip pat palaiko sąsajos tipus, kurių objektai gali būti vertės arba nuorodiniai tipai, priklausomai nuo realizacijos.

	2.2.1. Fundamentalieji tipai

		LaborasLang turi keletą fundamentaliųjų tipų, kurie atitinka fundamentaliuosius CLI tipus:

		Tipo vardas	     CLI tipo atitikmuo	     Pastabos
		bool	         System.Boolean	         Loginis tipas, galintis laikyti 2 reikšmes: true ir false.
		int8	         System.SByte	         1 baito dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-128; 127].
		uint8	         System.Byte	         1 baito dydžio sveikasis skaičius be ženklo, Galimos reikšmės: [0; 255].
		int16	         System.Int16	         2 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-32768; 32767].
		uint16	         System.UInt16	         2 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 65535].
		char	         System.Char	         2 baitų dydžio simbolio tipas.
		int32, int	     System.Int32	         4 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-2147483648; 2147483647].
		uint32, uint	 System.UInt32	         4 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 4294967295].
		int64, long	     System.Int64	         8 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės:  [–9,223,372,036,854,775,808; 9,223,372,036,854,775,807].
		uint64, ulong	 System.UInt64	         8 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 18,446,744,073,709,551,615].
		float	         System.Single	         4 baitų dydžio slankaus kablelio skaičius, atitinkantis IEC 60559:1989 standartą.
		double	         System.Double	         8 baitų dydžio slankaus kablelio skaičius, atitinkantis IEC 60559:1989 standartą.
		void	         System.Void	         Tipas neturintis reikšmės. Naudojamas pažymėti, jog funkcija negražina rezultato.
		object	         String.Object	         Objektas – fundamentaliausias tipas. Jis gali laikyti bet kurio kito tipo reikšmes.
		string	         System.String	         Simbolių eilutės tipas.

		Fundamentalieji tipai išskyrus void, object ir string yra taip pat vadinami primityviaisiai tipais. Jie yra naudojami atliekant standartines operacijas ir sudaro kitus CLI tipus. ;;might be BS, bet kažkaip noriu parašyti kad yra primitives. paskui primitives naudoju apie castus rašydamas

		Fundamentaliųjų tipų vardai yra pseudonimai CLI tipams ir jie yra kompiliavimo metu verčiami į tikruosiu tipus.
		Todėl:

		string foo;
		ir 
		System.String foo;

		yra sukompiliuojami į identišką kodą.

	2.2.2. Funkcijų tipai

		LaborasLang kalboje, funkcijų tipus apibrėžia funkcijos gražinamas tipas ir jos priimamų argumentų tipai. Pilna funkcijos tipo sintaksė yra:

		<gražinamas tipas>(<parametrų tipai atskirti kableliais>)

		Ir gražinamas tipas, ir parametrų tipai gali būti bet kokie LaborasLang palaikomi tipai. Keletas funkcijų tipų pavydžių:
		void() – funkcija negražina rezultato ir nepriima jokių argumentų.
		void(int, double) nurodo, jog funkcija negražina jokio rezultato, ir priima du argumentus, kurių tipai yra int ir double.
		string(string, string()) nurodo, jog funkcija gražina rezultatą, kurio tipas yra string, ir priima du argumentus, kurių tipai yra string ir funkcija, kuri gražina string tipo rezultatą.
		int[](System.Collections.IList)

		void tipas gali būti naudojamas tik kaip funkcijos gražinamas tipas. C stiliaus sintaksė int(void), kurioje void parametrų sąraše reikšdavo nulį parametrų nėra leidžiama, tam yra naudojamas tuščias parametrų sąrašas.

		Kadangi funkcijos yra pirmos klasės nariai, funkcijos taip pat gali gražinti kitas funkcijas. Pavyzdys: 

		string()() - funkcija, kuri gražina string() tipo funkciją ir neima jogių argumentų.

		Funkcijų tipams yra naudojamos kompiliatoriaus generuotos klasės, kurių tiksli realizacija gali priklausyti nuo kompiliatoriaus. Taip funkcijos gali be jokių papildomų išlygų tapti tipų sistemos dalimi.

		;; compiler spece reiktų parašyti tą tikslią realizaciją, tipo jei kas norės su laboraslang interopintis

		;; IMO, čia visai ne į temą. skyrius vadinasi Funkcijų tipai, o rašai apie calls, higer order functions ir panašius dalykus
		;; galima parašyti "daugiau apie funkcijas ir funkcijų tipus skyriuje Funkcijos"

		Funkcija, kurią laiko funkcijos tipo kintamasis, yra iškviečiama šalia kintamojo parašant skliausteliuose argumentus, atskirtus kableliais. Pavyzdžiui:
		void(int, double) myVariable = someFunction;
		myVariable(3, 5.8);

		Funkcijų tipus labai patogu naudoti perduodant funkcijas kaip argumentus kitoms funkcijoms:
		int(int()) GetFunctionResultPlusOne = int(int() function)
		{
		    return function() + 1;
		};

		void() PrintSix = void()
		{
		    Console.WriteLine(GetFunctionResultPlusOne(int() { return 5; }));
		};

	2.2.3. Masyvų tipai

		LaborasLang palaiko masyvų kūrimą iš visų palaikomų tipų. Masyvo tipą sudaro elemento tipas ir matmenų skaičius, visi masyvai yra indeksuojami nuo nulio. Tipų sistema nedengia masyvo matmenų ilgio, tik jų skaičių. Skaičius deklaruojamas kableliais tarp laužtinių skliaustų. Gautas masyvas turės vienu matmeniu daugiau negu tipe yra kablelių. 

		Masyvo tipas yra nuorodos tipas, vieno matmens masyvai atitinka CLI vektoriaus specifikaciją, kelių matmenų masyvai (matricos) atitinka CLI masyvo specifikaciją.  Maksimalus masyvo matmenų skaičius yra 32. 

		<elemento tipas>[<matmenų skaičiaus deklaracija>]

		Pavyzdžiai:
		int[] //vienmatis int masyvas
		float[,] //dvimatis float masyvas
		System.IO.File[,,] //trimatis failų masyvas

		Taip pat, galima deklaruoti funkcijų masyvus.

		int(int)[]

		Arba masyvus sudarytus iš kitų masyvų, kitaip dantytus masyvus.

		int[][]

		Kadangi dantytą masyvą sudaro tik nuorodos į kitus masyvus, tokio masyvo matmenų ilgis yra neribojamas. Maksimalus įmanomas matmenų skaičius priklauso nuo kompiliatoriaus realizacijos, taip pat nuo veikimo aplinkos (kompiliatoriaus ir gautos programos).

	2.2.4. Tipų keitimas

		LaborasLang tipų sistema nėra griežta, norint galima keisti reikšmių tipus, bet kompiliatorius užtikrina keitimo korektiškumą jei tai yra įmanoma. Kadangi korektiškumą garantuoti yra įmanoma tik labai retais atvejais ir naudojant sudėtingą statinę analizę, kompiliatorius leidžia tik akivaizdžiai teisingus keitimus.
		Tipo keitimas yra reikalingas keliose situacijose. Pirma, yra daug sveikųjų skaičių tipų, kurie visi laiko tą pačią informaciją panašiu formatu. Taip galima pasirinkti geriausią tipą, bet gali reikėti keitimų perduodant duomenis. Antra, objektinis programavimas reikalauja keitimų. Su keitimais objektų tipai neturi atitikti kintamųjų tipų, užtenka, kad paveldėtų jų tipus. 
		Yra naudojami du keitimų tipai: automatinis keitimas ir nurodomasis keitimas.

		2.2.4.1 Automatinis tipo keitimas

			Kai kuriais atvejais nesutampa reikšmės tipas ir reikalaujamas tipas, bet kompiliatorius gali nustatyti, kad keitimas galimas. Keitimo pagrindinės taisyklės:
			•	Jei tipai vienodi, keitimas nereikalingas. 
			•	Jei tai primityvūs tipai, ar norimas tipas gali įgyti visas keičiamo tipo reikšmes.
			•	Jei tai yra funkcijų tipai, ar sutampa parametrų skaičius? Ar reikšmės parametrus galima automatiškai keisti į norimo tipo parametrus?
			•	Jei tai masyvų tipai, ar sutampa matmenų skaičius? Ar reikšmės elemento tipą galima keisti į norimo tipo elementą?
			•	Ar reikšmės tipas paveldi iš norimo tipo?
			Jei netenkinama nei viena šių taisyklių, keitimas neleidžiamas ir rodoma klaida.
			Keičiant primityvius tipus, naudojama galimų keitimų lentelė.

			;;čia mano papaišyta nuostabi lentelė "assignment map.jpg"

			Šios taisyklės yra tranzityvios, t.y. jei uint8 galima keisti į int16, o int16 į int32, leidžiama ir uint8 keitimas į int32. Vienintelė išlyga reikalavimui dėl korektiškumo yra sveikųjų skaičių keitimas į realiuosius, nors tai gali neduodi tikslių rezultatų artėjant prie kraštutinių reikšmių, dėl paprastumo šis keitimas leidžiamas.

		2.2.4.2 Nurodomasis tipo keitimas

			Jeigu statiškai neįmanoma įrodyti keitimo korektiškumo, bet vartotojas žino, jog jis bus teisingas, galimas nurodomasis keitimas. Šiame keitime vartotojas nurodo tipą į kurį nori keisti. Kompiliatorius draudžia tik tuos nurodomuosius keitimus, kurie yra garantuotai neteisingi. 
			Turi būti patenkinta viena iš sąlygų:
			•	Vienas iš tipų gali būti automatiškai keičiamas kitu;
			•	Abu tipai yra primityvūs ir nei vienas jų nėra bool.

			Keitimai tarp bool ir kitų primityvių tipų nėra leidžiamas, nes rasta vykdymo greičio ar skaitomumo padidėjimų.
			;; kažkaip reikia parašyti kodėl bool neleidžiama

	2.2.5 Null reikšmės tipas

		null yra išskirtinė reikšmė tuo, kad ji neturi tipo. Ją gali įgyti bet koks nuorodinio tipo kintamasis.

	2.2.6 Automatinis tipo radimas

		LaborasLang palaiko ribotą automatinį tipų radimą. Deklaruojant kintamuosius galima nurodyti auto tipą. Tokioje deklaracijoje tipas bus randamas automatiškai, bet kintamąjį būtina inicializuoti.  Kompiliavimo metu kintamojo tipas nustatomas toks pat kaip inicializatoriaus. Pavyzdys:

		auto str = "text";

		ir

		string str = "text";

		Abi deklaracijos sukompiliuojamos į identišką kodą.

	2.3. Kintamieji

		LaborasLang palaiko trijų tipų kintamuosius: lokalius kintamuosius, globalius kintamuosius ir funkcijų parametrus. Pagrindiniai kintamųjų panaudojimo skirtumai yra jų galiojimo sritis.
		;; kiti skirtumai yra kur alokuojama, kada dealokuojama, gal šitą kada reikės parašyti

		2.3.1. Lokalūs kintamieji

			Lokalūs kintamieji yra kintamieji deklaruoti funkcijos viduje. Šių kintamųjų galiojimo sritis yra kodo blokas, kuriame jie buvo deklaruoti, su išlygomis. Kintamieji pradeda galioti nuo jų deklaracijos ir baigia uždarant jų bloką. Jeigu kintamojo galiojimo srityje yra deklaruota funkcija, iš šios funkcijos galima pasiekti kintamąjį, bet tik kaip skaitomą reikšmę.

		2.3.2. Globalūs kintamieji
		2.3.3. Funkcijų parametrai


	2.4. Išraiškos
		2.4.1. Literalai ;;include null
		2.4.2. Simboliai
		2.4.2. Indeksavimas
		2.4.3. Funkcijos
		2.4.4. Funkcijos kvietimai
		2.4.5. Priskyrimo operacija
		2.4.6. Vienanarės operacijos
			;;2.4.6.1. Aritmeninės operacijos
			;;2.4.6.2. Loginės operacijos
			;;2.4.6.3. Bitinės operacijos
			;;Joined
		2.4.7. Dvinarės operacijos
			2.4.7.1. Aritmetinės operacijos
			2.4.7.2. Loginės operacijos
			2.4.7.3. Bitinės operacijos
			2.4.7.4. Stūmimo operacijos
		2.4.8. Objektų kūrimas
		2.4.9. Klasių nariai
	2.5. Teiginiai
		2.5.1 Deklaracija
		2.5.2 use
		2.5.3 return
	2.6. Kontrolės blokai
		2.6.1. Kodo blokas
		2.6.2. Sąlygos sakiniai
		2.6.3. Ciklai ;;subskyriai ciklams
3. LaborasLang gramatika
	3.1. Programos apibrėžimas
	3.2. Leksinė gramatika
		3.2.1. Komentarai
		3.2.2. Raktiniai žodžiai
		3.2.3. Terminaliniai žetonai
	3.3. Sintaksinė gramatika
4. LaborasLang programų pavyzdžiai
5. Pavyzdinis kompiliatorius
	5.1. Komponentai
		5.1.1. Lekseris
		5.1.2. Parseris
		5.1.3. Kodo generatorius
	5.2. Testavimas
		5.2.1. Lekserio testavimas
		5.2.2. Parserio testavimas
		5.2.3. Kodo generatorius testavimas
			5.2.3.1. CIL kodo palyginimu grįsti testai
			5.2.3.2. Vykdymu grįsti testai
		5.2.4 Kontraktai/statinė analizė
	5.3. Vartotojo dokumentacija
		5.3.1. Išvesties tipai
		5.3.2. Bibliotekų nuorodos
		5.3.3. Šakninės direktorijos
6. Išvados
7. Literatūra