Programavimo kalba „LaborasLang“
Bakalauro baigiamasis darbas


Techininė užduotis
Autentiškumo patvirtinimas
Santrauka
Summary
Lentelių sąrašas
Terminų ir santrumpų žodynas ;; TO DO: sort by name

	Asemblis – failas, kuris yra LaborasLang programos kompiliavimo rezultatas. 
	CIL (Common Intermediate Language) – kalba, kurią supranta ir geba vykdyti CLI implementacijų vykdymo aplinkos.
	CLI (Common Language Infrastructure) – tai specifikacija, aprašanti virtualią vykdymo aplinką ir CIL kodą. CLI yra specifikuota ECMA-335 tarptautiniame standarte. Dvi populiariausios CLI implementacijos yra CLR (.NET karkaso dalis) ir Mono Runtime.
	LaborasLang programa – vienas ar daugiau išeities kodo failų, kurie nurodomi LaborasLang kompiliatoriui kaip duomenys. 
	Įeities taškas (entry point) – speciali funkcija, kuri yra iškviečiama paleidus vykdomąjį failą.
	Išraiška (expression) – kodo fragmentas, kurį įvykdžius galima gauti reikšmę, arba jam nustatyti reikšmę.
	Skaitoma išraiška (gettable expression, rvalue) – išraiška, kuri garantuotai grąžina reikšmę.
	Rašoma išraiška (settable expression, lvalue) – išraiška, kuriai galima nustatyti reikšmę.
	Lokalus kintamasis (local variable) – kintamasis deklaruotas funkcijoje.
	Globalus kintamasis (global variable) – kintamasis deklaruotas faile.
	Galiojimo sritis (scope) – taisyklės nusakančios kintamųjų pasiekiamumą.
	Sąveika (interoperability) – sistemos galimybė bendrauti su kitomis sistemomis. Kalbos kontekste tai yra galimybė naudoti resursus sukurtus kitomis kalbomis, taip pat kitose kalbose naudoti LaborasLang resursus.
	Blokas, kodo blokas – Kodo fragmentas apribotas simboliais „{“ ir „}“.
	Literalas (literal) – Kode įrašyta reikšmė.
	Vertės tipas (value type) – tipas, kurio kintamasis laiko reikšmę.
	Nuorodos tipas (reference type) – tipas, kurio kintamasis laiko nuorodą į reikšmę.
	Daugybinis tipas (generic type) – tipas turintis kelis daugybinius parametrus, galintis aprašyti kelis skirtigus tipus.
	Tipo pseudonimas (type alias) – papildomas vardas skiriamas tipui.
	Dantytas masyvas (jagged array) – masyvas sudarytas iš kitų masyvų.
	Automatinis tipo keitimas (implicit cast) – reikšmės tipas pagal poreikį keičiamas be vartotojo reikalavimo.
	Nurodomasis tipo keitimas (explicit cast) – reikšmės tipas keičiamas, nes taip nurodė vartotojas.
	Funkcijos parametras (function parameter) - funkcijos deklaruojamas kintamasis, kuris įgyja funkcijos argumento reikšmę. ;;geriau nemoku parašyti, bet niekas nežino kuo arg nuo param skirias
	Funkcijos argumentas (function argument) - reikšmė paduodama funkcijai.
	Vardų grupė (namespace) - ;; dunno, lol - D.
	PEG - parsing expression grammar ;; jei ką čia žemaitiškai o ne angliškai - A.
	Metaduomenys - 

Įvadas

	Ši specifikacija aprašo programavimo kalbą, pavadinimu „LaborasLang“. LaborasLang kalbos autoriai yra Andrius Dapševičius, Darius Lapūnas ir Tautvydas Žilys. 
	Pagrindiniai tikslai, keliami LaborasLang, yra:
	•	Esamiems programuotojams pažįstama sintaksė. Yra siekiama, kad programuotojai,  pažystami su bet kuria programavimo kalba, kurios sintaksė yra kilusi iš C kalbų šeimos, galėtų greitai išmokti programuoti su LaborasLang.
	•	Statinė tipų sistema. LaborasLang kompiliatorius turi sugebėti statiškai patikrinti tipų naudojimą.
	•	Funkcijos – pirmos klasės nariai. LaborasLang programavimo kalboje, funkcijas galima naudoti lygiai taip pat, kaip ir bet kurį kitą duomenų tipą.
	•	Paprastumas. Vienas iš LaborasLang uždavinių – būti kuo įmanoma paprastesnei.
	•	Vykdymo greitis. LaborasLang kalba parašytos programos turi galėti efektyviai išnaudoti kompiuterio resursus. ;;Ar čia kalbos ar implementacijos dalis? A.
	•	Sąveika su kitomis programavimo kalbomis. LaborasLang kalba parašytos programos turi galėti naudotis bibliotekomis, kurios yra parašytos kitomis .NET programavimo kalbomis. Dėl šios priežasties, LaborasLang programos yra kompiliuojamos į CIL. Taip pat bibliotekos parašytos LaborasLang turi veikti kitose .NET kalbose.


1. Apimtis ;;siūlau Specifikacijos apimtis A.

	Ši specifikacija apibrėžia LaborasLang programavimo kalbą. Tai apima:
	•	LaborasLang kalbos leksinę ir sintaksinę gramatiką;
	•	LaborasLang kalbos semantiką;
	•	LaborasLang kalbos apribojimus.
	Kartu su specifikacija pateikiamas pavyzdinio LaborasLang kalbos kompiliatoriaus aprašas.

2. LaborasLang apžvalga
	LaborasLang yra statiškai tipuojama, procedūrinė, kompiliuojama, bendros paskirties programavimo kalba, turinti funkcinio programavimo elementų. Šis skyrius aprašo pagrindines LaborasLang kalbos savybes.

	2.1. Pirmoji LaborasLang programa

		Pavyzdinė „Hello, world“ programa LaborasLang kalboje gali būti užrašoma taip:

			use System;

			entry auto HelloWorld = void()
			{
				Console.WriteLine("Hello, world!");
			};

		Išnagrinėkime šią programą po eilutę:
		•	Sakinys  use System; nurodo, jog šiame faile tipai ir vardų grupės iš System vardų grupės bus tiesiogiai pasiekiami.
		•	entry auto HelloWorld = void() šioje eilutėje yra deklaruojamas kintamasis HelloWorld. Šiam kintamajam yra priskiriama funkcija, kurios tipas – void(). Kadangi kintamojo deklaravimo metu jam yra priskiriama reikšmė, tai jo tipą galima nustatyti automatiškai – tai nurodo specialus tipas auto. Raktinis žodis entry nurodo, jog šis kintamasis yra programos įeities taškas.
		•	{ pažymima funkcijos pradžia.
		•	Console.WriteLine("Hello, world!"); iškviečiama funkcija WriteLine esanti Console tipe. Tai yra standartinė CLI funkcija.
		•	}; pažymima funkcijos pabaiga ir užbaigiamas priskyrimo sakinys.


2.2. Tipai

	LaborasLang palaiko dviejų rūšių tipus: vertės tipus ir nuorodinius tipus. Vertės tipai, skiriasi nuo nuorodinių tipų tuo, kad jie 
	savyje laiko reikšmę. Nuorodiniai tipai laiko nuorodą į reikšmę. Dvi nuorodos gali rodyti į tą pačią reikšmę, o reiškia, kad 
	pakeitimai per vieną nuorodą gali atsirasti kitoje. Tai neįmanoma su vertės tipais, nes vertės tipo kintamieji turi savo reikšmės kopiją. Pavyzdžiui:

		use System;
		use System.Runtime.InteropServices.ComTypes;
		use System.Text;

		entry auto MyFunction = void()
		{
			FILETIME value;
			value.dwLowDateTime = 15;

			auto reference = StringBuilder("Laboras");

			Console.WriteLine(value.dwLowDateTime);
			Console.WriteLine(reference);

			auto valueCopy = value;
			valueCopy.dwLowDateTime = 20;

			auto referenceCopy = reference;
			referenceCopy.Append("Lang");

			Console.WriteLine(value.dwLowDateTime);
			Console.WriteLine(valueCopy.dwLowDateTime);

			Console.WriteLine(reference);
			Console.WriteLine(referenceCopy);
		};

	Ši programa atspausdina:

		15
		Laboras
		15
		20
		LaborasLang
		LaborasLang

	Visi palaikomi CLI tipai paveldi iš System.Object. Reikšmės tipai paveldi iš System.ValueType, kuris paveldi iš System.Object. 
	LaborasLang taip pat palaiko sąsajos tipus, kurių objektai gali būti vertės arba nuorodiniai tipai, priklausomai nuo realizacijos.

	2.2.1. Fundamentalieji tipai

		LaborasLang turi keletą fundamentaliųjų tipų, kurie atitinka fundamentaliuosius CLI tipus:

		;; c# ref rašo .NET Framework type, ne CLI type - D.
		Tipo vardas	     CLI tipo atitikmuo	     Pastabos
		bool	         System.Boolean	         Loginis tipas, galintis laikyti 2 reikšmes: true ir false.
		int8	         System.SByte	         1 baito dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-128; 127].
		uint8	         System.Byte	         1 baito dydžio sveikasis skaičius be ženklo, Galimos reikšmės: [0; 255].
		int16	         System.Int16	         2 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-32768; 32767].
		uint16	         System.UInt16	         2 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 65535].
		char	         System.Char	         2 baitų dydžio simbolio tipas.
		int32, int	     System.Int32	         4 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės: [-2147483648; 2147483647].
		uint32, uint	 System.UInt32	         4 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 4294967295].
		int64, long	     System.Int64	         8 baitų dydžio sveikasis skaičius su ženklu. Galimos reikšmės:  [–9,223,372,036,854,775,808; 9,223,372,036,854,775,807].
		uint64, ulong	 System.UInt64	         8 baitų dydžio sveikasis skaičius be ženklo. Galimos reikšmės: [0; 18,446,744,073,709,551,615].
		float	         System.Single	         4 baitų dydžio slankaus kablelio skaičius, atitinkantis IEC 60559:1989 standartą.
		double	         System.Double	         8 baitų dydžio slankaus kablelio skaičius, atitinkantis IEC 60559:1989 standartą.
		void	         System.Void	         Tipas neturintis reikšmės. Naudojamas pažymėti, jog funkcija negražina rezultato.
		object	         String.Object	         Objektas – fundamentaliausias tipas. Jis gali laikyti bet kurio kito tipo reikšmes.
		string	         System.String	         Simbolių eilutės tipas.

		Fundamentalieji tipai išskyrus void, object ir string yra taip pat vadinami primityviaisiai tipais. Jie yra naudojami atliekant 
		standartines operacijas ir sudaro kitus CLI tipus. 
		;;might be BS, bet kažkaip noriu parašyti kad yra primitives. paskui primitives naudoju apie castus rašydamas

		Fundamentaliųjų tipų vardai yra pseudonimai CLI tipams ir jie yra kompiliavimo metu verčiami į tikruosius tipus.
		Todėl:

		string foo;
		ir 
		System.String foo;

		yra sukompiliuojami į identišką kodą.

	2.2.2 Vardų erdvė ir pilnas vardas

		Tipo pilnas vardas yra sudaromas iš jo vardų grupės ir vardo atskirtu tašku. Pavyzdžiai:

			Pilnas vardas                  Vardų grupė          Vardas
			System.Collections.ArrayList   System.Collections   ArrayList
			System.String                  System               String
			System.IO.File                 System.IO            File

		Vardų grupės turi dvi funkcijas: suskirstyti tipus pagal paskirtį ir leisti keliem tipam turėti tą patį vardą. Kadangi 
		tipo identifikatorius yra jo pilnas vardas, keli tipai gali turėti tą patį vardą, kol jų vardų grupės skiriasi. Sakoma, 
		kad tipas String priklauso vardų grupei System. Taip pat vardų grupė Collections priklauso vardų grupei System.

	2.2.2. Funkcijų tipai

		LaborasLang kalboje, funkcijų tipus apibrėžia funkcijos gražinamas tipas ir jos priimamų argumentų tipai. 
		Pilna funkcijos tipo sintaksė yra:

		<grąžinamas tipas>(<parametrų tipai atskirti kableliais>)

		Ir grąžinamas tipas, ir parametrų tipai gali būti bet kokie LaborasLang palaikomi tipai. Keletas funkcijų tipų pavydžių:

		void() – funkcija negrąžina rezultato ir nepriima jokių argumentų.

		void(int, double) - funkcija negrąžina jokio rezultato, ir priima du argumentus, kurių tipai yra int ir double.

		string(string, string()) - funkcija grąžina rezultatą, kurio tipas yra string, ir priima du argumentus, kurių tipai yra string ir 
		funkcija, kuri grąžina string tipo rezultatą.

		int[](System.Collections.IList) - funkcija grąžina masyvą, kurio elemento tipas yra int, ir priima vieną argumentą, kurio tipas 
		yra System.Collections.IList.

		void tipas gali būti naudojamas tik kaip funkcijos gražinamas tipas. C stiliaus sintaksė int(void), kurioje void parametrų sąraše 
		reikšdavo parametrų nebuvimą nėra leidžiama, tam yra naudojamas tuščias parametrų sąrašas.

		Kadangi funkcijos yra pirmos klasės nariai, funkcijos taip pat gali gražinti kitas funkcijas. Pavyzdys: 

		string()() - funkcija, kuri gražina string() tipo funkciją ir neima jokių argumentų.

		Funkcijų tipams yra naudojamos kompiliatoriaus generuotos klasės, kurių tiksli realizacija gali priklausyti nuo kompiliatoriaus. Taip 
		funkcijos gali be jokių papildomų išlygų tapti tipų sistemos dalimi.

		;; compiler spece reiktų parašyti tą tikslią realizaciją, tipo jei kas norės su laboraslang interopintis

		;; IMO, čia visai ne į temą. skyrius vadinasi Funkcijų tipai, o rašai apie calls, higer order functions ir panašius dalykus
		;; galima parašyti "daugiau apie funkcijas ir funkcijų tipus skyriuje Funkcijos"

		;; Aš manau, jog čia tam sakiniui apie implementacija tikrai ne vieta - T.

		Funkcija, kurią laiko funkcijos tipo kintamasis, yra iškviečiama šalia kintamojo parašant skliausteliuose argumentus, atskirtus kableliais. Pavyzdžiui:
		void(int, double) myVariable = someFunction;
		myVariable(3, 5.8);

		Funkcijų tipus galima naudoti perduodant funkcijas kaip argumentus kitoms funkcijoms: ;;Patogu - šališka nuomonė, nėra įrodymo kad patogu ar ne. A.

			int(int()) GetFunctionResultPlusOne = int(int() function)
			{
				return function() + 1;
			};

			void() PrintSix = void()
			{
				Console.WriteLine(GetFunctionResultPlusOne(int() { return 5; }));
			};

		;; TO DO: Parašyti, kad funkcijos tipas kitose CLI kalbose turi "Invoke" metodą, kuris iškviečia funkciją, grąžino jos grąžinamą reikšmę ir priima tokius pačius argumentus.

	2.2.3. Masyvų tipai

		LaborasLang palaiko masyvų kūrimą iš visų palaikomų tipų. Masyvo tipą sudaro elemento tipas ir matmenų skaičius, visi masyvai yra 
		indeksuojami nuo nulio. Tipų sistema nedengia masyvo matmenų ilgio, tik jų skaičių. Skaičius deklaruojamas kableliais tarp laužtinių 
		skliaustų. Gautas masyvas turės vienu matmeniu daugiau negu tipe yra kablelių. 

		Masyvo tipas yra nuorodos tipas, vieno matmens masyvai atitinka CLI vektoriaus specifikaciją, kelių matmenų masyvai (matricos) atitinka 
		CLI masyvo specifikaciją. Maksimalus masyvo matmenų skaičius yra 32. 

		<elemento tipas>[<matmenų skaičiaus deklaracija>]

		Pavyzdžiai:
		int[] //vienmatis int masyvas
		float[,] //dvimatis float masyvas
		System.Version[,,] // Trimatis versijų masyvas

		Taip pat, galima deklaruoti funkcijų masyvus.

		int(int)[]

		Arba masyvus sudarytus iš kitų masyvų (t.y. dantytus masyvus).

		int[][]

		Kadangi dantytą masyvą sudaro tik nuorodos į kitus masyvus, tokio masyvo matmenų ilgis yra neribojamas. Maksimalus įmanomas matmenų 
		skaičius priklauso nuo kompiliatoriaus realizacijos, taip pat nuo veikimo aplinkos (kompiliatoriaus ir gautos programos).

	2.2.4. Tipų keitimas

		LaborasLang tipų sistema nėra griežta, norint galima keisti reikšmių tipus, bet kompiliatorius užtikrina keitimo korektiškumą jei 
		tai yra įmanoma. Kadangi korektiškumą garantuoti yra įmanoma tik labai retais atvejais ir naudojant sudėtingą statinę analizę, 
		kompiliatorius leidžia tik akivaizdžiai teisingus keitimus.

		Tipo keitimas yra reikalingas keliose situacijose. Pirma, yra daug sveikųjų skaičių tipų, kurie visi laiko tą pačią informaciją 
		panašiu formatu. Taip galima pasirinkti geriausią tipą, bet gali reikėti keitimų perduodant duomenis. Antra, objektinis programavimas 
		reikalauja keitimų. Su keitimais objektų tipai neturi atitikti kintamųjų tipų, užtenka, kad paveldėtų jų tipus. 

		Yra naudojami du keitimų tipai: automatinis keitimas ir nurodomasis keitimas.

		2.2.4.1 Automatinis tipo keitimas

			Kai kuriais atvejais nesutampa reikšmės tipas ir reikalaujamas tipas, bet kompiliatorius gali nustatyti, kad keitimas galimas. Keitimo pagrindinės taisyklės:
			•	Jei tipai vienodi, keitimas nereikalingas. 
			•	Jei tai primityvūs tipai, ar norimas tipas gali įgyti visas keičiamo tipo reikšmes.
			•	Jei tai yra funkcijų tipai, ar sutampa parametrų skaičius? Ar reikšmės parametrus galima automatiškai keisti į norimo tipo parametrus?
			•	Jei tai masyvų tipai, ar sutampa matmenų skaičius? Ar reikšmės elemento tipą galima keisti į norimo tipo elementą?
			•	Ar reikšmės tipas paveldi iš norimo tipo?
			Jei netenkinama nei viena šių taisyklių, keitimas neleidžiamas ir rodoma klaida.
			Keičiant primityvius tipus, naudojama galimų keitimų lentelė.

			;;čia mano papaišyta nuostabi lentelė "assignment map.jpg"

			Šios taisyklės yra tranzityvios, t.y. jei uint8 galima keisti į int16, o int16 į int32, leidžiama ir uint8 keitimas į int32. 
			Vienintelė išlyga reikalavimui dėl korektiškumo yra sveikųjų skaičių keitimas į realiuosius, nors tai gali neduodi tikslių 
			rezultatų artėjant prie kraštutinių reikšmių, dėl paprastumo šis keitimas leidžiamas.

		2.2.4.2 Nurodomasis tipo keitimas

			Jeigu statiškai neįmanoma įrodyti keitimo korektiškumo, bet vartotojas žino, jog jis bus teisingas, galimas nurodomasis keitimas. 
			Šiame keitime vartotojas nurodo tipą į kurį nori keisti. Kompiliatorius draudžia tik tuos nurodomuosius keitimus, kurie yra garantuotai neteisingi. 
			Turi būti patenkinta viena iš sąlygų:
			•	Vienas iš tipų gali būti automatiškai keičiamas kitu;
			•	Abu tipai yra primityvūs ir nei vienas jų nėra bool.

	2.2.5 Null reikšmės tipas

		null yra išskirtinė reikšmė tuo, kad ji neturi tipo. Ją gali įgyti bet koks nuorodinio tipo kintamasis.

	2.2.6 Automatinis tipo radimas

		LaborasLang palaiko ribotą automatinį tipų radimą. Deklaruojant kintamuosius galima nurodyti auto tipą. Tokioje deklaracijoje tipas 
		bus randamas automatiškai, bet kintamąjį būtina inicializuoti. Kompiliavimo metu kintamojo tipas nustatomas toks pat kaip inicializatoriaus. Pavyzdys:

			auto str = "text";

		ir

			string str = "text";

		Abi deklaracijos sukompiliuojamos į identišką kodą.

	2.3. Kintamieji

		LaborasLang palaiko trijų tipų kintamuosius: lokalius kintamuosius, globalius kintamuosius ir funkcijų parametrus. Pagrindiniai 
		kintamųjų panaudojimo skirtumai yra jų galiojimo sritis.
		;; kiti skirtumai yra kur alokuojama, kada dealokuojama, gal šitą kada reikės parašyti

		2.3.1. Lokalūs kintamieji

			Lokalūs kintamieji yra kintamieji deklaruoti funkcijos viduje. Šių kintamųjų galiojimo sritis yra kodo blokas, kuriame jie buvo 
			deklaruoti, su keliomis išlygomis. Kintamieji pradeda galioti nuo jų deklaracijos ir baigia uždarant jų bloką. Jeigu kintamojo 
			galiojimo srityje yra deklaruota funkcija, iš šios funkcijos galima pasiekti kintamąjį, bet tik kaip skaitomą reikšmę.

		2.3.2. Globalūs kintamieji

			Deklaruojant kintamajį tiesiogiai faile, bus sukuriamas globalus kintamasis. Tokio kintamojo galiojimo sritis yra visas failas, 
			juo galima naudotis anksčiau negu jis yra deklaruotas. Kintamajį, priklausomai nuo deklaracijos, taip pat galima pasiekti iš 
			kitų failų. Plačiau apie tai skyriuje "Atributai".

		2.3.3. Funkcijų parametrai

			Funkcijos deklaraciją sudaro jos parametrai. Šie parametrai yra kintamieji, kurie įgis funkcijai perduotų argumentų reikšmes. 
			Parametrų galiojimo sritis yra visas funkcijos blokas, bet jų panaudojimas nesiskiria nuo lokalių kintamųjų.

	2.4. Išraiškos

		;; man dabar skaitoma/rašoma išraiška nepatinka. gal kas sugalvosit geriau - D.
		Išraiška yra kodo framgentas, kurios gali gražinti reikšmę, arba priimti reikšmę. Išraiškos, kurios gražina reikšmę, dar vadinamos 
		skaitomomis išraiškomis. Dauguma išraiškų yra skaitomos. Išraiškos, kurios gali priimti reikšmę vadinamos rašomomis išraiškomis. 
		Rašomomis išraiškomis gali būti yra simboliai, klasių nariai ir indeksavimas. Ar išraiška yra skaitoma arba rašoma priklauso nuo 
		išraiškos. Šios taisyklės tiksliai aprašomos prie kiekvieno išraiškos tipo.

		2.4.1. Literalai

			Literalai yra reikšmės įrašytos kode. Literalai yra tik skaitomos išraiškos.

			2.4.1.1 Loginiai literalai

				Reikšmės "true" ir "false" yra loginiai literalai. Jie gali būti naudojami kaip "bool" tipo skaitomos išraiškos.

			2.4.1.2 Sveikųjų skaičių literalai.

				;; gal reikia užsimint apie visokius u, l. visa informacija apie tai ką lexer 
				;; laiko sveikuoju skaičiumi eina į lexer dalį, bet čia reikia parašyti, kad tipą gali pakeisti - D.
				Sveikųjų skaičių literalo įgyjamas tipas priklauso nuo skaičiaus dydžio ir jo ženklo. 

					uint8 a = 5;
					int16 b = -20000;
					uint16 c = 70000;// klaida, skaičius netelpa į uint16

				Literalo įgyjami tipai priklauso nuo tipų maksimalių ir minimalių reikšmių (žr. sk. $2.2.1). Šias reikšmes galima apskaičiuoti arba 
				gauti iš tipų sąvybių MinValue ir MaxValue.

				;; Dariau, gal gali aprašyt tiksliai kaip tai veiks? Būtų gerai atitikti parserio implementaciją - T.

				Standarinis tipas yra "int". Šis tipas yra naudojamas jei nėra žinomas reikalingas tipas. Tipas 
				nėra žinomas dviem atvejais - jei naudojama deklaracija su inicializacija ir jei kviečiama perdengta funkcija.

					auto foo = void(int a){};
					auto foo = void(long a){};

					foo(5);

				Bus iškviesta pirmoji funkcija. Norint iškviesti antrają, reikia rašyti 

					foo((long)5);

			2.4.1.3 Realiųjų skaičių literalai

				Realieji skaičiai gali įgyti tipus "float" ir "double". Įgyjamas tipas priklauso nuo skaičiaus užrašymo.
				;; turbūt prie gramatikos reiktų specifikuoti - D.

			2.4.1.4 Tekstiniai literalai

				Tekstiniai literalai turi du tipus - "string" ir "char". Įgyjamas tipas priklauso nuo naudojamų kabučių.
				;; taip pat mažoka, bet gramatikoj bus aprašyta - D.

			2.4.1.5 Null literalas

				"null" reikšmė taip pat laikoma literalu. Šis literalas tipo neturi ir gali įgyti bet kokį nuorodinį tipą.
				;; C# daro kažkoius hackus, kad Nullable veiktų? Mes juos palaikom? - D
				;; Nedaro jokiu hackų. Nullable<T> yra generic type. Mes jų nepalaikom - T.
				;; Gal ne taip supratau, bet mačiau apie tai ECMA-334 13.7.2 skyriuje kažką - D.
				;; Nu, C# tiesiog int? išverčia į Nullable<int> - T.

		2.4.2 Nario išraiška

			Išraiška naudojama pasiekti vardų grupės ar tipo narį. 

			<pagrindinė išraiška>.<identifikatorius>

			Šios sintaksės rezultatas gali būti kelios skirtingos išraiškos, priklausomai nuo pagrindinės išraiškos ir identifikatoriaus.
			Galimos išraiškos:

				* vardų grupė. Išraiška gaunama jei pagridninė išraiška kartu su identifikatoriumi sudaro vardų grupę arba jos fragmentą. 
				Tokią išraišką galima panaudoti kaip pagrindinę nario išraišką arba "use" teiginyje.

				* tipas. Išraiška gaunama jei:
					* pagrindinė išraiška yra vardų grupė ir joje deklaruotas tipas, kurio vardas sutampa su identifikatoriumi.
					* pagrindinė išraiška yra tipas, kuriame deklaruotas tipas, kurio vardas sutampa su identifikatoriumi.
				 Tipo išraiška taip pat turi ribotą panaudojimą:
					* kaip pagrindinė nario išraiška
					* deklaracijos tipas
					* kūriamo objekto tipas
					* kūriamo masyvo tipas
					* sudėtinio tipo dalis ;; function types, array tipes, nežinau kaip kitaip pavadinti - D.

				* laukas. Išraiška gaunama jei:
					* pagrindinė išraiška yra tipas. Šiuo atveju pasiekiami statiniai laukai, atitinkantys identifikatorių.
					* pagrindinė išraiška yra reikšmė. Šiuo atveju pasiekiami nestatiniai laukai.
				 Laukai yra visada skaitomi. Laukas yra rašomas jei nėra deklaruotas su atributu "readonly" [ECMA-335 III.2.3]. 

				* metodas. Išraiška gaunama taip pat kaip laukas, bet metodai yra tik skaitomi. Naudojant metodą kaip išraišką, 
				jis yra keičiamas funkcijos kintamuoju.

				* metodų grupė. Išraiška gaunama tada jei tipas turi kelis metodus tuo pačiu vardu. Šią išraišką reikia sukonkretinti taip, 
				kad būtų parinktas vienas iš metodų. Tam yra du būdai:
					* metodo kvietimas. Pagal argumentus bus parinktas reikiamas metodas, arba gražinama klaida jei tokio metodo nėra.
					* panaudojimas kitose išraiškose. Jei išraiška reikalaja tam tikro tipo, bus parinktas tinkantis metodas arba gražinama 
					klaida, jei tokio nėra.
				 Kadangi metodų grupė neturi konkretaus tipo, ji negali būti naudojama deklaracijos inicializacijoje su tipu "auto".
				 Sukonkretinus metodų grupę ji tampa metodo išraiška.

				* sąvybė. Sąvybė gaunama kaip laukas. Sąvybė yra rašoma ir skaitoma jei pasiekiami "set" ir "get" metodai atitinkamai.

		2.4.2 Nario išraiška

			Išraiška naudojama pasiekti vardų grupės ar tipo narį. 

			<pagrindinė išraiška>.<identifikatorius>

			Šios išraiškos rezultatu laikomas tipo arba vardų grupės narys, kurio vardas atitinka nurodytą identifikatorių. Yra trys šios išraiškos apdorojimo variantai:

				* pagrindinė išraiška yra vardų grupė. Šioje grupėje ieškoma tipo arba grupės, kurie atitinka identifikatorių.
				* pagrindinė išraiška yra tipas. Tipe ieškoma statinių narių, kurie atitinka identifikatorių.
				* pagrindinė išraiška yra reikšmė. Reikšmės tipe ieškoma nestatinių narių, kurie atitinka identifikatorių.

			Jei tipo narys turi apribotą pasiekiamumą ir nėra pasiekiamas iš failo, kuriame rašoma išraiška, gražinama klaida.
			;; kažkur gal reikia parašyti apie visus access apribojimus, gal prie tipų sistemos - D.
				
		2.4.3. Pavieniai identifikatoriai

			;; gramatikoj turėtų būti specifikuota kas yra identifikatorius - D.
			Naudojant identifikatorių kaip išraišką atliekama paieška pagal galiojimo sritį:

				1. Jei identifikatorius nėra naudojamas funkcijos viduje einama į punktą 4
				2. Ieškoma tarp lokalių kintamųjų. Kodo bloke neradus identifikatoriaus, paieška tesiama aukštesniame bloke kol pasiekiamas 
				aukščiausias funkcijos blokas. Šiame žingsnyje taip pat apimami "for" ciklų kintamieji.
				3. Ieškoma funkcijos parametro.
				4. Ieškoma globalaus kintamojo.
				5. Ieškoma importuotos vardų srities.
				6. Ieškoma importuoto tipo.
				7. Ieškoma vardų grupės.
				8. Ieškoma tipo.

			Tipus galima pasiekti kaip pavienius identifikatorius jei:
				* Jie nėra deklaruoti su vardų grupe arba kitame tipe.
				* Jie yra deklaruoti importuotoje vardų grupėje.

			Vardų grupes galima pasiekti kaip pavienius identifikatorius jei:
				* Jos nėra deklaruotos kitoje vardų grupėje.
				* Jos yra deklaruotos importuotoje vardų grupėje.

			Šiuo būdu gautos tipo ar vardų grupės išraiškos yra aprašytos skyriuje Nario išraiška.

		2.4.4. Indeksavimas
			2.4.2.x Masyvo indeksavimas
			2.4.2.x Indekso operatorius
		2.4.5. Funkcijos
		2.4.6. Funkcijos kvietimai
			2.4.4.x Funkcijos objekto kvietimas ;; LL functors, Func
			2.4.4.x Metodo kvietimas

		;; Čia reikia nepamiršti paminėti tail calls

		2.4.7. Priskyrimo operacija ;; parašyt kas būna kai dešinėj yra metodas
		2.4.8. Vienanarės operacijos
			;;2.4.6.1. Aritmeninės operacijos
			;;2.4.6.2. Loginės operacijos
			;;2.4.6.3. Bitinės operacijos
			;;Joined
		2.4.9. Dvinarės operacijos
			2.4.7.1. Aritmetinės operacijos
			2.4.7.2. Loginės operacijos
			2.4.7.3. Bitinės operacijos
			2.4.7.4. Stūmimo operacijos
		2.4.10. Objektų kūrimas
		2.4.11. Masyvų kūrimas
	2.5. Teiginiai

		;; kaip parašyti kas yra teiginys - D?

		2.5.1 Deklaracija

			;; Šitas skyrius labai išsipūtė, gal ką praleidau - D.

			Deklaracijos teiginys yra naudojamas deklaruojant kintamajį.

				<atributai> <tipas> <identifikatorius>;
				<atributai> <tipas> <identifikatorius> = <inicializatorius>;

			Atributai yra sąrašas atributų atskirtų tarpais, palaikomi atributai priklauso nuo kintamojo tipo. Atributus galima praleisti.

			Tipas yra bet koks palaikomas tipas išskyrus "void".

			Identifikatorius yra bet koks legalus simbolis. ;; reiktų kokio link į lexer skyriu kas yra legalus simbolis - D.

			Inicialiatorius yra bet kokia skaitoma išraška.

			Pavyzdžiai:

				int a; // "int" tipo kintamasis be inicializacijos
				float b = 5; // "float" tipo kintamasis su inicializacija
				string str = null; // teksto eilutė inicializuojama "null" reikšme.
			
				// funkcijos kintamasis su inicializacija
				int(int) incrementer = int(int num)	
				{
					return num + 1;
				};

			Verta atkreipti dėmesį, jog po funkcijos bloko uždarymo yra ";". Funkcijos deklracija nėra kontrolės blokas ir jis, kaip visi 
			įprasti teiginiai yra baigiamas ";".
			;; pats šitą klaidą padariau ne kartą - D.

			Inicializuojant deklaraciją, jos tipą galima nustatyti "auto". Tada kintamojo tipas bus toks pat kaip inicializatoriaus išraiškos. 

			auto numbers = int[5];
			auto sudoku = void() { sudoku(); };	
			;; Ar pažiūrėjai, kad buildintųsi? Aš galvojau toks capture neveikia.
			;; yes, jei tai global var. O jei ir ne, šitas spece tinka, nes pagal spec veikia capture - D.

			;; čia dubliuojasi su skyriumi Automatinis tipo radimas, galvosiu kaip keisti - D.
			Deklaruojant "auto" tipą taikomi du apribojimai:
			* Deklaracija privalo būti inicializuota.
			* Inicializatorius negali būti "null", kadangi "null" neturi tipo.

			Jei nesilaikoma vieno iš šių apribojimų, kintamojo tipo nustatyti neįmanoma ir yra gražinama klaida.

				auto foo; // klaida
				auto bar = null; // klaida

			Norint papildomai apriboti kintamuosius, deklaracijoje galima jiems pridėti atributus. LaborasLang turi dvi atributų rūšis - 
			pasiekiamumo ir kintamumo. Pasiekiamumo atributai apriboja kintamojo galiojimo sritį, o kitamumo leidžia kintamajį padaryti 
			konstanta. Deklaracijoje galima pridėti po vieną kiekvienos rūšies atributą. Nepridėjus atributo rūšies bus nustatoma 
			standartinis atributas, kuris priklauso nuo deklracijos.

			2.5.1.1 Kintatumo atributai

				Yra du priešingi kintamumo atributai: const ir mutable. const padaro kintamajį konstanta, o mutable atvirkščiai - pažymi, 
				jog kintamajo reikšmė gali kisti. Konstantoms negalima priskirti reikšmės ir jas būtina inicializuoti. 

					const int a = 5;
					a = 6; // klaida, a reikšmę galima tik skaityti

					mutable int b = 7;
					b = 8; // reikšmę galima ir skaityti ir rašyti

					const int c; // klaida, konstantas būtina inicializuoti

				Standartinis atributas yra mutable, išskrus vieną atvejį. Globalūs funkcijų tipo kintamieji yra deklaruojami su const atributu. Tokia 
				taisyklė leidžia funkcijų perdengimą ir kelias optimizacijas. Norint gauti globalų funkcijos kintamajį, kuris nėra konstanta, 
				būtina deklarauotį jį su mutable atributu. 

					void() foo; // klaida, jei tai globalus kintamasis

					mutable void() foo; // šis kodas veikia

				Kintamumo atributai yra palaikomi lokalių ir globalių kintamųjų. 
				;; Koks tas atvejis kai kintamasis yra ne mutable by default? A.
				;; global functors, nes tada kompiliuojam į metodus. greičiau veikia ir galima naudoti overloading - D.

				
			2.5.1.2 Pasiekiamumo atributai

				Pasiekiamumo atributai naudojami apriboti globalių kintamųjų galiojimo sritį. Yra du pasiekiamumo atributai - private ir public. 
				private kintamieji yra pasiekiami tik iš failo kuriame yra deklaruoti, public kintamieji yra pasiekiami iš bet kurio failo. 
				Standartinis atributas yra private. 

				public auto foo = 5;
				private auto bar = 6;

				Pasiekiamumo atributai leidžiami tik globaliems kintamiesiems.

			2.5.1.3. Atributų kombinavimas

				Atributus galima kombinuoti. 

					public const int MAX_COUNT = 200;

				Bet deklaracijoje gali būti tik po vieną atributą iš kiekvieno tipo.

					public private int a; // klaida
					public public int b; // kompiliatoriui nereikia kartoti dalykų

		2.5.2 Vardų grupės importavimo ;; Gal kas geriau sugalvosit - D.

			Importavimo teiginys naudojamas į failo galiojimo sritį įterptį vardų grupes ir tipus iš kitos vardų grupės.

				use <vardų grupė>;

			Vardų grupė privalo būti pilna vardų grupė iš naudojamų asemblių.

			Po šio teiginio galima visus tipus ir vardų grupes iš nurodytos vardų grupės pasiekti tiesiogiai, nerašant importuotos grupės.

				use System;

				String a;
				Collections.ArrayList lst;

			yra analogiška

				System.String a;
				System.Collections.ArrayList lst;

			Importavimo teiginiai leidžiami tik faile. ;; Kaip kitaip parašyti - D?
			Faile gali būti neribotas skaičius importavimo teiginių.

			Nors teiginys importuoja ir vardų grupes, importavimo teiginyje privaloma rašyti pilną vardų grupę, net jei ji pasiekiama trumpiau per kitą teiginį.

				use System;
				use Collections; // klaida, nėra tokios vardų grupės
				use System.Collections; // Toks teiginys veikia

			Kompiliavimo metu importuoti tipai keičiami pilnais tipų vardais. Importavimas, kaip ir tipų pseudonimai, yra pagalbinė kompiliatoriaus funkcija. 
			Šių sakinių naudojimas visiškai neįtakoja gaunamo kodo veikimo.

		2.5.3 Grįžimo teiginys

			"return" teiginys naudojamas baigti funkcijos darbą. 

				return;
				return <reikšmė>;

			"return" sakinio tipas privalo atitikti funkcijos gražinamą tipą. Jei gražinas "void" tipas, leidžiamas tik tuščias "return" sakinys. Toks sakinys naudojamas tik užbaigti funkcijos darbą. "void" tipo funkcijos gali neturėti "return" sakinio, jų darbas bus baigtas pasiekus funkcijos bloko galą. 

			Jei funkcijos tipas nėra "void", ji privalo gražinti reikšmę, todėl privalomas bent vienas "return" sakinys su reikšme. Šios reikšmės tipas turi atitikti funkcijos tipą, arba turi egzistuoti automatinis keitimas iš reikšmės į funkcijos gražinamą tipą.

			Norint užtikrinti, jog funkcija tikrai gražins reikšmę, kompiliatoriuje įvedama gražinančio teiginio sąvoka.

			Teiginys gražina jei:
			* tai yra "return" teiginys
			* tai yra kodo blokas ir bent vienas jo teiginių gražina
			* tai yra sąlygos sakinys, jis turi abi atšakas ir jos abi yra gražinantys blokai

			Jei funkcijos blokas nėra gražinantis blokas, kompiliatorius gražina klaidą.

			Pavyzdžiai:

				// teisingas kodas, funkcijai nereikalingas return sakinys
				void()
				{
					int a = 5;
				}

				// klaida, ši funkcija negali gražinti
				void()
				{
					return 5;
				}

				// klaida, funcija negražina reikšmės
				int()
				{
					int a = 5;
				}

				// teigingas kodas, abi šakos gražina reikšmę
				int()
				{
					int a = GetNum();
					if (a > 6)
					{
						return a - 1;
					}
					else
					{
						return a + 1;
					}
				}

				// klaida, viena iš šakų negražina reikšmės
				int()
				{
					int a = GetNum();
					if (a > 6)
					{
						return a - 1;
					}
					else
					{
						a++;
					}
				}

				// klaida, viena iš šakų negražina reikšmės
				int()
				{
					int a = 5;
					if (a > 0)
					{
						return a;
					}
					else
					{
						a++;
					}
				}

			Šis kodo fragmentas parodo sistemos trūkumą. Nors jūs esatę įsitikinę, kad funkcija gražins reikšmę, kompiliatorius naudoja 
			paprastą analizę, kuri negali garantuoti šio fakto. Tokiu atveju tenka naudoti "return" sakinius, kurie niekada nebus įvykdyti.

		2.5.4 Tuščias teiginys

			Tuščią teiginį sudaro tik kabliataškis. Toks teiginys nedaro nieko ir gali būti naudojamas ten, kur sintaksė reikalauja teiginio, 
			bet nenorite nieko atlikti.

		2.5.5 Išraiškos teiginys

			Išraiškos teiginį sudaro pati išraikša ir kabliataškis:

				<išraiška>;

			Bet kokia išraiška taip pat gali būti panaudota kaip teiginys. Tokia išraiška bus įvykdyta ir jos gražinama reikšmė atmesta.

	2.6. Kontrolės blokai

		Kontrolės blokai yra teiginiai naudojami valdyti programos vykdymo seką. Kontrolės blokai gali būti panaudoti tik kodo bloko viduje.

		2.6.1. Kodo blokas

			LaborasLang kodo blokai sudaromi iš atidarančių kabučių, sąrašo teiginių ir uždarančių kabučių.

				{
					<teiginių sąrašas>
				}

			Blokas leidžia įrašyti kelis teiginius, kur sintaksė palaiko tik vieną. Vykdant kodo bloką, jame esantys teiginiai yra vykdomi paeiliui.

			Kodo bloke deklaruoti kintamieji galioja tik iki blogo galo, todėl blokai taip pat naudojami norint apriboti kintamojo galiojimo sirtį.

			Pavyzdys:

				{
					int a = 5;
					a++;
				}

			Kintamasis a galioja iki bloko pabaigos, bandymai jį naduoti vėliau gražins klaidą (nebent yra kitų kintamųjų vardu a).

				{
					int b = 5;
					{
						int a = b;
						b++;
					}

					Console.WriteLine(b);// išspausdintų 6
					Console.WriteLine(a);// bet yra klaida, kintamasis a čia neegzistuoja
				}

			Bloke kintamieji negali turėti to pačio vardo.

				{
					int a = 5;
					float a = 0.0; // klaida, kintamasis "a" jau deklaruotas
				}

			Tačiau, vardas gali būti vėl panaudojamas gilesniame bloke.

				{
					int a = 5;
					{
						Console.WriteLine(a);
						int a = 16;
						Console.WriteLine(a);
					}
					Console.WriteLine(a);
				}

			Ši programa išspausdins

				5
				16
				5

			Blokas gali būti tuščias. Toks blokas daro tą patį ką tuščias teiginys - visiškai nieko.

		2.6.2. Sąlygos sakinys

			Sąlygos sakinys naudojamas parinkti vykdomą teiginį pagal sąlygą.

				if (<sąlyga>)
					<teigiamas teiginys>
			
				if (<sąlyga>)
					<teigiamas teiginys>
				else
					<neigiamas teiginys>

			Sąlyga yra bet kokia "bool" tipo skaitoma išraiška.

			Jei sąlygos reikšmė yra "true", bus vykdomas tegiamas teiginys, jei "false" - neigiamas.

			"else" ir neigiamas teiginys gali būti praleisti.
			Pavyzdžiai:

				int num = GetNum();
				if (num >= 0)
					Console.WriteLine("Tegiamas skaičius");
				else
					Console.WriteLine("Neigiamas skaičius");

				num++;

				if (num < 0)
					return;

			"if" yra grupuojamas su artimiausiu "else" bloku. Norint sugrupuoti kitaip naudojami kodo blokai.

				int num = GetNum();
				if (num >= 0)
					if (num == 0)
						Console.WriteLine("Nulis");
				else
					Console.WriteLine("Neigiamas skaičius");

			Ši programa išspausdins "Neigiamas skaičius" visiems teigiamiems nenuliniams skaičiams, kadangi "else" yra grupuojamas su 
			artimiausiu "if". Pataisyta programa:

				int num = GetNum();
				if (num >= 0)
				{
					if (num == 0)
						Console.WriteLine("Nulis");
				}
				else
					Console.WriteLine("Neigiamas skaičius");


		2.6.3. Ciklai

			LaborasLang programavimo kalba palaiko trijų tipų ciklus: "while" tipo ciklą ir du "for" tipo ciklus.	
			;; Worde pakeisti kabutes į keyword style

			2.6.3.1. while ciklas
				
				while ciklas susideda iš dviejų dalių: ciklo sąlygos ir ciklo teiginio. Ciklas yra vykdomas tol, kol ciklo sąlyga 
				yra teisinga. Bendrą ciklo struktūrą galima aprašyti taip:

					while (<sąlyga>)
						<teiginys>

				Ciklo teiginys yra bet koks LaborasLang kalboje legalus teiginys (kodo blokas, sąlyga, ciklas ir t.t.).

				Sąlyga yra bet kokia "bool" tipo skaitoma išraiška.
				
				Keletas while ciklo pavyzdžių:

					while (foo-- > 0)
						Report(foo);

					while (IsValid(bar))
					{
						if (bar % 2 == 0)
							Console.WriteLine(bar);

						bar = Transform(bar);
					}

			2.6.3.2. C stiliaus for ciklas

				;; Mes teiginiais vadinam use, deklaciją, return, visokie ciklai yra kontrolės blokai. Reikia suvienodinti semantiką ir pataisyti taisyklę - D.

				LaborasLang kalba palaiko C stiliaus for ciklą - jis analogiškas C ciklui ir yra palaikomas daugumos C šeimos kalbų. 
				Šį for ciklą sudaro kelios dalys: ciklo inicializatorius, ciklo sąlyga, ciklo iteratorius ir ciklo teiginys. C stiliaus 
				for ciklo struktūra yra tokia: ;; nepasiskolinom o atėmėm A.

					for (<inicializatorius>; <sąlyga>; <iteratorius>)
						<teiginys>

				Kiekviena iš šio for ciklo atraštės dalių gali būti praleista.

				Ciklo inicializatorius, jei toks yra, privalo būti kintamojo deklaracija arba bet kokia LaborasLang išraiška. 
				Deklaracija gali būti su inicializacija arba be. Ši deklaracija sukuria lokalų kintamajį, kurio galiojimo sritis apima visą 
				ciklą.

				Ciklo sąlyga, jei tokia yra, privalo būti "bool" tipo skaitoma išraiška. Jei sąlygos nėra, ji pakeičiama išraiška "true".

				Ciklo iteratorius, jei toks yra, gali būti bet kokia išraiška.

				Ciklo teiginys yra bet koks LaborasLang teiginys, išskyrus "use" teiginį.

				Ciklo vykdymo tvaka:

					1. Jei aprašytas, įvykdomas ciklo inicializatorius.
					2. Įvykdoma ciklo sąlyga. Jei rezultatas nėra "true", baigiamas ciklo vykdymas.
					3. Įvykdomas ciklo teiginys. 
					4. Jei nebuvo išeita iš teiginio (pavyzdžiui "return" sakiniu) ir yra aprašytas iteratorius, jis yra įvykdomas.
						Vykdymas gražinamas į 2 punktą.

				;; Man šitas padeda suvokti kaip tiksliai vykdomas for - D.
				Naudojant "while" ciklą, "for" galima aprašyti taip:

					{
						<inicializatorius>;
						while (<sąlyga>)
						{
							<teiginys>;
							<iteratorius>;
						}
					}

				For ciklo pavyzdžiai:

					// Šis for ciklas spausdina "Spinning infinitely" be galo.
					for (;;)
						Console.WriteLine("Spinning infinitely");


					// Šis for ciklas atspausdina skaičius nuo 0 iki 9 imtinai.
					for (int i = 0; i < 10; i++)
						Console.WriteLine(i);


					// Šis ciklas analogiškas while ciklui
					for (; i < 10;)
					{
						Console.WriteLine(i);
						i++;
					}


			2.6.3.3. Kolekcijos iteravimo for ciklas

				Iteravimui per reikšmių kolekcijas dažnai naudojamas specialus ciklas, kitose kalbose vadinamas "foreach" ciklu. Šiame 
				cikle yra deklaruojamas kintamasis, kuris paeiliui įgyja visas rinkinio reikšmes. 

					for (<kintamojo tipas> <kintamojo pavadinimas> in <kolekcija>)
						<teiginys>

				Pagal kintamojo tipą ir pavadinimą yra deklaruojamas lokalus kintamasis. Šio kintamojo galiojimo sritis yra visas ciklas, 
				bet jo reikšmę galima tik perskaityti. Šis ciklas netinka, jei reikia modifikuoti kolekciją.

				Kolekcijos gali būti masyvai arba objektai turintys metodą GetEnumerator(). Kolekcijos išraiška bus įvykdyta vieną kartą 
				ir viso ciklo metu bus naudojamas tas pats enumeratorius. 
				;; čia gal tik biški BS.
				;; norėjau parašyti, kad jei iteruosi per call, nebus kviečiama 500 kartų - D.

				Kadangi iš kolekcijos visada galima sužinoti elemento tipą, dažnai deklracijoje naudojamas tipas "auto".

				Ciklo pavyzdžiai:

					// iteruojama per masyvą
					auto arr = int[] { 1, 2, 3, 4 };
					for (auto i in arr)
						Console.WriteLine(i);
					// išspausdins skaičius 1 - 4

					// iterauojama per kolekciją
					ArrayList lst = ...
					for (object i in lst)
						Console.WriteLine(i.ToString());
					// išspausdinami kolekcijos objektų tekstinės reprezentacijos ;; gal geresnis žodis tam yra - D.

3. LaborasLang gramatika

	Kalbos gramatika nusako kaip leksemos yra sudaromos į prasmingas struktūras

	3.1. Programos apibrėžimas

		Programa yra vienas ar daugiau išeities kodo failų.

		Išeities kodo failus sudaro matomieji ir nematomieji tarpai (whitespace), žetonai, komentarai.
		* Nematomieji tarpai yra tarpo, įtraukos, eilutės pabaigos bei kiti panašūs simboliai, kompiliavimo metu jie yra ignoruojami.
		* Komentarai atitinka C šeimos kalbų komentarus, tai yra galimi vienos eilutės komentarai kurie yra pradedami simboliais "//" bei
		tęsiami iki eilutės pabaigos simbolio ir bloko tipo komentarai pradedami "/*" simboliu ir baigiami "*/" simboliu. Komentarų
		turinys kompiliavimo metu yra ignoruojamas
		* Žetonai yra gaunami sujungiant gretimus simbolius į prasmingas maksimalaus ilgio leksemas, kurios yra toliau analizuojamos
		kompiliuojant programą. Žetonai yra tokie simboliai kaip
		"*", "+", "=", ";" bei ilgesni dariniai - "auto", "penki", "+=", "while" bei kiti. Žetonai naudojami sudaryti kalbos
		struktūras, kurios savo ruožtu sudaro programą.

	3.2. Dviprasmybės

		LaborasLang gramatikoje dviprasmybės yra gailimos tik sudarant žetonus. Jos yra sprendžiamos sudarant maksimalaus galimio ilgio
		žetonus. Tai yra taikoma valdant tokius žetonus kaip "<<", "++", "--", tai reiška kad nors teiginys "i = i--1" galėtų būti 
		transformuotas į "i = i - (-1)" dėl žetonų ilgio maksimizavimo jis bus suprastas kaip "i = (i--) 1", kas yra nevalidus kodas (
		nėra jokio operatoriaus tarp dviejų operandų).

	3.3. Leksinė gramatika

		Leksiniu požiūriu gramatika nurodo kaip leksemos yra formuojamos į sakinius.

		Gramatiką sudaro aibė paprastų leksemų kurios sudaro programos kodą:
		
		LaborasLang gramatikoje naudojama aibė žetonus atitinkančių taisyklių:							

			;; Čia turėtų gautis kelios lentelės - A.
			Specialūs simboliai
			EndOfLine 				;
			Comma 					,
			Else 					else
			If 						if
			Return 					return
			Use 					use
			Virtual 				virtual
			While 					while
			For 					for
			In 						in

			Literalai
			CharLiteral 			'simbolis'
			StringLiteral 			"simbolių eilutė"
			Integer 				0
			Float 					0.0f
			Long 					0l
			Double 					0.0
			False 					false
			True 					true
			Null 					null

			Simbolis
			Symbol 					foo

			Sklaustai
			LeftCurlyBrace 			{
			RightCurlyBrace 		}
			LeftParenthesis 		(
			RightParenthesis 		)
			LeftBracket 			[
			RightBracket 			]

			Dvinariai operatoriai (InfixOperator)
			Period 					.
			BitwiseAnd 				&
			BitwiseAndEqual 		&=
			Plus 					+
			Minus 					-
			MinusEqual 				-=
			NotEqual 				!=
			PlusEqual 				+=
			BitwiseXor 				^
			BitwiseXorEqual 		^=
			BitwiseOr 				|
			BitwiseOrEqual 			|=
			LeftShiftEqual 			<<=
			LeftShift 				<<
			LessOrEqual 			<=
			Less 					<
			LogicalAnd 				&&
			LogicalAndEqual 		&&=
			LogicalOr 				||
			LogicalOrEqual 			||=
			More 					>
			RightShift 				>>
			RightShiftEqual 		>>=
			MoreOrEqual 			>=
			Divide 					/
			DivideEqual 			/=
			Multiply 				*
			MultiplyEqual 			*=
			Remainder 				%
			RemainderEqual 			%=
			Assignment 				=
			Equal 					==

			Vienanariai operatoriai
			PlusPlus 				++
			MinusMinus 				--
			Not 					!
			BitwiseComplement 		~

			Deklaracijų modifikatoriai (VariableModifier)
			Const 					const
			Private 				private
			Public 					public
			Mutable 				mutable
			Entry 					entry

			Šios leksemos yra naudojamos aprašyti taisyklėms kartu naudojant kitas taisykles atstojančias leksemas.

		3.3.x. Kalbos taisyklės
			Taisyklėms aprašyti naudojama forma yra
				<taisyklės pavadinimas>:
					<kableliais atskirtas taisyklės alternatyvų sąrašas>

				alternatyvas taisyklei sudaro leksemos ir taisyklės, kurioms gali būti taikomi modifikatorai
					? - elementas yra neprivalomas, jei jo nėra taisyklė alternatyva vis dar gali būti validi
					* - elementas yra neprivalomas bei gali būti kartojamas kelis kartus jei jis yra.

				Šie modifikatoriai gali būti taikomi taisyklių grupėms jas apskliaudžiant.

			Program:
				CodeConstruct*

			LaborasLang programą sudaro daugiau nei nulis CodeConstruct, tai yra daugiau nei nulis kalbos struktūrų. Jų gali būti ir nulis,
			tačiau tokia programa nėra itin naudinga.

			CodeConstruct:
			    CodeBlockNode,
			    WhileLoop,
			    ForLoop,
			    ForEachLoop,
			    ConditionalSentence,
			    StatementWithEndOfLine

			Galimos kalbos struktūros yra kodo blokas, ciklas "while", ciklai "for" bei "foreach", sąlygos sakiniai, ar teiginiai kurie
			baigiasi kabliataškiu.

			CodeBlockNode:
			    LeftCurlyBrace + CodeConstruct* + RightCurlyBrace
			Kodo bloko kalbos struktūrą sudaro kairysis figūrinis skliaustas "{", nulis ar daugiau kitų kodo konstrukcijų bei dešinysis
			figūrinis skliaustas "}"

			StatementNode:
			    UseNode,
			    DeclarationNode,
			    Value,
			    ReturnNode
			
			Teiginius sudaro importavimo teiginys "UseNode", deklaravimo teiginys "DeclarationNode", reikšmė (nesvarbu ar kairinė ar
			dešininė) "Value", grąžinimo sakinys. Šie teiginiai gali būti naudojami kaip kalbos struktūros prie jų pridėjus kabliataškį:

			StatementWithEndOfLine:
			    StatementNode? EndOfLine
			Šioje struktūroje teiginys yra neprivalomas - reikia bent vieno kabliataškio, bet jei jie kartojasi kelis kartus programa yra
			vis dar validi.

			UseNode:
			    Use FullSymbol
			Importavimo teiginį sudaro raktažodį "use" atitinkanti leksema bei pilnas simbolis - tai yra simbolių atskirtų taškais
			 rinkinys, kitur jis gali būti suprantamas kaip kairinė reikšmė.

			DeclarationNode:
			    VariableModifier* Type Symbol (Assignment Value)?
			Deklaravimo teiginį sudaro neprivalomi kintamojo modifikatoriai, jo tipas, kintamojo pavadinimas bei neprivalomas priskyrimo
			operatorius su dešinine reiškme

			ReturnNode:
			    Return Value?
			Grąžinimo sakinį sudaro raktažodis "return" bei neprivaloma dešininė reikšmė. Reikšmė neprivaloma nes void tipo funkcijose
			galima išeiti iš funkcijos negrąžinant jokios reikšmės

			Value:
			    (PrefixNode PostfixOperator*) (InfixOperator PrefixNode PostfixOperator*)* 
			Dešinines reikšmes atitinka taisyklė "Value". Dešininės reikšmės yra sudarytos iš priešdėlinių operatorių, dvinarių operatorių ir galūninių operatorių. galimi operandai apskliaustos dešininės reikšmės, dešininės reikšmės su masyvo narių pasiekimo operatoriumi ([x]), literalai, simboliai, funkcijų kvietiniai.

			PrefixNode:
		        PrefixOperator PrefixNode,
		        PrefixOperator ParenthesesNode,
		        ParenthesesNode

			PostfixOperator:
			    PlusPlus, 
			    MinusMinus,
			    IndexNode,
			    FunctionArgumentsList

			FunctionArgumentsList:
			    LeftParenthesis RightParenthesis,
			    LeftParenthesis Value CommaAndValue* RightParenthesis
			Funkcijos argumentai yra skliaustuose esančios dešininės reikšmės atskirtos kableliais

			PrefixOperator:
			    PlusPlus, 
			    MinusMinus, 
			    Minus, 
			    Not,
			    BitwiseComplement,
			    CastOperator

			CastOperator:
			    LeftParenthesis Type RightParenthesis			            
			        
			IndexNode:
			    LeftBracket Value CommaAndValue* RightBracket,
			    LeftBracket Comma* RightBracket),
			        
			ParenthesesNode:
			    LeftParenthesis Value RightParenthesis,
			    Operand
			            
			           
			Operand:
			    ArrayLiteral,
			    Function,
			    Symbol,
			    LiteralNode,
			    Null

			LiteralNode:
			    Float,
			    Integer,
			    Double,
			    Long,
			    CharLiteral,
			    StringLiteral,
			    True,
			    False
		        
			ArrayLiteral:
			    Type InitializerList,
			    InitializerList
			Masyvo tipo literalus sudaro masyvo tipas bei figūriniuose skliaustuose esantis sąrašas kableliu atskirtų dešininių reikšmių.

			InitializerList:
			    LeftCurlyBrace Value CommaAndValue* RightCurlyBrace,
			    LeftCurlyBrace RightCurlyBrace

			CommaAndValue:
			    Comma Value

			FullSymbol:
			    Symbol SubSymbol*
			FullSymbol taisyklė apima kairinius elementus - tai yra taškais atskirti simboliai.

			SubSymbol:
			    Period Symbol

			Type:
			    FullSymbol ParameterList*
			Tipą laborasLang kalboaje sudaro pilnas simbolis bei neprivalomas parametrų sąrašas.			
			ParameterList:
			    FunctorParameters,   
			    IndexNode                     
			Parametrai gali būti masyvo tipo arba funkcijos tipo

			FunctorParameters:
			    LeftParenthesis Type (Comma Type)* RightParenthesis,
			    LeftParenthesis Type Symbol (Comma Type Symbol)* RightParenthesis,
			    LeftParenthesis RightParenthesis
			Funkcijos tipo tipo parametrai sudaryti iš tipų, ar tipų ir simbolių sąrašo atskirto kableliais.
			
			Function:
			    Type CodeBlockNode                    
			Pačią funkciją sudaro tipas bei kodo blokas kuris bus vykdomas iškvietus funkciją.

			Išskiriami trys ciklų tipai ciklas "while", ciklas "foreach" bei ciklas "for"
			WhileLoop:
			    While LeftParenthesis Value RightParenthesis CodeConstruct
			ciklą while sudaro raktažodis "while", apskliausta dešininė reikšmė, bei kodo struktūra kuri bus kartojama

			ForEachLoop:
			    For LeftParenthesis Type Symbol In Value RightParenthesis CodeConstruct
			ciklą "foreach" sudaro raktažodis "for", skliaustuose esanti konstrukcija sudaryta iš iteravimo kintamojo deklaravimo,
			raktažodžio "in" bei dešininės reikšmės per kurią bus iteruojama
			
			ForLoop:
			    For LeftParenthesis Value? EndOfLine Value? EndOfLine Value? RightParenthesis CodeConstruct,
			    For LeftParenthesis DeclarationNode? EndOfLine Value? EndOfLine Value? RightParenthesis CodeConstruct
			paprastas "for" ciklas naudojamas taip pat kaip kitose C šiemos kalbose - naudojamas raktažodis "for", skliaustuose trys kodo
			segmentai atskirti kabliataškiais, kuriuose iš eilės aprašoma kintamojo deklaracija, dešininė reikšmė kuri atitinka ciklo
			sąlygą, bei teiginys kuris bus vykdomas kiekvienos po kiekvienos iteracijos. Šie segmentai gali neturėti jokio turinio.

			ConditionalSentence:
			    If LeftParenthesis Value RightParenthesis CodeConstruct (Else CodeConstruct)?
			sąlygos sakinys sudaromas iš raktažodžio "if", apskliaustos dešininės reikšmės, kodo struktūros kuri bus vykdoma jei sąlyga
			yra teisinga bei neprivalomo "else" raktažodžio kartu su kodo struktūra kuri bus vykdoma jei sąlyga yra neteisinga

4. LaborasLang programų pavyzdžiai	;; TODO: make sure everything builds and actually works

	;; Truksta ivadinio sakinio

	4.1. Hello world

		Tradicinė programa, atspausdinanti "Hello, world!".

			use System;

			entry auto Main = void()
			{
				Console.WriteLine("Hello, world!");
			};

	4.2. Begalinė rekursija

		Ši programa demonstruoja LaborasLang galinę rekursiją. Nors šioje programoje yra begalinė rekursija, ji niekada neperpildys dėklo, todėl programa veiks amžinai.

			auto IsEven = bool(int number)
			{
				return number % 2 == 0;
			};

			auto Func = void(int i)
			{
				if (IsEven(i))
				{
					System.Console.WriteLine("{0} is even", i);
					Func(i + 3);
				}
				else
				{
					System.Console.WriteLine("{0} is odd", i);
					Func(i + 5);
				}
			};

			entry auto Recursion = int()
			{
				Func(0);
				return 0;
			};

	4.3. Dainelė apie alaus butelius

		Ši programa atspausdina dainelės apie alaus butelius tekstą.

			use System;

			entry auto BeerBottleSong = int()
			{
				auto count = 99;
				Console.WriteLine("{0} on the wall, {0}.", Bottles(count));

				while ((count -= 1) >= 0)
				{
					Console.WriteLine("Take one down and pass it around, {0} on the wall.", Bottles(count));
					Console.WriteLine();
					Console.WriteLine("{0} on the wall, {0}.", Bottles(count));
				}
	
				Console.WriteLine("Go to the store and buy some more, {0} on the wall.", Bottles(99));
				Console.ReadKey();
				return 0;
			};

			auto Bottles = string(int count)
			{
				string ret;

				if (count > 0)
				{
					ret += count;

					if (count > 1)
					{
						ret += " bottles ";
					}
					else
					{
						ret += " bottle ";
					}
				}
				else
				{
					ret += "no more bottles ";
				}

				ret += "of beer";
				return ret;
			};

	4.4. Pirminiai skaičiai

		Ši programa spausdina, ar įvesti skaičiai yra pirminiai. Programa baigia darbą, kai įvedamas 0.

			use System;

			entry auto Main = void()
			{
				auto quit = false;
				Console.WriteLine("Enter 0 at any time to quit.");

				while (!quit)
				{
					int value;
					string line = Console.ReadLine();

					if (int.TryParse(line, value))
					{
						if (value == 0)
						{
							quit = true;
						}
						else
						{
							if (IsPrime(value))
							{
								Console.WriteLine("{0} is a prime number", value);
							}
							else
							{
								Console.WriteLine("{0} is not a prime number", value);
							}
						}
					}
					else
					{
						Console.WriteLine("Entered value is not a number!");
					}
				}
			};

			auto IsPrime = bool(int value)
			{
				if (value < 2)
					return false;
	
				auto isDivisor = bool(int value, int divisor) { return value % divisor == 0 && divisor < value; };

				auto isPrime = true;
				auto divisor = (int)Math.Sqrt(value) + 2;

				while (--divisor >= 2)
				{
					if (isDivisor(value, divisor))
						return false;
				}

				return true;
			};

	4.5. Interneto svetainės pavadinimas

		Pateikta programa iš įvestos interneto svetainės parsiunčia jos pavadinimą.

			use System;
			use System.IO;
			use System.Net;

			entry auto Main = int()
			{
				auto website = Console.ReadLine();
				auto webResponse = WebRequest.Create(website).GetResponse();
				auto reader = StreamReader(webResponse.GetResponseStream());
				auto html = reader.ReadToEnd();

				reader.Close();
				webResponse.Close();
	
				const auto titleOpeningTag = "<title>";
				const auto titleClosingTag = "</title>";
				auto titleStartIndex = html.IndexOf(titleOpeningTag, StringComparison.InvariantCultureIgnoreCase) + titleOpeningTag.Length;
				auto titleEndIndex = html.IndexOf(titleClosingTag, titleStartIndex, StringComparison.InvariantCultureIgnoreCase);
				auto pageTitle = html.Substring(titleStartIndex, titleEndIndex - titleStartIndex);

				Console.WriteLine(pageTitle);
				Console.ReadKey();
				return 0;
			};

	4.6. Paprastas skaičiuotuvas

		Ši programa yra paprastas skaičiuotuvas, galintis atlikti keturias aritmetines operacijas: sudėti, atimti, dauginti ir dalinti.
		Ji grafinei sąsajai naudoja Windows Forms karkasą.

			use System;
			use System.Drawing;
			use System.Globalization;
			use System.Text;
			use System.Windows.Forms;

			TextBox firstNumberTextBox;
			TextBox secondNumberTextBox;
			ComboBox operationComboBox;
			TextBox resultTextBox;

			Button calculateButton;

			const string kAdd = "Add";
			const string kSubtract = "Subtract";
			const string kMultiply = "Multiply";
			const string kDivide = "Divide";

			auto ValidateTextBox = void(object sender, EventArgs e)
			{
				auto textBox = (TextBox)sender;
				int decimalCount = 0;
				bool hasErrors = false;
				auto caretPosition = textBox.SelectionStart;

				for (int i = 0; i < textBox.Text.Length && !hasErrors; i++)
				{
					auto c = textBox.Text[i];

					if (c == '.')
					{
						decimalCount++;

						if (decimalCount > 1 || i == 0)
						{
							hasErrors = true;
						}
					}
					else if (c < '0' || c > '9')
					{
						hasErrors = true;
					}
				}
	
				if (!hasErrors)
					return;

				auto builder = StringBuilder();
				builder.Capacity = textBox.Text.Length;
				decimalCount = 0;
	
				for (int i = 0; i < textBox.Text.Length; i++)
				{
					auto c = textBox.Text[i];
		
					if (c >= '0' && c <= '9')
					{
						builder.Append(c);
					}
					else if (c == '.' && decimalCount == 0 && i > 0)
					{
						builder.Append(c);
						decimalCount++;
					}
					else if (i < caretPosition)
					{
						caretPosition--;
					}
				}

				textBox.Text = builder.ToString();
				textBox.Select(caretPosition, 0);
			};

			entry auto Main = void()
			{
				Application.EnableVisualStyles();
				Application.SetCompatibleTextRenderingDefault(false);

				const auto boxSize = Size(136, 20);
				const auto labelSize = Size(60, 20);
				const auto windowSize = Size(300, 350);

				const auto kControlCount = 4;
				const auto xPositions = { 20, 100 };
				const auto yPositions = { 30, 90, 150, 210, 270 };
		
				auto labels = Label[kControlCount];
				auto labelTexts = { "Number 1", "Operation", "Number 2", "Result" };
				auto controls =
				{
					firstNumberTextBox = TextBox(),
					operationComboBox = ComboBox(),
					secondNumberTextBox = TextBox(),
					resultTextBox = TextBox()
				};

				for (int i = 0; i < kControlCount; i++)
				{
					auto label = labels[i] = Label();
					label.Text = labelTexts[i];
					label.Location = Point(xPositions[0], yPositions[i]);
					label.Size = labelSize;
					label.TextAlign = ContentAlignment.MiddleRight;

					auto control = controls[i];
					control.Location = Point(xPositions[1], yPositions[i]);
					control.Size = boxSize;
					control.TabIndex = i;
				}
	
				firstNumberTextBox.add_TextChanged(ValidateTextBox);
				secondNumberTextBox.add_TextChanged(ValidateTextBox);

				operationComboBox.Items.AddRange({ kAdd, kSubtract, kMultiply, kDivide });
				operationComboBox.DropDownStyle = ComboBoxStyle.DropDownList;
				operationComboBox.SelectedIndex = 0;
				resultTextBox.ReadOnly = true;

				calculateButton = Button();
				calculateButton.Size = Size(75, 25);
				calculateButton.TabIndex = 4;
				calculateButton.Text = "Calculate";
				calculateButton.Location = Point(xPositions[1], yPositions[4]);
				calculateButton.UseVisualStyleBackColor = true;
				calculateButton.add_Click(void(object sender, EventArgs e)
				{
					auto leftText = firstNumberTextBox.Text;
					auto rightText = secondNumberTextBox.Text;
		
					if (leftText[leftText.Length - 1] == '.')
						leftText += '0';

					if (rightText[rightText.Length - 1] == '.')
						rightText += '0';

					auto leftOperand = double.Parse(leftText, CultureInfo.InvariantCulture);
					auto rightOperand = double.Parse(rightText, CultureInfo.InvariantCulture);
					auto operation = operationComboBox.SelectedItem;
					double result;

					if (operation == kAdd)
					{
						result = leftOperand + rightOperand;
					}
					else if (operation == kSubtract)
					{
						result = leftOperand - rightOperand;
					}
					else if (operation == kMultiply)
					{
						result = leftOperand * rightOperand;
					}
					else
					{
						result = leftOperand / rightOperand;
					}

					resultTextBox.Text = result.ToString(CultureInfo.InvariantCulture);
				});

				auto window = Form();
				window.Controls.AddRange(labels);
				window.Controls.AddRange(controls);
				window.Controls.Add(calculateButton);
				window.MinimumSize = windowSize;
				window.MaximumSize = windowSize;
				window.MaximizeBox = false;
				window.Text = "Simple Calculator";

				Application.Run(window);
			};

5. Pavyzdinis kompiliatorius

	;; Truksta ivadinio sakinio

	5.1. Komponentai
	
		;; Truksta ivadinio sakinio
		5.1.1. Lekseris

			Šis modulis iš programos išeities kodo sugeneruoja abstraktų sintaksės medį kuris yra toliau naudojamas semantinėje analizėje.
			Abstraktaus sintaksės medžio generavimas atliekamas trimis žingsniais:
				1. Išeities kodo skaidymas žetonais (leksemomis)
				2. Pirminis žetonų formavimas į abstraktų sintaksės medį
				3. AST medžio apdorojimas baigiamosiomis doroklėmis (post processors)
			Pirmas žingsnis atliekamas "Tokenizer" komponento, antrasis - "Syntax matcher" modulio, trečiasis "Post processor" modulio. 
				;;todo išversti šitus žodžius, gal Jusas pasiūlys kokias lietuviškas alternatyvas
				;; Jusas sakė neversti - T.
				
			Lekserį sudaro šie komponentai:

			Tokenizer
				Šis komponentas iš išeities kodo teksto sugeneruoja sąrašą leksemų kurios turi tam tikrą tipą, turinį, vietą pradiniame
				išeities kode.
				RulePool
				Šis komponentas yra statinis kalbos gramatinių taisyklių sąrašas kuris naudojamas SyntaxMatcher modulio. Šis modulis
				nusako visą abstraktaus sintaksės medžio struktūrą kuri bus išlaikoma iki apdorojomo baigiamosiomis daryklėmis. Visos 
				aprašytos taisyklės yra bekontekstės, naudojama PEG gramatika. Konteksto nebuvimas apsunkina operatorių analizę, dėl to
					jų operacijų prioritetą atitinkantis medis yra suformuojamas baigiamosiomis daryklėmis.
			SyntaxMatcher
				Šis komponentas analizuoja leksemų sąrašą ir iš jo suformuoja medį pagal RulePool modulyje aprašytas taisykles.
			PostProcessors
				Šis komponentas leidžia atlikti kontektines operacijas su abstrakčiu sintaksės medžiu. Tai panaudojama atlikti veiksmus kurie
				yra labai sudėtingi naudojant PEG gramatiką. Šie veiksmai yra:
					Operatorių prioritetizavimas
					Funkcijų ir masyvų atskyrimas
					Neigiamų skaičių atpažinimas
					Taško operatoriaus apdorojimas
					Perteklinių medžio šakų minimizavimas

			5.1.1.1. Tokenizer ("Žetonatorius")

				Išeiteis kodas suskaidomas į leksemas. Leksema yra sudaryta iš jos turinio, tipo, vietos išeities kode.

				5.1.1.1.1. veikimo principas

					Modulio veikimo principas - iš eilės skaitomas tekstas po vieną simbolį kol nuskaityti simboliai gali būti sujungti į vieną 
					leksemą, pvz tekstas {code}pirmas=antras+trečias;{code} bus pradėtas skaityti, pirmas rastas simbolis yra raidė 'p', iš to 
					galima nuspręsti kad tai bus simbolis. Šis simbolis skaitomas kol bus rasta raidė netinkama simboliams - '=', tada simbolis 
					bus užsaugotas, patikrita ar tai yra vienas iš rezervuotų žodžių tam kad nustatyti teisingą tipą ir pridėtas į leksemų sąrašą. 
					Analogiškai bus apdorojamas ir likęs išeities kodas.

				5.1.1.1.2. Testavimas

					Modulis testuojamas naudojant išeities kodo pavyzdžius kurie sudaryti taip kad testais būtų padengtas visas šio modulis. 
					Testai vyikdomi sugeneruojant leksemų sąrašą ir jį lyginant su anksčiau sugeneruotu leksemų sąrašu. Jei leksemų sąrašai 
					nesutampa apie tai pranešama programuotojui ir jie patikrinami, lyginant su siekiamu rezultatu. Pagal tai ar atitinka 
					rezultatą nusprendžiama ar testas yra sėkmingas ar nesėkmingas. Visi gauti sąrašai yra serializuojami ir saugomi kartu 
					su testų duomenų sąrašu.

			5.1.1.2. RulePool ("Taisyklių sąrašas")

				Saugomas kalbos gramatikos taisyklių sąrašas. Naudojama gramatika kuri yra panaši į PEG gramatiką.
				Taisyklės yra sudaromos iš terminalinių ir neterminalinių žetonų. Kiekvienam neterminaliniam žetonui yra nurodoma taisyklė 
				kuri jį aprašo terminaliniais ir neterminalianiais žetonais. Vieną neterminalinį žetoną galima aprašyti keliomis skirtingomis 
				taisyklėmis, jos bus taikomos iš eilės pagal deklaravimo tvarką. Taisyklėse naudjoami terminalinių ir neterminalinų žetonų 
				modifikatoriai: 
					* Vienas arba daugiau
					* nulis arba daugiau
					* neprivalomas galas
					* neprivalomas

				Modifikatorius "Vienas arba daugiau"
					Naudojamas nurodyti kad šis elementas gali kartotis vieną arba daugiau kartų
				Modifikatorius "Nulis arba daugiau"
					Naudojamas nurodyti kad šis elementas gali kartotis nulį arba daugiau kartų. Gramatikoje naudojamas nurodyti neprivalomus 
					deklaracijos modifikatorius, vienanarius operatorius. 
				Modifikatorius "Neprivalomas galas"
					Šis modifikatorius naudojamas deklaracijose, juo nurodoma kad deklaracijose reikšmės priskyrimas nėra privalomas. Šis 
					operatorius gali būti pakeistas rekursiniu kreipiniu, tačiau toks kreipinys nėra optimalus dėklo naudojimo požiūriu bei 
					taisyklių skaitomumo atžvilgiu.
				Modifikatorius "Neprivalomas"
					Šis modifikatorius naudojamas nurodant neprivalomus žetonus. Šio modifikatoriaus naudojimo galima išvengti aprašant 
					alternatyvias taisykles.

				Taip pat taisyklės gali būti apibrėžtos kaip:
					* Taisyklė
					* Minimizuojama taisyklė
					* Visada minimizuojama taisyklė
				Minimizuojama ir visada minimizuojama taisyklės yra naudojamos tarpinių abstraktaus sintaksės medžio narių aprašymui kurie 
				turi prasmę tik leksikografinėje analizėje, tokie kaip "Kablelis ir reikšmė".

				Taisyklės palaiko ribotą rekursiją. Jos apribojimas yra tai kad rekursinis kreipinys privalo turėti bent vieną nerekursinį 
				kreipinį prieš rekursinį taisyklės panaudojimą. Nepaisant to tiesioginė rekursija taisyklių sąraše yra nenaudojama.

				5.1.1.2.1. Testavimas

					Taisyklių sąrašas testuotas jį naudojant sintaksės atpažinimo modulyje bei atliekant taisyklių analizę:
						Tikrinama ar nėra nenaudojamų taisyklių
						Tikrinama ar visi galimi žetonai yra apibrėžti taisyklėse
						Tikrinama ar nėra begalinės rekursijos taisyklėse 

			5.1.1.3. SyntaxMatcher ("Sintaksės atpažinimo sistema")
			
				Šis modulis leksemų sąrašą performuoja į abstraktų sintaksės medį pagal taisyklių sąrašą.

				5.1.1.3.1. veikimo principas

					Syntax matcher nauoja taisyklių sąrašą kad sugeneruoti teisiną ast iš rule pool'o. Viskas pradedama nuo pagrindinės taisyklės
					kuri nusako programos struktūrą, tai yra aibė sakinių. Taisyklės taikomos jų neterminalines leksemas keičiant kitomis 
					taisyklėmis ir jas pritaikant. Jei bent viena alternatyva iš taisyklės sprendimų tinka tai ji pridedama į AST, jei ne
					- nepridedama, ir mėginama kita alternatyvi taisyklė. Taip kiekviena neterminalinė taisyklė yra išskleidžiama iki 
					terminalinių žetonų kurie atitinka leksemų sąrašo narius. Jei nei viena taisyklė netiko, laikoma, kad išeities kodas yra 
					su klaidomis, tačiau kompiliavimas nėra nutraukiamas. SyntaxMatcher bando surasti iš kur 
					galėtų vėl pradėti analizę, ieškodamas simbolių ';' ir '{'. Simboliai kurie nėra pridėti į AST ir yra iki to recovery point ;; Sugalvok kaip recovery point išverst - T.
					pridedami prie AST kaip Unknown node. Tai leidžia pranešti daugiau nei vieną klaidą kompiliacijos metu. Syntax matcher 
					taisyklių taikymas yra godus, jei taisyklė tinka tai ji yra pritaikoma ir kitos nemėginamos, laikoma, kad pirma tikusi 
					taisyklė yra geriausia. Taisyklės yra prioretizuotos, jų deklaravimo tvarka nurodo prioritetą, dėl to išvengiama vietų 
					kur gali būti pritaikyta daugiau nei viena taiskylė. 
					Toks syntax matcher veikimo algoritmas yra prastas atminties naudojimo atžvilgiu, nes pastoviai deklaruojama labai daug 
					AST nodes kurie yra nebenaudojami - jei kokia taisyklė sufailino yra grįžtama iki jos alternatyvos, dėl to daug objektų ;; "sufailino"? Seriously? - T.
					tampa nebenaudojami ir GC turi juos visus surinkti. Tai darė didelę įtaką analizės greičiui, dėl to sudarant AST
					naudojamas specialiai parašytas alokatorius. Aprašyta klasė RootNode, kuri atitinka atminties valdymo objektą, kuris suteikia 
					resursus. Tai leidžia pranešti, kad tam tikra medžio šaka nebus naudojama ir ją galima pernaudoti tolimesniam medžio ;; Gramatiką pataisiau, bet paskutinis sakinys makes no sense whatsoever - T.
					formavimui, taip išvengiant bereikalingų objektų alokacijų ir deadlokacijų.											 ;; Gal būtų verta plačiau aprašyt apie jo veikimą? - T.

					Galima teigti, kad šis modulis yra bekontekstis lexeris, nes nėra saugoma jokia globali būsena kuri naudojama tikrinti ;; Ištrinčiau "Galima teigti, kad", nes lexeris toks ir yra - T.
					leksemų sąrašui, jis yra lyginamas tik su taisyklių sąrašu. Tai leidžia naudoti metaprogramą - taisyklių sąrašą ir jo 
					interpretatorių - SyntaxMatcher. Taip labai lengvai atskirtas taisyklės nuo jų pritaikymo logikos, tas leido RulePool ;; I can't comprehend that again'
					naudoti kaip dalinę AST dokumentaciją.

					Šio modulio sugeneruotas AST yra laikomas specifiniame optimizuotame formate - RootNode valdomame atminties bloke. Nors 
					jis yra optimalus atminties naudojimo atžvilgiu brute force taisyklių taikymo metu, jis tampa sudėtingu, kai reikia naudoti 
					post procesorius. Dėl to po syntax matcher praleidimo jis yra keičiamas paprastu adt-ish medžiu.

				5.1.1.3.2. Testavimas

					SyntaxMatcher testuojamas regresiniais testais. Naudojant abię išeities kodo pavyzdžių yra sugeneurojami ast kurie yra lyginami 
					su modifikuoto rulePool ast. Tai leidžia paprastai sukurti naujus testus - užtenka parašyti kodo gabaliuką ir peržiūrėti 
					sugeneruotą AST dėl korektiškuom. Tokio testavimo trūkumai - kartu su išeities kodu reikia saugoti serializuotus ast, jei 
					keičiasi medžio API reikia pergeneruoti ir rankois patikrinti daug failų.
					Testuose taip pat tikrinama kad medžiuose nėra nei vieno UnknownNode kuris rieškia kad neišėjo pritaikyti nei vienos taisyklės 
					šiam kodo blokui.

			5.1.1.4. PostProcesorius

				PostProcesoirius yra hackas skirtas pridėti kontekstą į bekontekstinį lexerį. Post procesoriai vykdomi iteruojant per ast ir 
				tikrinant kuris simbolis rastas, jie gali būti keičiami, restrukūtrizuojami, pašalinami. Aktyvšs post'ai:
					Operatorių prioritetizavimas
					Funkcijų ir masyvų atskyrimas
					Neigiamų skaičių atpažinimas
					Taško operatoriaus apdorojimas
					Perteklinių medžio šakų minimizavimas

				5.1.1.4.1. Operatorių prioritetizavimas

					Naudojamas Dijkstros Shunting yard algoritmas infix notacijos vertimui į medžio formos postfix notaciją. Toks metodas parinktas ;; wtf yra infix? Paaiškink, nes aš pats nesuprantu - T.
					dėl sudėtingumo išreikšiant operatorius per rule pool - jį sudėtinga debuginti, sudėtinga nustatyti okie pakitimai sulaužys 
					kitas taisykles. Po perėjimo prie psot'o pastebėtas ir gana žymus pagreitėjimas - taip nutiko dėl to kad kiekvienas value 
					eidavo per 10 bereikalingų taisykjlių lygių, tą panaikinus dabar eina tik per tris, tai reiškia kad kiekviena vertė, reiškėm, 
					function call yra išleksinami žymiai greičiau.

				5.1.1.4.2. Funkcijų ir masyvų atskyrimas:

					Kalbos gramatika nėra context free. function call ir tipai atrodo identiškai. Kadangi lexeris yra pritaikytas cfg 
					gramatikai funkcijų tipus teko analizuoti kontekstą turinčioje dalyje. Šis postas atpažysta ar tai yra funkcija ar taipas 
					ar masyvas.

				5.1.1.4.3. Neigiamų skaičių atpažinimas:
				
					Parseriui netiko kai minusas yra unary operatorius, reikia kad kai pirmas narys yra skaičius jis būtų neigiamas skaičius o 
					ne skaičius plius unary operatorius. Tai išsprendžiama šio post'o

				5.1.1.4.4. Taško opreratoriaus apdorojimas:

					Taškas yra įterpiamas trarp simbolių. Taip gaunamas sąrašįas kurio kas antras narys yra taškas. Tokį parseriui apdoroti 
					sunkiau, jis performuojamas į medį kuris sudarytas iš kairės, taško, dešinės - taškas tampa paprastu dvinariu operatoriumi.

				5.1.1.4.5. Perteklinių medžio šakų minimizavimas

					Kai kurie nodes yra nereikalingi - jie neturi jokio turinio, trukdo parseriui dirbti, dėl to jei jie yra tušti jie yra 
					collapsinami į. Taip gunamas mažesnis ir prpaastesnis medis. vėliau yra tikimasi panaikinti ir kitus nereikalingus 
					operatorius kaip taškas, kabliataškus, priskyrimas ar kita.
				
				5.1.1.4.6. Testavimas

					Rankomis suformuojamas siekiamas medžio snippet'as kuris yra lyginamas su gautu medžiu. Toks testavimo būdas parinktas vietoje 
					serializavimo dėl mažesnio postų sudėtingumo nei syntax matcherio ir sudėtingo analizavimo, nelabai aišku kaip medis geras ar 
					ne, jei jis formuotas rankomis tai galima nustatyti nesudėtingai. Šis metodas gali būti naudojamas ir paprasto lexerio 
					testavime, bet tai neturi įeiti į šią ataskaitą.
		
		5.1.2. Parseris
		5.1.3. Kodo generatorius
			
			Kodo generatorius yra kompiliatoriaus dalis, kuri tiesiogiai manipuliuoja CIL kodu ir metaduomenimis. Jį sudaro keletas subkomponentų:
				* Assembly Registry
				* Metadata Helpers
				* Assembly Emitter
				* Type Emitter
				* Method Emitter
				* Functor Emitter
				* Method Body Optimzers
			
			5.1.3.1. Assembly Registry
				 
				 Tai yra asemblių registras - jis užkrauna bibliotekas ir saugoja jų metaduomenis. Jo paskirtis yra suteikti kompiliatoriui
				 žinias apie egzistuojančius tipus, metodus, laukus ir t.t. ir juos pateikti patogiu formatu. Kompiliavimo pradžioje, ši klasė
				 užkrauna visas vartotojo nurodytas bibliotekas - t.y. jų asemblius. Tai padaręs, asemblių registras sužino visus užkrautuose
				 asembliuose esančius tipus ir jų vidurius. Asemblių registras gali:

					* Pasakyti, ar tam tikra vardų grupė egzistuoja;
					* Surasti tipą pagal jo vardą;
					* Surasti tipe esančius metodus pagal vardą;
					* Surasti tipe esantį metodą, kuris labiausiai tinka iškviesti su pateiktais argumentų tipais;
					* Surasti tipe esantį lauką pagal vardą;
					* Surasti tipe esančią sąvybę pagal vardą;
					* Surasti tipe esantį indekso operatoriaus sąvybę pagal argumentų tipus;
					* Surasti funkcijos tipą pagal jos grąžinamą tipą ir argumentų tipus;
					* Sukurti masyvo tipą pagal jo elemento tipą ir matmenų skaičių;
					* Surasti specialius kolekcijos tipo metodus įgalinančius jos iteravimą.

			5.1.3.2. Metadata Helpers

				Metadata Helpers - tai rinkinys funkcijų, skirtų padėti manipuliuoti metaduomenimis ir sužinoti jų sąvybes. Pagrindiniai Metadata Helpers

					* Pasakyti, ar tipas yra primityvus tipas, sveikasis skaičiaus tipas, slankiojančio kablelio skaičiaus tipas, funkcijos tipas ir t.t.;
					* Suskaičiuoti tipo dydį;
					* Nustatyti, ar vieno tipo kintamąjį galima priskirti kito tipo kintamajam;
					* Nustatyti, ar tipas paveldi kitą tipą visoje paveldimumo grandinėje;
					* Surasti tipo bazinį tipą;
					* Surasti visas sąsajas, kurias implementuoja tam tikras tipas;
					* Surasti nurodyto metodą deklaruojantį tipą;
					* Surasti nurodyto metodo grąžinamos reikšmės ir parametrų tipus;
					* Nustatyti, ar metodą galimą iškviesti su nurodytų tipų parametrais;
					* Nustatyti, ar tam tikras tipas, metodas ar laukas yra prieinami iš nurodyto tipo;
					* Importuoti tipą iš kito asemblio;
					* Nustatyti, ar per kolekciją galima iteruoti su kolekcijos iteravimo for ciklu.

				Assembly Registry ir Metadata Helpers subkomponentai įgalina kompiliatorių suprasti metaduomenų pasaulį ir leidžia parseriui validuoti visus
				LaborasLang programos atliekamus veiksmus.

			5.1.3.3. Assembly Emitter ir Type Emitter

				Assembly Emitter yra subkomponentas atsakingas už kompiliuojamo asemblio sukūrimą ir iššaugojimą diske. Kompiliatoriuje jis yra objektas, simbolizuojantis
				kompiliavimo rezultatą. Kiekvieną asemblį iš esmės yra tipų konteineris ir dėl to, Assembly Emitter viena iš pagrindinių funkcijų ir yra kaupti sukurtus tipus.
				
				Kita svarbi Assembly Emitter funkcija yra išsaugoti sukurtą asemblį diske. Prieš tai atlikdamas, Assembly Emitter atlieka keletą validacijos žingsnių:
					
					1. Patikrinti, ar asemblio tipuose nėra metodų su vienodais parametrų tipais. Tai yra geriausia vietą šiai validacijai atlikti, nes visi metodai tuo
					metu yra galutinai sukurti. Ši validacija reikalinga, nes CLI specifikacija reikalauja, jog viename tipe nebūtų daugiau, nei vieno metodo, turinčio
					tą patį vardą, tokį patį parametrų skaičių ir tokius pačius parametrų tipus ([1], §I.10.2 Overloading).

					2. Atmesti visus programoje nenaudojamus funkcijų tipus. Kadangi šiuo metu programa jau yra sukompiliuota, Assembly Emitter geba surasti ir išmesti visus
					funkcijų tipus, kurie buvo matyti programoje, bet realiai niekada nepanaudoti (pavyzdžiui, buvo deklaruota funkcija, kurios tipas void(), tačiau ji niekada
					niekam nebuvo priskirta).

					3. Jeigu asemblio tipas yra vykdomasis failas, patikrinti, ar yra metodas, esantis vykdomojo failo įeities taškas.

				Jei visi šie validacijos žingsniai pavyko, AssemblyEmitter gali saugiai išsaugoti asemblį diske.

				Type Emitter yra tiesioginis kuriamo tipo atitikmuo kompiliatoriuje. Jis tiesiogiai valdo tipų laukus, jų inicializatorius ir metodus.

			5.1.3.4. Method Emitter

				Method Emitter yra kodo generatoriaus širdis. Šis komponentas verčia parserio sudarytą medį tiesiai į CIL instrukcijas. 
				
				CIL yra dėklu pagrįsta žemo lygio objektinė programavimo kalba. Joje visos operacijos manipuliuoja duomenimis evaluacijos dėkle. Pavyzdžiui, prieš kviečiant funkciją,
				visi argumentai yra įstumiami į evaluacijos dėklą, o funkcijos grąžinama reikšmė yra reikšmė, esanti dėklo viršuje funkcijos pasibaigimo metu ([1], §I.12.1 Virtual Execution System).
				
				;; TO DO: linkas į parserio medžio aprašymą
				Method Emitter veikimas pagrįstas parserio medžio iteracija paieškos gylyn metodu. Kiekviena parserio medžio viršūnė yra aplankoma iš eilės
				ir paverčiama į atitinkamą CIL kodą. Kadangi CIL kodas operuoja reikšmėmis, esančiomis evaluacijos dėkle, Method Emitter gali tiesiogiai versti
				parserio medžio viršūnes į CIL instrukcijas nesirūpindamas jokia globalia būsena, tokia kaip procesoriaus registrų reikšmės.

				Pavyzdžiui, Method Emitter parserio medyje aptikęs dvinarės operacijos viršūnę, reiškiančia sudėtį, suformuos instrukcijas į evaluacijos dėklą įstumti 
				abu sudėties operandus rekursiškai aplankydamas jų viršūnes, ir tada suformuos CIL instrukciją "add", kuri sudeda dvi viršūtines evaluacijos dėklo reikšmės,
				o rezultatą įstumia atgal į evaluacijos dėklą.

				Kadangi kai kurios parserio medžio viršūnės tiesiogiai nesisieja su CIL instrukcijomis, Method Emitter kartais reikšmes turi saugoti laikinuosiuose kintamuosiuose.
				Šiam tikslui buvo panaudota speciali duomenų struktūra, kuri tiekia reikiamo tipo lokaliuosius kintamuosius, ir gali juos pernaudoti, kai Method Emitter žino, kad juose 
				laikomos reikšmės nebereikės.
			
			5.1.3.5. Functor Emitter
				
				LaborasLang kalba palaiko tipus, kurių kintamiesiems galima priskirti funkcijas. Kodo generatorius šiuos tipus vadinas funktoriais. Functor Emitter tikslas yra
				surformuoti šiuos tipus.

				Functor Emitter formuoja dviejų tipų funktorius: bazinius funktorius ir implementacijos funktorius.

				Kiekvienas funkcijos tipas LaborasLang kalboje atitinka vieną bazinį funktorių. Bazinis funktoriaus tipas yra abstrakti klasė, turinti du metodus:
					1. Invoke(), kuris priima savyje laikomos funkcijos parametrus ir grąžina funkcijos gražinamą reikšmę;
					2. AsDelegate(), kuris funktorių paverčia į CLI specifikaciją atitinkantį "delegate" objektą ([1], §I.8.9.3. Delegates). Šio gražinamo delegate objekto tipas yra
					deklaruotas kaip vidinis bazinio funktoriaus tipas.

				Funktoriaus implementacijos tipas paveldi iš atitinkančio bazinio tipo. Šis tipas yra sukuriamas, kai funkcijos tipo kintamajam yra priskiriama tam tikra funkcija.
				Šio tipo Invoke() metodas iškvies priskirtą funkciją, o AsDelegate() metodas sukurs delegate objektą kviečiamai funkcijai. Jei priskiriama funkcija nėra statinė, tai
				funktorius savyje taip pat laikys objektą, ant kurio ši funkcija turi būti iškviesta.

				Kai LaborasLang kalboje yra kviečiamas kintamasis, kuris yra funkcija, tai atitinka funktoriaus Invoke() metodo kvietimą.

			5.1.3.6. Method Body Optimizers
			
				Method Body Optimizers - metodų optimizatoriai - yra kodo generatoriaus dalis, kuri analizuoja ir optimizuoja Method Emitter sugeneruotą CIL kodą. Nors Method 
				Emitter stengiasi sugeneruotikuo efektyvesnį kodą, tai nėra visada įmanoma padaryti pereinant visą parserio medį tik vieną kartą. Dėl šios priežasties, metodų 
				optimizatoriai buvo pridėti į kodo generatorių.

				Šiuo metu, kompiliatoriuje yra keturi metodų optimizatorai. Iš jų kiekvienas yra pritaikytas optimizuoti skirtingus scenarijus.

				5.1.3.6.1. „nop“ instrukcijų šalinimas

					„nop“ instrukcija yra CIL instrukcija, kuri nieko nedaro. Ji naudojama kaip šuolių taikinys. Pavyzdžiui, jei sąlygos sakinyje sąlyga nėra išpildoma, tai vykdomas
					šuolis į „nop“ instrukciją, kuri įdedama po sąlygos kodo bloko. Šis optimizatorius iš metodo pašalina visas „nop“ instrukcijas, ir atnaujina visus šuolius, kad jų
					taikinys būtų sekanti instrukcija po pašalintosios.

				5.1.3.6.2. Perteklinių šuolių šalinimas

					Šis optimizatorius aptinka situaciją, kai vykdomas šuolis į instrukciją, kuri grįžta iš metodo. Aptikęs tokią situaciją, jis pakeičia šuolio instrukciją į grįžimo
					instrukciją. Šis optimizatorius padeda padidinti galinių kvietimų optimizacijos efektyvumą (žr. 5.1.3.6.4.). Pavyzdžiui, šis optimizatorius būtų vykdoma tokiai LaborasLang
					funkcijai:					

						auto Func = void(int i)
						{
							if (IsEven(i))
							{
								System.Console.WriteLine("{0} is even", i);
								Func(i + 3);	// Po šito, vyksta šuolis į funkcijos pabaigą. Šis optimizatorius padaro, kad vietoj šuolio, funkcija grįžtų.
							}
							else
							{
								System.Console.WriteLine("{0} is odd", i);
								Func(i + 5);
							}
						};

				5.1.3.6.3. Negyvo kodo šalinimas

					Šis optimizatorius pašalina visą kodą, kuriam gali įrodyt, kad jis niekada nebus pasiektas. Tai pagreita JIT kompiliavimą ir sumažina atminties naudojimą bei asemblio dydį.
					Optimizatorius visą metodą paverčia vienkrypčiu grafu: kiekviena instrukcija tampa viršūne, kurios kaimynės yra sekanti instrukcija, šuolio taikinys arba abu, jei šuolis yra
					sąlyginis. Sudarius grafą, vykdoma paieška gylyn ir pažymimos aplankytos viršūnės. Paieškos gale neaplankytos instrukcijos yra pašalinamos.

				5.1.3.6.4. Galinis metodo kvietimas

					Galinis metodo kvietimas - tai toks kvietimas, kuris neišsaugo dabartinės instrukcijų rodyklės adreso ir nepadidina vykdymo dėklo - tai yra pernaudoja 
					dėklo vietą, skirtą kviečiančiajam metodui. CLI specifikacija sako, jog galinis metodo kvietimas yra validus tik tada, jei po kvietimo iš kart grįžtama
					iš kviečiančiojo metodo ([1], §I.12.4.1.2 Calling instructions). Šis reikalavimas yra natūralus: kadangi instrukcijos rodyklė nėra įrašoma į dėklą, grįžtant
					iš iškviesto metodo yra grįžtama į praeitą metodą kvietimų dėkle, o ne šį dėklą. Jei po tokio kvietimoreiktų atlikti kokią nors kitą operaciją, ji niekada 
					nebūtų atlikta.

					Šis optimizatorius suranda visus metodų kvietimus, kuriuos gali paversti galiniai metodų kvietimais ir taip padaro. Dėl CLI reikalavimo, kad galinis metodo
					kvietimas gali būti atliekamas tik prieš grįžimo instrukciją, perteklinių šuolių optimizatorius turi galimybę smarkiai padidinti metodų kvietimų kiekį, kuriems
					atliema ši optimizacija.

	5.2. Komponentų integracija
	5.3. Testavimas
		5.3.1. Lekserio testavimas
		5.3.2. Parserio testavimas
		5.3.3. Kodo generatorius testavimas
			5.3.3.1. CIL kodo palyginimu grįsti testai
			5.3.3.2. Vykdymu grįsti testai
		5.3.4. Integracijos testavimas
		5.3.5. Kontraktai/statinė analizė

	5.4. Naudotos bibliotekos

	5.5. Vartotojo dokumentacija
		5.5.1. Išvesties tipai
		5.5.2. Bibliotekų nuorodos
		5.5.3. Šakninės direktorijos
6. Išvados
7. Literatūra

[1] - Standard ECMA-335 - Common Language Infrastructure (CLI) (http://www.ecma-international.org/publications/standards/Ecma-335.htm)
